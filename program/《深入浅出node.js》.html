<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/578220.jpg"><title>《深入浅出node.js》 | Leon Chen</title><meta name="description" content="">
    <link rel="modulepreload" href="/blog-site/assets/app.06e41ebd.js"><link rel="modulepreload" href="/blog-site/assets/《深入浅出node.js》.html.fb3fe7c6.js"><link rel="modulepreload" href="/blog-site/assets/《深入浅出node.js》.html.4ab30f1b.js"><link rel="modulepreload" href="/blog-site/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blog-site/assets/style.5c2fd74e.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog-site/" class=""><img class="logo" src="/blog-site/images/578220.jpg" alt="Leon Chen"><span class="site-name can-hide">Leon Chen</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外提升"><!--[--><!--]--> 课外提升 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="疑问清单"><!--[--><!--]--> 疑问清单 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外提升"><!--[--><!--]--> 课外提升 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="疑问清单"><!--[--><!--]--> 疑问清单 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">《深入浅出node.js》 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第1章-node简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="第1章 Node简介"><!--[--><!--]--> 第1章 Node简介 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_1-1-node特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 node特点"><!--[--><!--]--> 1.1 node特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_1-2-node的应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 Node的应用场景"><!--[--><!--]--> 1.2 Node的应用场景 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第2章-模块机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="第2章 模块机制"><!--[--><!--]--> 第2章 模块机制 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-1-commonjs模块规范" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 CommonJS模块规范"><!--[--><!--]--> 2.1 CommonJS模块规范 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-2-node模块的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 Node模块的实现"><!--[--><!--]--> 2.2 Node模块的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-3-核心模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 核心模块"><!--[--><!--]--> 2.3 核心模块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-4-c-c-拓展模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 C/C++拓展模块"><!--[--><!--]--> 2.4 C/C++拓展模块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-5-模块调用栈" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 模块调用栈"><!--[--><!--]--> 2.5 模块调用栈 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-6-包与npm" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 包与NPM"><!--[--><!--]--> 2.6 包与NPM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_2-7-前后端共用模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.7 前后端共用模块"><!--[--><!--]--> 2.7 前后端共用模块 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第3章-异步i-o" class="router-link-active router-link-exact-active sidebar-item" aria-label="第3章 异步I/O"><!--[--><!--]--> 第3章 异步I/O <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_3-1-为什么要异步i-o" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 为什么要异步I/O"><!--[--><!--]--> 3.1 为什么要异步I/O <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_3-2-异步i-o实现现状" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 异步I/O实现现状"><!--[--><!--]--> 3.2 异步I/O实现现状 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_3-3-node的异步i-o" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 Node的异步I/O"><!--[--><!--]--> 3.3 Node的异步I/O <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_3-4-非i-o的异步api" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 非I/O的异步API"><!--[--><!--]--> 3.4 非I/O的异步API <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_3-5-事件驱动与高性能服务器" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 事件驱动与高性能服务器"><!--[--><!--]--> 3.5 事件驱动与高性能服务器 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第4章-异步编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="第4章 异步编程"><!--[--><!--]--> 第4章 异步编程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_4-1-函数式编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 函数式编程"><!--[--><!--]--> 4.1 函数式编程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_4-2-异步编程的优势与难点" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 异步编程的优势与难点"><!--[--><!--]--> 4.2 异步编程的优势与难点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_4-3-异步编程解决方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 异步编程解决方案"><!--[--><!--]--> 4.3 异步编程解决方案 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_4-4-异步并发控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 异步并发控制"><!--[--><!--]--> 4.4 异步并发控制 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第5章-内存控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="第5章 内存控制"><!--[--><!--]--> 第5章 内存控制 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-1-v8的垃圾回收机制与内存限制" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 V8的垃圾回收机制与内存限制"><!--[--><!--]--> 5.1 V8的垃圾回收机制与内存限制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-2-高效使用内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 高效使用内存"><!--[--><!--]--> 5.2 高效使用内存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-3-内存指标" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 内存指标"><!--[--><!--]--> 5.3 内存指标 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-4-内存泄漏" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.4 内存泄漏"><!--[--><!--]--> 5.4 内存泄漏 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-5-内存泄漏排查" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.5 内存泄漏排查"><!--[--><!--]--> 5.5 内存泄漏排查 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_5-6-大内存应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.6 大内存应用"><!--[--><!--]--> 5.6 大内存应用 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第6章-理解buffer" class="router-link-active router-link-exact-active sidebar-item" aria-label="第6章 理解Buffer"><!--[--><!--]--> 第6章 理解Buffer <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_6-1-buffer结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.1 Buffer结构"><!--[--><!--]--> 6.1 Buffer结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_6-2-buffer的转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.2 Buffer的转换"><!--[--><!--]--> 6.2 Buffer的转换 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_6-3-buffer的拼接" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.3 Buffer的拼接"><!--[--><!--]--> 6.3 Buffer的拼接 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第7章-网络编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="第7章 网络编程"><!--[--><!--]--> 第7章 网络编程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_7-1-构建tcp服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.1 构建TCP服务"><!--[--><!--]--> 7.1 构建TCP服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_7-2-构建udp服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.2 构建UDP服务"><!--[--><!--]--> 7.2 构建UDP服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_7-3-构建http服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.3 构建HTTP服务"><!--[--><!--]--> 7.3 构建HTTP服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_7-4-构建websocket服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.4 构建WebSocket服务"><!--[--><!--]--> 7.4 构建WebSocket服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_7-5-网络服务与安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.5 网络服务与安全"><!--[--><!--]--> 7.5 网络服务与安全 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第8章-构建web应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="第8章 构建Web应用"><!--[--><!--]--> 第8章 构建Web应用 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_8-1-基础功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.1 基础功能"><!--[--><!--]--> 8.1 基础功能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_8-2-数据上传" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.2 数据上传"><!--[--><!--]--> 8.2 数据上传 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_8-3-路由解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.3 路由解析"><!--[--><!--]--> 8.3 路由解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_8-4-中间件" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.4 中间件"><!--[--><!--]--> 8.4 中间件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_8-5-页面渲染" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.5 页面渲染"><!--[--><!--]--> 8.5 页面渲染 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第9章-玩转进程" class="router-link-active router-link-exact-active sidebar-item" aria-label="第9章 玩转进程"><!--[--><!--]--> 第9章 玩转进程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_9-1-服务模型的变迁" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.1 服务模型的变迁"><!--[--><!--]--> 9.1 服务模型的变迁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_9-2-多进程架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.2 多进程架构"><!--[--><!--]--> 9.2 多进程架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_9-3-集群稳定之路" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.3 集群稳定之路"><!--[--><!--]--> 9.3 集群稳定之路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_9-4-cluster模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.4 Cluster模块"><!--[--><!--]--> 9.4 Cluster模块 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第10章-测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="第10章 测试"><!--[--><!--]--> 第10章 测试 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_10-1-单元测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.1 单元测试"><!--[--><!--]--> 10.1 单元测试 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_10-2-性能测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.2 性能测试"><!--[--><!--]--> 10.2 性能测试 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#第11章-产品化" class="router-link-active router-link-exact-active sidebar-item" aria-label="第11章 产品化"><!--[--><!--]--> 第11章 产品化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-1-项目工程化" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.1 项目工程化"><!--[--><!--]--> 11.1 项目工程化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-2-部署流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.2 部署流程"><!--[--><!--]--> 11.2 部署流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-3-性能" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.3 性能"><!--[--><!--]--> 11.3 性能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-4-日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.4 日志"><!--[--><!--]--> 11.4 日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-5-监控报警" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.5 监控报警"><!--[--><!--]--> 11.5 监控报警 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-6-稳定性" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.6 稳定性"><!--[--><!--]--> 11.6 稳定性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E3%80%8B.html#_11-7-异构共存" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.7 异构共存"><!--[--><!--]--> 11.7 异构共存 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="第1章-node简介" tabindex="-1"><a class="header-anchor" href="#第1章-node简介" aria-hidden="true">#</a> 第1章 Node简介</h2><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJCh6.jpg" alt="gjJCh6.jpg"></p><h3 id="_1-1-node特点" tabindex="-1"><a class="header-anchor" href="#_1-1-node特点" aria-hidden="true">#</a> 1.1 node特点</h3><ul><li><p>异步I/O</p></li><li><p>事件与回调函数</p></li><li><p>单线程 与其余线程是无法共享任何状态的 弱点：</p><ol><li>无法利用多核Cpu。</li><li>错误会引起整个应用退出，应用的健壮性值得考验。</li><li>大量计算占用cpu导致无法继续调用异步I/O。</li></ol><p><code>child_process</code>解决单线程大计算量的问题。</p></li><li><p>跨平台</p></li></ul><h3 id="_1-2-node的应用场景" tabindex="-1"><a class="header-anchor" href="#_1-2-node的应用场景" aria-hidden="true">#</a> 1.2 Node的应用场景</h3><ul><li><p>I/O密集型</p></li><li><p>CPU密集型业务</p></li><li><p>与遗留系统和平共处</p><p>取长补短</p></li><li><p>分布式应用</p></li></ul><h2 id="第2章-模块机制" tabindex="-1"><a class="header-anchor" href="#第2章-模块机制" aria-hidden="true">#</a> 第2章 模块机制</h2><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJAje.jpg" alt="gjJAje.jpg"></p><h3 id="_2-1-commonjs模块规范" tabindex="-1"><a class="header-anchor" href="#_2-1-commonjs模块规范" aria-hidden="true">#</a> 2.1 CommonJS模块规范</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">math</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">math</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#8FBCBB;">exports</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">add</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">function</span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span><span style="color:#81A1C1;">...</span><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#8FBCBB;">module</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">export</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">xxx</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-2-node模块的实现" tabindex="-1"><a class="header-anchor" href="#_2-2-node模块的实现" aria-hidden="true">#</a> 2.2 Node模块的实现</h3><p>在Node中引入模块经历3个步骤</p><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><p>模块分为两类，一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p><p>核心模块被直接加载进内存中，文件模块加载速度比核心模块加载速度慢。</p><h4 id="优先从缓存加载" tabindex="-1"><a class="header-anchor" href="#优先从缓存加载" aria-hidden="true">#</a> 优先从缓存加载</h4><p>浏览器仅缓存文件，而Node缓存的是编译和执行之后的对象。</p><p>核心模块的缓存检查先于文件模块的缓存检查。</p><h4 id="路径分析和文件定位" tabindex="-1"><a class="header-anchor" href="#路径分析和文件定位" aria-hidden="true">#</a> 路径分析和文件定位</h4><ol><li><p>模块标识符分析</p><ul><li><p>核心模块，如http、fs、path等。</p><p>核心模块的优先级仅次于缓存加载。</p></li><li><p>.或..开始的相对路径文件模块。</p><p>require()方法会将路径转为真实路径，并以真实路径作为索引。</p></li><li><p>以/开始的绝对路径文件模块。</p></li><li><p>非路径形式的文件模块。</p><p>查找最慢最费时。</p></li></ul></li><li><p>文件定位</p><p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。</p><ul><li><p>文件拓展名分析</p><p>在不包含文件扩展名的情况下，Node会按.js、.json、.node的次序补足拓展名，依次尝试。</p><p>在尝试的过程中，需要调用fs模块同步阻塞地判断文件是否存在。小诀窍是：1.如果是.node和.json文件，在传递给require()的标识符中带上拓展名，会加快一点速度。2.同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。</p></li><li><p>目录分析和包</p><p>如果引入的路径得到一个目录，首先，Node在当前目录下查找package.json，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少拓展名，将会进入拓展名分析的步骤。</p><p>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js，index.json，index.node。</p></li></ul></li></ol><h4 id="模块编译" tabindex="-1"><a class="header-anchor" href="#模块编译" aria-hidden="true">#</a> 模块编译</h4><p>对于不同的文件拓展名，其载入方法也有所不同</p><ul><li><strong>.js文件</strong>。通过fs模块<strong>同步</strong>读取文件后编译执行。</li><li><strong>.node文件</strong>。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。</li><li><strong>.json文件</strong>。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li><li>其余扩展名文件。他们都被当做.js文件载入。</li></ul><p>编译方式</p><ol><li><p>JavaScript模块的编译</p><p>在编译过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname){\n，在尾部添加了\n});</p><p>在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，模块中的其余变量或属性则不可直接被调用。</p></li><li><p>C/C++模块的编译</p><p>Node调用process.dlopen()方法进行加载和执行。</p></li><li><p>JSON文件的编译</p><p>Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p></li></ol><h3 id="_2-3-核心模块" tabindex="-1"><a class="header-anchor" href="#_2-3-核心模块" aria-hidden="true">#</a> 2.3 核心模块</h3><p>核心模块分为C/C++编写和JavaScript编写，C/C++文件存放在src目录下，JavaScript文件存放在lib目录下。</p><h4 id="javascript核心模块的编译过程" tabindex="-1"><a class="header-anchor" href="#javascript核心模块的编译过程" aria-hidden="true">#</a> JavaScript核心模块的编译过程</h4><ol><li><p>转存为C/C++代码</p><p>在启动Node进程时，JavaScript代码直接加载进内存中。</p></li><li><p>编译JavaScript核心模块</p><p>在引入JavaScript核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。</p><p>与文件模块的区别在于获取源代码的方式（核心模块从内存中加载）以及缓存执行结果的位置。</p></li></ol><h4 id="c-c-模块的编译过程" tabindex="-1"><a class="header-anchor" href="#c-c-模块的编译过程" aria-hidden="true">#</a> C/C++模块的编译过程</h4><p>由纯C/C++编写的部分称为内建模块，他们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的。</p><ol><li><p>内建模块的组织形式</p><p>node_extensions.h文件将散列的内建模块统一放进node_module_list数组中。</p><p>内建模块的优势：它们本身由C/C++编写，性能上优于脚本语言，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。</p></li><li><p>内建模块的导出</p><p>文件模块=》核心模块=》内建模块，文件模块依赖核心模块依赖内建模块。</p><p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p></li></ol><h4 id="核心模块的引入流程" tabindex="-1"><a class="header-anchor" href="#核心模块的引入流程" aria-hidden="true">#</a> 核心模块的引入流程</h4><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJVnH.jpg" alt="gjJVnH.jpg"></p><h4 id="编写核心模块" tabindex="-1"><a class="header-anchor" href="#编写核心模块" aria-hidden="true">#</a> 编写核心模块</h4><p>编写内建模块分为两步，编写头文件和编写C/C++文件。</p><h3 id="_2-4-c-c-拓展模块" tabindex="-1"><a class="header-anchor" href="#_2-4-c-c-拓展模块" aria-hidden="true">#</a> 2.4 C/C++拓展模块</h3><p>C/C++拓展模块属于文件模块的一类。</p><p>C/C++模块通过预先编译为.node文件，然后调用process.dlopen()方法加载执行。</p><p>一个平台下的.node文件在另一个平台下是无法加载运行的，必须重新用各自平台的编译器编译为正确的.node文件。</p><h4 id="前提条件" tabindex="-1"><a class="header-anchor" href="#前提条件" aria-hidden="true">#</a> 前提条件</h4><ul><li><p>GYP项目生成工具。</p><p>node-gyp，为Node提供的一个专门的扩展构建工具。</p></li><li><p>V8引擎C++库。</p></li><li><p>libuv库。</p><p>这个库是跨平台的一层封装。libuv封装的功能包括事件循环、文件操作等。</p></li><li><p>Node内部库。</p></li><li><p>其他库。</p></li></ul><h4 id="c-c-扩展模块的编写" tabindex="-1"><a class="header-anchor" href="#c-c-扩展模块的编写" aria-hidden="true">#</a> C/C++扩展模块的编写</h4><p>普通的扩展模块与内建模块的区别在于无须将源代码编译进Node，而是通过dlopen()方法动态加载。</p><h4 id="c-c-扩展模块的编译" tabindex="-1"><a class="header-anchor" href="#c-c-扩展模块的编译" aria-hidden="true">#</a> C/C++扩展模块的编译</h4><p>通过输入node-gyp build进行编译。</p><h4 id="c-c-扩展模块的加载" tabindex="-1"><a class="header-anchor" href="#c-c-扩展模块的加载" aria-hidden="true">#</a> C/C++扩展模块的加载</h4><p>require(&#39;./xx.node&#39;)执行，.node扩展名的文件会调用process.dlopen()方法去加载文件。</p><p>加载.node文件实际上经历了两个步骤，第一个步骤是调用uv_dlopen()文件去打开动态链接库，第二个步骤是调用uv_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法低值。</p><p>C/C++扩展模块与JavaScript模块的区别在于加载之后不需要编译。</p><h3 id="_2-5-模块调用栈" tabindex="-1"><a class="header-anchor" href="#_2-5-模块调用栈" aria-hidden="true">#</a> 2.5 模块调用栈</h3><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2Ckxun.jpg" alt="2Ckxun.jpg"></p><p>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。</p><p>如果不是非常了解C/C++内建模块，尽量避免通过process.binding()调用。</p><p>JavaScript核心模块作为C/C++内建模块的封装层和桥接层，供文件模块调用，也是纯粹的功能模块，它不需要跟底层打交道，但又十分重要。</p><h3 id="_2-6-包与npm" tabindex="-1"><a class="header-anchor" href="#_2-6-包与npm" aria-hidden="true">#</a> 2.6 包与NPM</h3><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJeHA.jpg" alt="gjJeHA.jpg"></p><p>CommonJS的包规范的定义其实也十分简单，它由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p><h4 id="包结构" tabindex="-1"><a class="header-anchor" href="#包结构" aria-hidden="true">#</a> 包结构</h4><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tag.gz格式的文件。</p><p>完全符合CommonJS规范的包目录包含如下文件：</p><ul><li>package.json：包描述文件。</li><li>bin：用于存放可执行二进制文件的目录。</li><li>lib：用于存放JavaScript代码的目录。</li><li>doc：用于存放文档的目录。</li><li>test：用于存放单元测试用例的代码。</li></ul><h4 id="包描述文件与npm" tabindex="-1"><a class="header-anchor" href="#包描述文件与npm" aria-hidden="true">#</a> 包描述文件与NPM</h4><p>CommonJS为<strong>package.json</strong>文件定义了如下一些必需的字段。</p><ul><li>name。包名。</li><li>description。包简介。</li><li>version。版本号。通常为major.minor.revision格式。</li><li>keywords。关键词数组，NPM中主要用来做分类搜索。</li><li>maintainers。包维护者列表。</li><li>contributors。贡献值列表。</li><li>bugs。一个可以反馈bug的网页地址或邮件地址。</li><li>licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。</li><li>repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源码。</li><li>dependencies。使用当前包所需要依赖的包列表。</li></ul><p>可选字段：</p><ul><li>homepage。当前包的网站地址。</li><li>os。操作系统支持列表。</li><li>cpu。CPU架构的支持列表。</li><li>engines。支持的JavaScript引擎列表。</li><li>builtin。标志当前包是否是内建在底层系统的标准组件。</li><li>directories。包目录说明。</li><li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范</li><li>scripts。脚本说明对象。</li></ul><p>在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies。</p><ul><li>author。包作者。</li><li>bin。一些包作者希望包可以作为命令行工具使用。</li><li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。</li><li>devDependencies。一些模块只在开发时需要依赖。</li></ul><h4 id="npm常用功能" tabindex="-1"><a class="header-anchor" href="#npm常用功能" aria-hidden="true">#</a> NPM常用功能</h4><ol><li><p>查看帮助</p><p>npm help &lt;common&gt;</p></li><li><p>安装依赖包</p><p>执行npm install xxx，NPM会在当前目录下创建node_modules目录，然后在该目录下创建xxx目录，接着将包解压到这个目录下。</p><ul><li><p>全局模式安装</p><p>npm install -g xxx会将包安装的node目录/lib/node_modules目录下。</p></li><li><p>从本地安装</p><p>本地安装只需为NPM指明package.json文件所在的位置即可，它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个目录下有package.json文件的目录位置。</p></li><li><p>从非官方源安装</p></li></ul></li><li><p>NPM钩子命令</p><p>scripts字段让包在安装或者卸载等过程中提供钩子机制。</p></li><li><p>发布包</p><ul><li><p>编写模块</p></li><li><p>初始化包描述文件</p></li><li><p>注册包仓库账号</p><p>npm adduser</p></li><li><p>上传包</p><p>npm publish &lt;folder&gt;</p></li><li><p>安装包</p></li><li><p>管理包权限</p><p>npm ower 管理包的所有者</p></li><li><p>分析包</p><p>npm ls分析包</p></li></ul></li></ol><h4 id="局部npm" tabindex="-1"><a class="header-anchor" href="#局部npm" aria-hidden="true">#</a> 局部NPM</h4><p>搭建自己的NPM仓库，参考附录D</p><h4 id="npm潜在问题" tabindex="-1"><a class="header-anchor" href="#npm潜在问题" aria-hidden="true">#</a> NPM潜在问题</h4><p>包质量良莠不齐。安全问题。</p><p>符合Kwalitee的模块要满足的条件：</p><ul><li>具备良好的测试。</li><li>具备良好的文档（README、API）</li><li>具备良好的测试覆盖率。</li><li>具备良好的编码规范。</li><li>更多条件。</li></ul><h3 id="_2-7-前后端共用模块" tabindex="-1"><a class="header-anchor" href="#_2-7-前后端共用模块" aria-hidden="true">#</a> 2.7 前后端共用模块</h3><p>前后端的环境略有差别。</p><h4 id="模块的侧重点" tabindex="-1"><a class="header-anchor" href="#模块的侧重点" aria-hidden="true">#</a> 模块的侧重点</h4><p>浏览器端JavaScript：需要经历从同一个服务器端分发到多个客户端执行。瓶颈在于带宽。需要通过网络加载代码。</p><p>服务器端JavaScript：相同的代码需要多次执行。瓶颈在于CPU和内存等资源。从磁盘中加载，两者的加载速度不在一个数量级上。</p><h4 id="amd规范" tabindex="-1"><a class="header-anchor" href="#amd规范" aria-hidden="true">#</a> AMD规范</h4><p>AMD规范是CommonJS模块规范的一个延伸。它是异步加载模块。</p><h4 id="cmd规范" tabindex="-1"><a class="header-anchor" href="#cmd规范" aria-hidden="true">#</a> CMD规范</h4><p>由国内的玉伯提出。与AMD规范的区别在于定义模块和依赖引入的部分。</p><h4 id="兼容多种模块规范" tabindex="-1"><a class="header-anchor" href="#兼容多种模块规范" aria-hidden="true">#</a> 兼容多种模块规范</h4><p>类库开发者需要将类库代码包装在一个闭包内。</p><h2 id="第3章-异步i-o" tabindex="-1"><a class="header-anchor" href="#第3章-异步i-o" aria-hidden="true">#</a> 第3章 异步I/O</h2><p>Node是首个将异步作为主要编程方式和设计理念。</p><p>Node既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。</p><h3 id="_3-1-为什么要异步i-o" tabindex="-1"><a class="header-anchor" href="#_3-1-为什么要异步i-o" aria-hidden="true">#</a> 3.1 为什么要异步I/O</h3><h4 id="用户体验" tabindex="-1"><a class="header-anchor" href="#用户体验" aria-hidden="true">#</a> 用户体验</h4><p>采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。</p><p>只有后端能够快速响应资源，才能让前端的体验变好。</p><h4 id="资源分配" tabindex="-1"><a class="header-anchor" href="#资源分配" aria-hidden="true">#</a> 资源分配</h4><p>多线程编程经常面临锁、状态同步等问题，但是多线程在多核CPU上能够有效提升CPU的利用率。</p><p>单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。</p><p>Node的优点是利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程上将资源分配得更高效。</p><p>Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。</p><h3 id="_3-2-异步i-o实现现状" tabindex="-1"><a class="header-anchor" href="#_3-2-异步i-o实现现状" aria-hidden="true">#</a> 3.2 异步I/O实现现状</h3><h4 id="异步i-o与非阻塞i-o" tabindex="-1"><a class="header-anchor" href="#异步i-o与非阻塞i-o" aria-hidden="true">#</a> 异步I/O与非阻塞I/O</h4><p>操作系统内核对于I/O只有两种方式：阻塞与非阻塞。</p><p>阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。</p><p>非阻塞I/O跟阻塞I/O地差别为调用之后会立即返回。</p><p>重复调用判断操作是否完成的技术叫做轮询。</p><p>现存的轮询技术有以下：</p><ul><li>read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。</li><li>select。通过对文件描述符上的事件状态来进行判断，最多可以同时检查1024个文件描述符。</li><li>poll。采用链表的方式避免数组长度的限制，能避免不需要的检查，但当文件描述符较多的时候，它的性能还是十分低下的。</li><li>epoll。在Linux下效率最高的I/O事件通知机制，利用事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率高。</li><li>kqueue。实现方式与epoll类似，不过它仅在FreeBSD系统下存在。</li></ul><p>轮询技术满足了非阻塞I/O确保获取完整数据的需求。</p><h4 id="理想的非阻塞异步i-o" tabindex="-1"><a class="header-anchor" href="#理想的非阻塞异步i-o" aria-hidden="true">#</a> 理想的非阻塞异步I/O</h4><p>完美的异步I/O是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，直接处理下一个任务，等I/O完成后通过信号或回调将数据传递给应用程序即可。</p><h4 id="现实的异步i-o" tabindex="-1"><a class="header-anchor" href="#现实的异步i-o" aria-hidden="true">#</a> 现实的异步I/O</h4><p>单线程仅仅只是JavaScript执行的单线程中罢了，在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJK4P.jpg" alt="gjJK4P.jpg"></p><h3 id="_3-3-node的异步i-o" tabindex="-1"><a class="header-anchor" href="#_3-3-node的异步i-o" aria-hidden="true">#</a> 3.3 Node的异步I/O</h3><p>完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p><h4 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h4><p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为<strong>Tick</strong>。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们，然后进入下个循环，如果不再有事件处理，就退出进程。</p><h4 id="观察者" tabindex="-1"><a class="header-anchor" href="#观察者" aria-hidden="true">#</a> 观察者</h4><p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p><p>在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。</p><h4 id="请求对象" tabindex="-1"><a class="header-anchor" href="#请求对象" aria-hidden="true">#</a> 请求对象</h4><p>从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。</p><p>从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用。</p><h4 id="执行回调" tabindex="-1"><a class="header-anchor" href="#执行回调" aria-hidden="true">#</a> 执行回调</h4><p>组装好请求对象、送入I/O线程池等待执行，完成了异步I/O的第一部分，回调通知是第二部分。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJQ9f.jpg" alt="gjJQ9f.jpg"></p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。</p><p>除了用户代码无法并行执行外，所有的I/O则是可以并行起来的。</p><h3 id="_3-4-非i-o的异步api" tabindex="-1"><a class="header-anchor" href="#_3-4-非i-o的异步api" aria-hidden="true">#</a> 3.4 非I/O的异步API</h3><p>setTimeout()、setInterval()、setImmediate()和process.nextTick()。</p><h4 id="定时器" tabindex="-1"><a class="header-anchor" href="#定时器" aria-hidden="true">#</a> 定时器</h4><p>setTimeout()和setInterval()的实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。</p><p>创建的定时器会被插入到定时器观察者内部的一个红黑树中。</p><h4 id="process-nexttick" tabindex="-1"><a class="header-anchor" href="#process-nexttick" aria-hidden="true">#</a> process.nextTick()</h4><p>立即异步执行一个任务，setTimeout(fn,0)的方式较为浪费性能。</p><p>定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的事件复杂度为O(1)。</p><h4 id="setimmediate" tabindex="-1"><a class="header-anchor" href="#setimmediate" aria-hidden="true">#</a> setImmediate()</h4><p>setImmediate()方法和proce.nextTick()十分类似，process.nextTIck()中的回调函数执行优先级高于setImmediate()。</p><p>原因是proces.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一轮轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。</p><p>process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。</p><p>process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，setImmediate()的每轮循环中执行链表中的一个回调函数。</p><h3 id="_3-5-事件驱动与高性能服务器" tabindex="-1"><a class="header-anchor" href="#_3-5-事件驱动与高性能服务器" aria-hidden="true">#</a> 3.5 事件驱动与高性能服务器</h3><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJl38.jpg" alt="gjJl38.jpg"></p><p>集中经典的服务器模型：</p><ul><li>同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。</li><li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。</li><li>每线程/每请求。为每个请求启动一个线程来处理。当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li></ul><p>Node采用事件驱动的方式处理请求，无须为每个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。即使在大量连接的情况下，也不受线程上下文切换开销的影响 ，这是Node高性能的一个原因。</p><h2 id="第4章-异步编程" tabindex="-1"><a class="header-anchor" href="#第4章-异步编程" aria-hidden="true">#</a> 第4章 异步编程</h2><h3 id="_4-1-函数式编程" tabindex="-1"><a class="header-anchor" href="#_4-1-函数式编程" aria-hidden="true">#</a> 4.1 函数式编程</h3><h4 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数" aria-hidden="true">#</a> 高阶函数</h4><p>高阶函数可以把函数当做参数，或是将函数作为返回值的函数。</p><h4 id="偏函数用法" tabindex="-1"><a class="header-anchor" href="#偏函数用法" aria-hidden="true">#</a> 偏函数用法</h4><p>偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">toString</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#8FBCBB;">Object</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9FF;">prototype</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">toString</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">isType</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">function</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">type</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">function</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">obj</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">toString</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">call</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">obj</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">===</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">[object </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">type</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">]</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">isString</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">isType</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">String</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">isFunction</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">isType</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Function</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-2-异步编程的优势与难点" tabindex="-1"><a class="header-anchor" href="#_4-2-异步编程的优势与难点" aria-hidden="true">#</a> 4.2 异步编程的优势与难点</h3><h4 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h4><p>Node特性是基于事件驱动的非阻塞I/O模型，是灵魂所在。</p><p>建议对CPU的耗用不要超过10ms，或者将大量的计算分解为诸多的小量计算，通过setImmediate()进行调度。</p><h4 id="难点" tabindex="-1"><a class="header-anchor" href="#难点" aria-hidden="true">#</a> 难点</h4><ol><li><p>难点1：异常处理</p><p>自行编写的异步方法需要遵循这些原则：<strong>必须执行调用者传入的回调函数；正确传递回异常供调用者判断。</strong></p></li><li><p>难点2：函数嵌套过深</p></li><li><p>难点3：阻塞代码</p><p>没有像sleep()这样的线程沉睡功能。</p><p>调用setTimeout()效果会更好</p></li><li><p>难点4：多线程编程</p><p>JavaScript中，Web Workers能解决利用CPU和减少阻塞UI渲染，但是不能解决UI渲染的效率问题。</p><p>Node借鉴了这个模式，child_process是基础API，cluster模块是更深层次的应用。</p></li><li><p>难点5：异步转同步</p></li></ol><h3 id="_4-3-异步编程解决方案" tabindex="-1"><a class="header-anchor" href="#_4-3-异步编程解决方案" aria-hidden="true">#</a> 4.3 异步编程解决方案</h3><ul><li>事件发布/订阅模式。</li><li>Promise/Deferred模式。</li><li>流程控制库。</li></ul><h4 id="事件发布-订阅模式" tabindex="-1"><a class="header-anchor" href="#事件发布-订阅模式" aria-hidden="true">#</a> 事件发布/订阅模式</h4><p>Node自身提供的events模块是发布/订阅模式的一个简单实现。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9;">emitter</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">e1</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#81A1C1;">function</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">mes</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">mes</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9;">emitter</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">emit</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">e1</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">nihao</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>事件侦听器模式也是一种钩子（hook）机制，利用钩子导出内部数据或状态给外部的调用者。</p><p>Node对事件发布/订阅的机制做了一些额外的处理</p><ul><li>如果对一个事件添加超过10个侦听器，就会得到一条警告，侦听器太多可能导致内存泄漏；调用emiiter.setMaxListeners(0)，可以将限制去掉；如果事件的侦听器过多，可能存在过多占用CPU的情景。</li><li>为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器，如果添加则将这个错误交给侦听器处理，否则会作为异常抛出；如果外部没捕获异常会引起线程退出。</li></ul><ol><li><p>继承events模块</p></li><li><p>利用事件队列解决雪崩问题</p><p>once()方法，侦听器只能执行一次。</p><p>雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景。</p></li><li><p>多异步之间的协作方案</p><p>一般而言，事件与侦听器的关系是一对多。</p></li><li><p>EventProxy的原理</p></li><li><p>EventProxy的异常处理</p></li></ol><h4 id="promise-deferred模式" tabindex="-1"><a class="header-anchor" href="#promise-deferred模式" aria-hidden="true">#</a> Promise/Deferred模式</h4><ol><li><p>Promises/A</p><ul><li>3种状态，未完成态、完成态和失败态。</li><li>从未完成态向完成态或失败态转化，不能逆反。</li><li>一旦转化，不能被更改。</li></ul></li><li><p>Promise中的多异步协作</p></li><li><p>Promise的进阶知识</p><ul><li><p>支持序列执行的Promise</p><p>要Promise支持链式执行，需要以下两个步骤</p><p>（1）将所有的回调都存到队列中。</p><p>（2）Promise完成时，逐个执行回调，一旦检查到返回了新的Promise对象，停止执行，然后将当前Deferred对象的promise引用改变为新的Pormise对象，并将队列中余下的回调转交给它。</p></li><li><p>将API Promise化</p></li></ul></li></ol><h4 id="流程控制库" tabindex="-1"><a class="header-anchor" href="#流程控制库" aria-hidden="true">#</a> 流程控制库</h4><ol><li><p>尾触发与Next,Connect库</p><p>需要手工调用才能持续执行后续调用。</p></li><li><p>async库</p><ul><li>异步的串行执行</li><li>异步的并行执行</li><li>异步调用的依赖处理</li><li>自动依赖处理</li></ul></li><li><p>Step库</p></li><li><p>wind库</p></li></ol><h3 id="_4-4-异步并发控制" tabindex="-1"><a class="header-anchor" href="#_4-4-异步并发控制" aria-hidden="true">#</a> 4.4 异步并发控制</h3><p>通过队列来控制并发量</p><h2 id="第5章-内存控制" tabindex="-1"><a class="header-anchor" href="#第5章-内存控制" aria-hidden="true">#</a> 第5章 内存控制</h2><p>基于无阻塞、事件驱动建立的Node服务，具有内存消耗低的优点，非常适合处理海量的网络请求。</p><h3 id="_5-1-v8的垃圾回收机制与内存限制" tabindex="-1"><a class="header-anchor" href="#_5-1-v8的垃圾回收机制与内存限制" aria-hidden="true">#</a> 5.1 V8的垃圾回收机制与内存限制</h3><h4 id="node与v8" tabindex="-1"><a class="header-anchor" href="#node与v8" aria-hidden="true">#</a> Node与V8</h4><p>Node在JavaScript的执行上直接受益于V8,可以随着V8的升级就能享受到更好地性能或新的语言特性（如ES5和ES6）等。</p><h4 id="v8的内存控制" tabindex="-1"><a class="header-anchor" href="#v8的内存控制" aria-hidden="true">#</a> V8的内存控制</h4><p>Node中通过JavaScript使用内存时只能使用部分内存，这会导致Node无法直接操作大内存对象，计算机内存资源无法得到充足的使用。</p><h4 id="v8的对象分配" tabindex="-1"><a class="header-anchor" href="#v8的对象分配" aria-hidden="true">#</a> V8的对象分配</h4><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。</p><p><code>process.memoryUsage()</code>查看内存使用信息。</p><p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。</p><p>考虑到垃圾回收机制所需要的时间会短暂造成JavaScript线程暂停执行，直接限制堆内存是一个好的选择。</p><p>这个限制也可以打开，在Node启动时传递<code>--max-old-space-size</code>（设置老生代内存空间的大小）或<code>--max-new-space-size</code>（设置新生代内存空间的大小）来调整内存限制的大小，如<code>node --max-old-space-size=1700 test.js // 单位为MB</code></p><h4 id="v8的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8的垃圾回收机制" aria-hidden="true">#</a> V8的垃圾回收机制</h4><p>V8用到的各种垃圾回收算法</p><ul><li><p>V8的内存分代</p><p>V8的垃圾回收策略主要基于<strong>分代式垃圾回收机制</strong>。</p><p>现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。</p><p>将内存分为新生代和老生代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p><p>当内存分配过程超过极限值就会导致进程出错。默认内存配置是64位1.4GB和32位0.7GB。</p></li><li><p>Scavenge算法</p><p>新生代中的对象主要通过Scavenge算法进行垃圾回收，Scavenge算法实现主要采用了Cheney算法。</p><p>Cheney算法是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，每一部分空间称为semispace，在这两个semispace空间中，一个处于使用状态（From空间），一个处于闲置状态（To空间），分配对象是在From空间进行分配。</p><p>当开始进行垃圾回收时，会检查From空间中的存活对象，将存活对象复制到To空间，而非存活对象占用的空间将会被释放，垃圾回收的过程就是通过将存活对象在两个semispace空间之间进行复制。</p><p>Scavenge的缺点是只能使用堆内存中的一半，这是因为划分空间和复制机制所决定的，采用了牺牲空间换取时间的算法。</p><p>Scavenge非常适合应用在新生代中，因为新生代中对象的声明周期较短。</p><p>实际使用的堆内存是新生代中的两个semispace空间大小和老生代所用内存大小之和。</p><p>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象，这种较长生命周期的对象随后被移动到老生代中，采用新的算法进行管理，这种过程称为<strong>晋升</strong>。</p><p>在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。</p><p>对象晋升的条件一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制（To空间占用比超过25%）。</p><p>在默认情况下，V8的对象分配主要集中在From空间中。对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。</p></li><li><p>Mark-Sweep &amp; Mark-compact</p><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。</p><p>Mark-Sweep最大的问题是进行一次标记清除回收后，内存空间会出现不连续的状态，这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><p>Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。他们的差别在于对象在标记为死亡后，在整理的过程中，将或者的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p><p>V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</p></li><li><p>Incremental Marking</p><p>垃圾回收的3中基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”。</p><p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一“步进”，就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行知道标记阶段完成。</p><p>想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。</p></li></ul><h4 id="查看垃圾回收日志" tabindex="-1"><a class="header-anchor" href="#查看垃圾回收日志" aria-hidden="true">#</a> 查看垃圾回收日志</h4><p>在启动时添加<code>--trace_gc</code>参数可以查看垃圾回收日志。</p><p>在启动时添加<code>--prof</code>参数可以得到V8执行时的性能分析数据。</p><h3 id="_5-2-高效使用内存" tabindex="-1"><a class="header-anchor" href="#_5-2-高效使用内存" aria-hidden="true">#</a> 5.2 高效使用内存</h3><h4 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h4><p>作用域会触发垃圾回收。函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁，作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁，只被局部变量引用的对象存活周期较短。</p><p>标识符查找。通过作用域链进行查找。如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（老生代中），可以通过delete或者将变量重新复制来释放常驻内存的对象。</p><h4 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h4><p>实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）。</p><p>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不再有引用，才会逐步释放。</p><h4 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h4><p>在正常的JavaScript执行中，无法立即回收的内存有闭包和全局变量引用，由于V8的内存限制，要十分小心此类变量是否无限制的增加，因为它会导致老生代中的对象增多。</p><h3 id="_5-3-内存指标" tabindex="-1"><a class="header-anchor" href="#_5-3-内存指标" aria-hidden="true">#</a> 5.3 内存指标</h3><h4 id="查看内存使用情况" tabindex="-1"><a class="header-anchor" href="#查看内存使用情况" aria-hidden="true">#</a> 查看内存使用情况</h4><p>os模块中的totalmem()和freemem()方法可以查看内存的使用情况。</p><ol><li><p>查看进程的内存占用</p><p>Process.meoryUsage()可以查看Node进程的内存占用情况。</p><p>rss表示进程的常驻内存部分，heapUsed表示目前堆中使用中的内存量，heapTotal表示堆中总共申请的内存量。</p></li><li><p>查看系统的内存占用</p><p>os模块的totalmem()返回系统的总内存，freemem()返回闲置内存。</p></li></ol><h4 id="堆外内存" tabindex="-1"><a class="header-anchor" href="#堆外内存" aria-hidden="true">#</a> 堆外内存</h4><p>不是通过V8分配得内存称为堆外内存。</p><p>Buffer对象不同于其他对象，它不经过V8的内存分配机制，不会有堆内存的大小限制。</p><h3 id="_5-4-内存泄漏" tabindex="-1"><a class="header-anchor" href="#_5-4-内存泄漏" aria-hidden="true">#</a> 5.4 内存泄漏</h3><p>造成内存泄漏的原因有：缓存。队列消费不及时。作用域未释放。</p><h4 id="慎将内存当做缓存" tabindex="-1"><a class="header-anchor" href="#慎将内存当做缓存" aria-hidden="true">#</a> 慎将内存当做缓存</h4><p>缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。</p><p>严格意义的缓存有着完善的过期策略，而普通对象的键值对没有。</p><p>在node中，任何试图拿内存当缓存的行为要小心为之。</p><ol><li><p>缓存限制策略</p><p>可以通过限制数量来限制缓存的无限增长。</p><p>由于模块的缓存机制，模块是常驻老生代的，在设计模块时，要十分小心内存泄漏，可以添加清空队列的接口供调用者释放内存。</p></li><li><p>缓存的解决方案</p><p>目前较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能，它可以解决Node中的两个问题（1）将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。（2）进程之间可以共享缓存。</p><p>目前市面上较好的缓存有Redis和Memcached。</p></li></ol><h4 id="关注队列状态" tabindex="-1"><a class="header-anchor" href="#关注队列状态" aria-hidden="true">#</a> 关注队列状态</h4><p>解决方案是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。</p><p>另一个方案是任意异步调用都应该包含超时机制，如果在限定时间内未完成响应，通过回调函数传递超时异常。</p><h3 id="_5-5-内存泄漏排查" tabindex="-1"><a class="header-anchor" href="#_5-5-内存泄漏排查" aria-hidden="true">#</a> 5.5 内存泄漏排查</h3><p>定位Node应用的内存泄漏工具：</p><ul><li>v8-profiler。</li><li><strong>node-heapdump。</strong></li><li>node-mtrace。</li><li>dtrace。</li><li><strong>node-memwatch。</strong></li></ul><h3 id="_5-6-大内存应用" tabindex="-1"><a class="header-anchor" href="#_5-6-大内存应用" aria-hidden="true">#</a> 5.6 大内存应用</h3><p>Node提供的stream模块解决操作大文件的读写问题。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">reader</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createReadStream</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">in.txt</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">writer</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createWriteStream</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">out.txt</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="第6章-理解buffer" tabindex="-1"><a class="header-anchor" href="#第6章-理解buffer" aria-hidden="true">#</a> 第6章 理解Buffer</h2><p>Buffer对象用于处理二进制数据。</p><h3 id="_6-1-buffer结构" tabindex="-1"><a class="header-anchor" href="#_6-1-buffer结构" aria-hidden="true">#</a> 6.1 Buffer结构</h3><h4 id="模块结构" tabindex="-1"><a class="header-anchor" href="#模块结构" aria-hidden="true">#</a> 模块结构</h4><p>Buffer的性能相关部分用C++实现，非性能部分用JavaScript实现。</p><p>Buffer所占用的内存不是通过V8分配得，属于堆外内存。</p><h4 id="buffer对象" tabindex="-1"><a class="header-anchor" href="#buffer对象" aria-hidden="true">#</a> Buffer对象</h4><p>Buffer对象类似于数组，它的元素为16进制的两位数。</p><p>可以通过length属性得到长度，通过下标访问元素。</p><h4 id="buffer内存分配" tabindex="-1"><a class="header-anchor" href="#buffer内存分配" aria-hidden="true">#</a> Buffer内存分配</h4><p>Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略。</p><p>Node中采用了slab分配机制，slab是一种动态内存管理机制。</p><p>slab有如下3中状态</p><ul><li>full：完全分配状态。</li><li>partial：部分分配状态。</li><li>empty：没有被分配状态。</li></ul><p>Node以8KB为界限来区分Buffer是大对象还是小对象。这个8KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p><p><strong>1.分配小Buffer对象</strong></p><p>Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它。</p><p><code>new Buffer(1024);</code>构造将会去检查pool对象，如果pool没有则会创建一个新的slab单元指向它，同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置（offset）开始使用的，slab对象自身也记录被使用了多少字节。</p><p>当再创建一个Buffer对象时，如果这个slab的剩余空间足够则使用这个slab的剩余空间并更新分配状态，如果不够则创建一个新的slab并使用，第一个slab剩余的空间将造成浪费。</p><p>由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8KB空间才会被回收。</p><p><strong>2.分配大Buffer对象</strong></p><p>超过8KB的Buffer对象将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。</p><p>上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收，但是其内部的parent属性指向的SlowBuffer对象却来自于Node自身C++中的定义，是C++层面上的Buffer独享，所用内存不在V8的堆中。</p><h3 id="_6-2-buffer的转换" tabindex="-1"><a class="header-anchor" href="#_6-2-buffer的转换" aria-hidden="true">#</a> 6.2 Buffer的转换</h3><p>Buffer对象可以与字符串之间互相转换，目前支持的字符串编码类型有：</p><ul><li>ASCII</li><li>UTF-8</li><li>UTF-16LE/UCS-2</li><li>Base64</li><li>Binary</li><li>Hex</li></ul><h4 id="字符串转buffer" tabindex="-1"><a class="header-anchor" href="#字符串转buffer" aria-hidden="true">#</a> 字符串转Buffer</h4><p><code>new Buffer(str, [encoding]);</code></p><p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p><p>Buffer对象中可以存在多种编码转化后的内容。不过每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理。</p><h4 id="buffer转字符串" tabindex="-1"><a class="header-anchor" href="#buffer转字符串" aria-hidden="true">#</a> Buffer转字符串</h4><p>Buffer对象调用toString()方法可以转为字符串。</p><p><code>buf.toString([encoding],[start],[end]);</code></p><h4 id="buffer不支持的编码类型" tabindex="-1"><a class="header-anchor" href="#buffer不支持的编码类型" aria-hidden="true">#</a> Buffer不支持的编码类型</h4><p><code>isEncoding()</code>函数判断编码是否支持转换。</p><p>iconv和iconv-lite两个模块支持更多的编码类型转换。</p><h3 id="_6-3-buffer的拼接" tabindex="-1"><a class="header-anchor" href="#_6-3-buffer的拼接" aria-hidden="true">#</a> 6.3 Buffer的拼接</h3><h4 id="乱码是如何产生的" tabindex="-1"><a class="header-anchor" href="#乱码是如何产生的" aria-hidden="true">#</a> 乱码是如何产生的</h4><p>对于任意长度的Buffer而言，宽字节字符串都有可能存在被截断的情况，只不过Buffer的长度越大出现的概率越低而已。</p><h4 id="setencoding-与string-decoder" tabindex="-1"><a class="header-anchor" href="#setencoding-与string-decoder" aria-hidden="true">#</a> setEncoding()与string_decoder()</h4><p>setEncoding()设置编码格式</p><p>string_decoder()可以自动进行整数倍字节进行转码，目前可以处理UTF-8、Base64和UCS-2/UTF-16LE。</p><h4 id="正确的拼接buffer" tabindex="-1"><a class="header-anchor" href="#正确的拼接buffer" aria-hidden="true">#</a> 正确的拼接Buffer</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">chunks</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> []</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">size</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">chunk</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">chunks</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">push</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">chunk</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">size</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">+=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">chunk</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9FF;">length</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">end</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">buf</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">Buffer</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">concat</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">chunks</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">size</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">str</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">iconv</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">decode</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">buf</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">utf8</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">str</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="buffer与性能" tabindex="-1"><a class="header-anchor" href="#buffer与性能" aria-hidden="true">#</a> Buffer与性能</h4><p>提高字符串转Buffer的转换效率，可以很大程度提高网络吞吐率。</p><p>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。</p><p>在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。文件自身是二进制数据，在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。</p><p><code>fs.createReadStream()</code>的工作方式是在内存中准备一段Buffer，然后在<code>fs.read()</code>读取时逐步从磁盘中将字节复制到Buffer中。</p><p>highWaterMark的大小对性能有两个影响的点：</p><ul><li>highWaterMark设置对Buffer内存的分配和使用有一定影响。</li><li>highWaterMark设置过小，可能导致系统调用次数过多。</li></ul><p>highWaterMark的大小决定会触发系统调用和data事件的次数。</p><h2 id="第7章-网络编程" tabindex="-1"><a class="header-anchor" href="#第7章-网络编程" aria-hidden="true">#</a> 第7章 网络编程</h2><p>Node中只需要几行代码即可构建服务器，无需额外的容器。</p><p>Node提供net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。</p><h3 id="_7-1-构建tcp服务" tabindex="-1"><a class="header-anchor" href="#_7-1-构建tcp服务" aria-hidden="true">#</a> 7.1 构建TCP服务</h3><h4 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h4><p>TCP全名为传输控制协议，在OSI模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。</p><h4 id="创建tcp服务器端" tabindex="-1"><a class="header-anchor" href="#创建tcp服务器端" aria-hidden="true">#</a> 创建TCP服务器端</h4><p>net模块<code>net.createServer()</code></p><h4 id="tcp服务的事件" tabindex="-1"><a class="header-anchor" href="#tcp服务的事件" aria-hidden="true">#</a> TCP服务的事件</h4><p><strong>1.服务器事件</strong></p><p><code>net.createServer()</code>是一个EventEmitter实例，它的自定义事件有如下几种：</p><ul><li>listening：在调用server.listen()或者Domain Socket触发。</li><li>connection：每个客户端套接字连接到服务器端时触发。</li><li>close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li><li>error：当服务器发生异常时，会触发该事件。</li></ul><p><strong>2.连接事件</strong></p><p>服务器可以同时与多个客户端保持连接，每个连接是可读可写Stream对象。Stream对象用于服务器端和客户端之间的通信。</p><ul><li>data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。</li><li>end：当连接中的任意一段发送了FIN数据时，将会触发该事件。</li><li>connect：该事件用于客户端，当套接字与服务器连接成功时会被触发。</li><li>drain：当任意一端调用write()发送数据时，当前这端会触发该事件。</li><li>error：当异常发生时，触发该事件。</li><li>close：当套接字完全关闭时，触发该事件。</li><li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前连接已经被闲置了。</li></ul><p>Node中TCP默认采用了Nagle算法来对小数据包进行一定的优化，Nagle算法要求缓冲区的数据达到一定数量或者一定时间后才将其发出。</p><p>调用<code>socket.setNoDelay(true)</code>去掉Nagle算法。</p><h3 id="_7-2-构建udp服务" tabindex="-1"><a class="header-anchor" href="#_7-2-构建udp服务" aria-hidden="true">#</a> 7.2 构建UDP服务</h3><p>在UDP中，一个套接字可以与多个UDP服务通信。</p><h4 id="创建udp套接字" tabindex="-1"><a class="header-anchor" href="#创建udp套接字" aria-hidden="true">#</a> 创建UDP套接字</h4><p>UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">dgram</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">dgram</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">socket</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">dgram</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createSocket</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">udp4</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="创建udp服务器端" tabindex="-1"><a class="header-anchor" href="#创建udp服务器端" aria-hidden="true">#</a> 创建UDP服务器端</h4><p>调用<code>dgram.bind(port, [address])</code>方法对网卡和端口进行绑定即可。</p><h4 id="创建udp客户端" tabindex="-1"><a class="header-anchor" href="#创建udp客户端" aria-hidden="true">#</a> 创建UDP客户端</h4><p>调用<code>socket.send(buf,offset,length,port,address,[callback])</code>发送数据。</p><p>参数分别是要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口，目标地址、发送完成后的回调。</p><h4 id="udp套接字事件" tabindex="-1"><a class="header-anchor" href="#udp套接字事件" aria-hidden="true">#</a> UDP套接字事件</h4><p>UDP套接字是一个EventEmitter的事例。</p><ul><li>message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。</li><li>listening：当UDP套接字开始侦听时触发该事件。</li><li>close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。</li><li>error：当异常发生时触发该事件，如果不侦听，直接抛出异常，使进程退出。</li></ul><h3 id="_7-3-构建http服务" tabindex="-1"><a class="header-anchor" href="#_7-3-构建http服务" aria-hidden="true">#</a> 7.3 构建HTTP服务</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">http</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">http</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">http</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createServer</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">200</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Content-Type</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">text/plain</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Hello World</span><span style="color:#EBCB8B;">\n</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">listen</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">1337</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">127.0.0.1</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h4><p>HTTP构建在TCP之上，属于应用层协议。<strong>B/S模式</strong>。</p><p>浏览器，其实是一个HTTP的代理。</p><h4 id="http模块" tabindex="-1"><a class="header-anchor" href="#http模块" aria-hidden="true">#</a> http模块</h4><p>在Node中，HTTP服务继承自TCP服务器（net模块）。</p><p>在开启keep-alive后，一个TCP会话可以用于多次请求和响应。</p><p>TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。</p><p>在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。</p><ol><li><p>HTTP请求</p><p>请求头放在在req.headers属性上。</p><p>报文体需要数据流结束后才能进行操作。</p></li><li><p>HTTP响应</p><p>res.setHeader()和res.writeHead()响应报文头部信息。</p><p>可以调用setHeader进行多次设置，当调用writeHead，报文头才会写入到连接中。</p><p>res.write()和res.end()实现报文体部分，res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。</p><p>报头是在报文体前发送，一旦开始了数据的发送，writeHead()和setHeader()将不再生效。</p><p>务必在结束时调用res.end()结束请求，否则客户端将一直处于等待的状态。</p></li><li><p>HTTP服务的事件</p><ul><li>connection事件：在开始HTTP请求和响应前，客户端与服务器需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发了一次connection事件。</li><li>request事件。建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。</li><li>close事件。与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册事件。</li><li>checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect:100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 continue后重新发送请求时，才会触发request事件。</li><li>connect事件：当客户端发起connect请求时触发，而发起connect请求重新在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭。</li><li>upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。</li><li>clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。</li></ul></li></ol><h4 id="http客户端" tabindex="-1"><a class="header-anchor" href="#http客户端" aria-hidden="true">#</a> HTTP客户端</h4><p>HTTP模块提供了一个底层API，http.request(options, connect)，用于构造HTTP客户端。</p><p>options参数决定了这个HTTP请求头的内容，它的选项有如下：</p><ul><li>host：服务器的域名或ip地址，默认为localhost。</li><li>hostname：服务器名称。</li><li>port：服务器端口，默认为80。</li><li>localAddress：建立网络连接的本地网卡。</li><li>scoketPath：Domain套接字路径。</li><li>method：HTTP请求方法，默认为get。</li><li>path：请求路径，默认为/。</li><li>headers：请求头对象。</li><li>auth：Basic认证，这个值将被计算成请求头中的Authorization部分。</li></ul><ol><li><p>HTTP响应</p><p>ClientRequest在解析响应报文时，一解析完响应头就触发response事件。</p></li><li><p>HTTP代理</p><p>为了重用TCP连接，HTTP模块包含了一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host+port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建五个连接。它的实质是一个连接池。</p><p>一旦请求量过大，连接限制将会限制服务性能。可以通过在options中传递agent选项。可以设置agent为false脱离连接池的管理，使得请求不受并发的限制。</p><p>Agent对象的sockets和requests属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数。</p></li><li><p>HTTP客户端事件</p><ul><li>response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时。会触发该事件。</li><li>socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li><li>connect：当客户端向服务器端发起connect请求时，如果服务器端响应了200状态码，客户端将会触发该事件。</li><li>Upgrade:客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。</li><li>continus：客户端向服务器端发起Expect: 100-continus头信息，以试图发送较大数据量，如果服务器端响应100 不。continue状态，客户端将会触发该事件。</li></ul></li></ol><h3 id="_7-4-构建websocket服务" tabindex="-1"><a class="header-anchor" href="#_7-4-构建websocket服务" aria-hidden="true">#</a> 7.4 构建WebSocket服务</h3><p>WebScoket客户端基于事件的编程模型与Node中自定义事件相差无几；WebScoket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。</p><p>WebSocket好处：</p><ul><li>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。</li><li>WebScoket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。</li><li>有轻量级的协议头，减少数据传送量。</li></ul><p>长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）。</p><p>使用WebSocket的话，网页客户端只需要一个TCP连接即可完成双向通信，在客户端与服务器端频繁通信时，无需频繁断开连接和重发请求。</p><h4 id="webscoket握手" tabindex="-1"><a class="header-anchor" href="#webscoket握手" aria-hidden="true">#</a> WebScoket握手</h4><p>一旦Websocket握手成功，服务器端与客户端将会呈现对等的效果，都能接收和发送消息。</p><h4 id="websocket数据传输" tabindex="-1"><a class="header-anchor" href="#websocket数据传输" aria-hidden="true">#</a> WebSocket数据传输</h4><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJ1gS.jpg" alt="gjJ1gS.jpg"></p><p>ws模块封装了WebScoket的底层实现。</p><h3 id="_7-5-网络服务与安全" tabindex="-1"><a class="header-anchor" href="#_7-5-网络服务与安全" aria-hidden="true">#</a> 7.5 网络服务与安全</h3><p>SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。</p><p>Node在网络安全上提供了3个模块，分别是crypto、tls、https。</p><p>crypto主要用于加密解密，SHA1、MD5等加密算法都在其中。tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。https与http模块接口一致，区别是它建立在安全的连接之上。</p><h4 id="tls-ssl" tabindex="-1"><a class="header-anchor" href="#tls-ssl" aria-hidden="true">#</a> TLS/SSL</h4><ol><li><p>密钥</p><p>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。</p><p>公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密。</p><p>在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJ3jg.jpg" alt="gjJ3jg.jpg"></p><p>Node底层采用的是openssl实现TLS/SSL的，生成公钥私钥可以用个openssl完成。</p><p>公私钥可能存在的漏洞是中间人攻击，通过数字证书认证可以解决这个问题。</p></li><li><p>数字证书</p><p>数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。</p><p>CA（Cretificate Authority，数字证书认证中心)。CA的作用是为站点颁发证书，这个证书通过CA通过自己的公钥和私钥实现的签名。</p><p>为了得到签名证书，服务器端需要通过自己的私钥生成CSR（证书签名请求）文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。</p><p>对于中小型企业，多半是采用自签名证书来构建安全网络的。所谓自签名证书就是自己扮演CA机构。给自己的服务器端颁发签名证书。</p></li></ol><h4 id="tls服务" tabindex="-1"><a class="header-anchor" href="#tls服务" aria-hidden="true">#</a> TLS服务</h4><ol><li><p>创建服务器端</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">tls</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">tls</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">server</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">tls</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createServer</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">options</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fn</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">server</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">listen</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">8080</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>TLS客户端</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">stream</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">tls</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">connect</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">8080</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">options</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fn</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">stream</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>与普通的TCP服务器端和客户端相比。TLS的服务器端和客户端仅仅只在证书的配置上有差别，其余部分基本相同。</p></li></ol><h4 id="https服务" tabindex="-1"><a class="header-anchor" href="#https服务" aria-hidden="true">#</a> HTTPS服务</h4><p>HTTPS服务就是工作在TLS/SSL上的HTTP。</p><ol><li><p>准备证书</p><p>HTTPS服务需要用到私钥和签名证书。</p></li><li><p>创建HTTPS服务</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">https</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">https</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">https</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createServer</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">options</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">200</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">heel world</span><span style="color:#EBCB8B;">\n</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">listen</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">8000</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p>HTTPS客户端</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">options</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">hostname</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">localhost</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">port</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">8000</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">path</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">/</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">method</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">GET</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">key</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">readFileSync</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">client.key</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">cert</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">readFileSync</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">client.crt</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">ca</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">readFileSync</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">ca.crt</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)]</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9;">options</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">agent</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">new</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">https</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Agent</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">options</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">req</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">https</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">request</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">options</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">setEncoding</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">utf-8</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,(</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">()</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ol><h2 id="第8章-构建web应用" tabindex="-1"><a class="header-anchor" href="#第8章-构建web应用" aria-hidden="true">#</a> 第8章 构建Web应用</h2><h3 id="_8-1-基础功能" tabindex="-1"><a class="header-anchor" href="#_8-1-基础功能" aria-hidden="true">#</a> 8.1 基础功能</h3><h4 id="请求方法" tabindex="-1"><a class="header-anchor" href="#请求方法" aria-hidden="true">#</a> 请求方法</h4><p>GET、POST、HEAD、DELETE、PUT、CONNECT</p><p>HTTP_Parser提供req.method方法获取请求方法</p><h4 id="路径分析" tabindex="-1"><a class="header-anchor" href="#路径分析" aria-hidden="true">#</a> 路径分析</h4><p>HTTP_Parser提供req.url方法获取路径解析</p><h4 id="查询字符串" tabindex="-1"><a class="header-anchor" href="#查询字符串" aria-hidden="true">#</a> 查询字符串</h4><p><code>?foo=bar&amp;baz=val</code>，Note提供了querystring模块用于处理这部分数据。</p><h4 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> Cookie</h4><h5 id="_1-初识cookie" tabindex="-1"><a class="header-anchor" href="#_1-初识cookie" aria-hidden="true">#</a> <strong>1.初识Cookie</strong></h5><p>Cookie的处理分为如下几步。</p><ul><li>服务器向客户端发送cookie。</li><li>浏览器将cookie保存。</li><li>之后每次浏览器都会将cookie发向服务器端。</li></ul><p>HTTP_Parser会将所有的报文字段解析到req.headers上，cookie是req.headers.cookie。Cookie的值格式是key=value；key2=value2。</p><p>浏览器端通过<code>document.cookie</code>获取cookie信息。</p><p>服务器端第一次发送cookie通过Set-Cooket字段。<code>Set-Cookie: name=value; Paht=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;</code></p><ul><li>path表示这个cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个cookie。</li><li>Expires和Max-Age是用来告知浏览器这个cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个cookie。</li><li>Secure。当Secure为true时，在HTTP中是无效的，在HTTPS中才有效。</li></ul><h5 id="_2-cookie的性能影响" tabindex="-1"><a class="header-anchor" href="#_2-cookie的性能影响" aria-hidden="true">#</a> 2.Cookie的性能影响</h5><p>一旦设置的cookie过多将会导致报头较大。</p><ul><li>减少cookie的大小。</li><li>为静态组件使用不同的域名。</li><li>减少DNS查询。</li></ul><h4 id="session" tabindex="-1"><a class="header-anchor" href="#session" aria-hidden="true">#</a> Session</h4><p>Session的数据值保留在服务器端，客户端无法修改，这样的数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。</p><ul><li><p>基于Cookie来实现用户和数据的映射</p></li><li><p>通过查询字符串来实现浏览器端和服务器端数据的对应</p><p>它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值的URL。</p></li></ul><ol><li><p>Session与内存</p><p>Session数据直接存在变量sessions中，它位于内存中。用户数量增多会引起性能问题。</p><p>解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解。</p></li><li><p>Session与安全</p><p>Seesion口令会被伪造，可能会造成服务器端数据被利用。</p><p>解决方法：将这个口令通过私钥加密进行签名，使得伪造的成本较高。在响应时将口令和签名进行对比，如果签名非法，我们将服务器中的数据立即过期即可。</p></li></ol><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h4><p>缓存方法：</p><ul><li>添加Expires或Cache-Control到报文头中。</li><li>配置ETag。</li><li>让Ajax可缓存。</li></ul><p>浏览器端如果在第二次请求如果不能确定这份本地文件是否可以直接使用，它将会发送一次条件请求，在普通的GET请求报文中，附带If-Modified-Since字段。</p><p>如果服务器端没有新的版本，只需响应一个304状态码，客户端就使用本地版本，如果服务器端有新的版本，就将新的内容发送给客户端，客户端放弃本地版本。</p><p>这里的条件请求采用时间戳的方式实现，但是时间戳有一些缺陷存在。</p><ul><li>文件的时间戳改动但内容并不一定改动。</li><li>时间戳只能精确到秒级别，更新频繁的内容将无法生效。</li></ul><p>为此HTTP1.1中引入了ETag的来解决这个问题，ETag由服务器端生成，服务器端可以决定它生成规则。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">gethash</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">str</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">shasum</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">crtpto</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createHash</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">sha1</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">shasum</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">update</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">str</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">digest</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">base64</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">handle</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">readFile</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">filename</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">err</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">file</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">hash</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">getHash</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">file</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">noneMatch</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">headers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">if-none-match</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">hash</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">===</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">noneMatch</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">304</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Not Modified</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">()</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">else</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">setHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">ETag</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">hash</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">200</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">OK</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">file</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;"> </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>ETag的请求和响应是If-None-Match/ETag。</p><p>在响应里设置Expires或Cache-Control头，浏览器将根据该值进行缓存。</p><p>Expires是一个GMT格式的时间字符串。浏览器在接收到这个过期值后，只有本地还存在这个缓存文件，在到期时间之前它都不会再发起请求。Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期或者到期后并没有被删除。Cache-Control以更丰富的形式，实现相同的功能。</p><p>Cache-Control设置了max-age值，可以避免服务器端与浏览器端时间不同步带来的不一致性问题。Cache-Control还可以设置public、private、no-cache、no-store等。</p><p>在浏览器中如果两个值同时存在且被同时支持时，max-age会覆盖Expires。</p><p><strong>清除缓存</strong></p><p>浏览器是根据URL进行缓存，一旦内容有所更新时，我们就让浏览器发起新的URL请求。一般的更新机制有如下两种。</p><ul><li>路径中跟随Web应用的版本号：<code>http://url.com/?v=20210401</code></li><li>路径中跟随该文件内容的hash值：<code>http://url.com/?hash=afadfadwe</code></li></ul><p>hash值进行缓存淘汰会更加高效。</p><h4 id="basic认证" tabindex="-1"><a class="header-anchor" href="#basic认证" aria-hidden="true">#</a> Basic认证</h4><p>Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</p><p>Basic认证会去检查请求报头中的Authorization字段。Basic认证会将用户名和密码部分组合然后进行Base64编码。</p><p>响应头中的<code>WWW-Authenticate</code>字段会告知浏览器采用什么样的认证和加密方式。</p><p>Basic认证一般在只有HTTPS的情况下才会使用。</p><h3 id="_8-2-数据上传" tabindex="-1"><a class="header-anchor" href="#_8-2-数据上传" aria-hidden="true">#</a> 8.2 数据上传</h3><p>通过判断报头的<code>Transfer-Encoding</code>或<code>Content-Length</code>来判断请求中是否带有内容。</p><h4 id="_8-2-1-表单数据" tabindex="-1"><a class="header-anchor" href="#_8-2-1-表单数据" aria-hidden="true">#</a> 8.2.1 表单数据</h4><p>表单提交的请求头<code>Content-Type</code>字段值为<code>application/x-www-form-urlencoded</code>。</p><h4 id="_8-2-2-其他格式" tabindex="-1"><a class="header-anchor" href="#_8-2-2-其他格式" aria-hidden="true">#</a> 8.2.2 其他格式</h4><p>JSON类型的值为<code>application/json</code>，XML类型的值为<code>application/xml</code>。</p><p>解析JSON文件通过<code>JSON.parse()</code>，解析XML文件通过xml2js模块处理。</p><h4 id="_8-2-3-附件上传" tabindex="-1"><a class="header-anchor" href="#_8-2-3-附件上传" aria-hidden="true">#</a> 8.2.3 附件上传</h4><p>特殊表单的值为<code>multipart/form-data</code>。</p><h4 id="_8-2-4-数据上传于安全" tabindex="-1"><a class="header-anchor" href="#_8-2-4-数据上传于安全" aria-hidden="true">#</a> 8.2.4 数据上传于安全</h4><h5 id="_1-内存限制" tabindex="-1"><a class="header-anchor" href="#_1-内存限制" aria-hidden="true">#</a> 1.内存限制</h5><p>解决内存被占光的问题：</p><ul><li>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。</li><li>通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;">// 限制</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">bytes</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">1024</span></span>
<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">len</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">headers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">content-length</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">] </span><span style="color:#81A1C1;">?</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">parseInt</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">req</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">headers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">content-length</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">]</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">10</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">null</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">len</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">&amp;&amp;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">len</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">bytes</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">413</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">()</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">return</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="_2-csrf" tabindex="-1"><a class="header-anchor" href="#_2-csrf" aria-hidden="true">#</a> 2.CSRF</h5><p>CSRF的全称是Cross-Site Request Forgery，中文意思是跨站请求伪造。</p><p>解决CSRF攻击的方案有添加随机值的方式。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">generateRandom</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">len</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">crypto</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">randomBytes</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">Math</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">ceil</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">len</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">*</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">3</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">/</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">4</span><span style="color:#D8DEE9FF;">))</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">toString</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">base64</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">slice</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">0</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">len</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_8-3-路由解析" tabindex="-1"><a class="header-anchor" href="#_8-3-路由解析" aria-hidden="true">#</a> 8.3 路由解析</h3><h4 id="_8-3-1-文件路径型" tabindex="-1"><a class="header-anchor" href="#_8-3-1-文件路径型" aria-hidden="true">#</a> 8.3.1 文件路径型</h4><ol><li><p>静态文件</p><p>将请求路径对应的文件发送给客户端即可。</p></li><li><p>动态文件（少见）</p><p>Web服务器根据URL路径找到对应的文件。</p></li></ol><h4 id="_8-3-2-mvc" tabindex="-1"><a class="header-anchor" href="#_8-3-2-mvc" aria-hidden="true">#</a> 8.3.2 MVC</h4><p>MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。</p><ul><li>控制器（Controller），一组行为的集合。</li><li>模型（Model），数据相关的操作和封装。</li><li>视图（View），视图的渲染。</li></ul><p>工作模式如下</p><ul><li>路由解析，根据URL寻找到对应的控制器和行为。</li><li>行为调用相关的模型，进行数据操作。</li><li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li></ul><p>路由映射分为手工映射和自然关联映射。</p><h4 id="_8-3-3-restful" tabindex="-1"><a class="header-anchor" href="#_8-3-3-restful" aria-hidden="true">#</a> 8.3.3 RESTful</h4><p>REST的全称是Representational State Transfer，中文含义为表现层状态转化。</p><p>通过URL设计资源、请求方法定义资源的操作，通过Accept决定资源的表现形式。</p><h3 id="_8-4-中间件" tabindex="-1"><a class="header-anchor" href="#_8-4-中间件" aria-hidden="true">#</a> 8.4 中间件</h3><p>中间件可以用来简化和隔离基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p><h4 id="_8-4-1-异常处理" tabindex="-1"><a class="header-anchor" href="#_8-4-1-异常处理" aria-hidden="true">#</a> 8.4.1 异常处理</h4><p>添加err参数，捕获中间件直接抛出的同步异常。</p><h4 id="_8-4-2-中间件与性能" tabindex="-1"><a class="header-anchor" href="#_8-4-2-中间件与性能" aria-hidden="true">#</a> 8.4.2 中间件与性能</h4><ol><li><p>编写高效的中间件</p><ul><li>使用高效的方法。</li><li>缓存需要重复计算的结果。</li><li>避免不必要的计算。</li></ul></li><li><p>合理使用路由</p><p>提升匹配成功率，避免QPS直线下降。</p></li></ol><h3 id="_8-5-页面渲染" tabindex="-1"><a class="header-anchor" href="#_8-5-页面渲染" aria-hidden="true">#</a> 8.5 页面渲染</h3><h4 id="_8-5-1-内容响应" tabindex="-1"><a class="header-anchor" href="#_8-5-1-内容响应" aria-hidden="true">#</a> 8.5.1 内容响应</h4><ol><li><p>MIME</p><p>浏览器通过不同的Content-Type的值来决定采用不同的渲染方式，这个值简称MIME值。</p><p>MIME的全称是Multipurpose Internet Mail Extensions。</p></li><li><p>附件下载</p><p><code>Content-Disposition</code>字段可以让客户端根据它的值判断应该讲报文数据当做即时浏览的内容，还是可下载的附件。</p><p>即时查看值为inline，存为附件值为attachement。<code>Content-Disposition: attachment; filename=&quot;filename.ext&quot;</code></p></li><li><p>响应JSON</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">json</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">json</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">setHeader</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Content-Type</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">application/json</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">200</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">JSON</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">stringify</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">json</span><span style="color:#D8DEE9FF;">))</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p>响应跳转</p><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">redirect</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">url</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">setHeader</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Location</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">url</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">writeHead</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">302</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">res</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">end</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">Redirect to </span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">+</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">url</span><span style="color:#D8DEE9FF;">)</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol><h4 id="_8-5-2-视图渲染" tabindex="-1"><a class="header-anchor" href="#_8-5-2-视图渲染" aria-hidden="true">#</a> 8.5.2 视图渲染</h4><p>通过后端返回html片段生成视图。</p><h4 id="_8-5-3-模板" tabindex="-1"><a class="header-anchor" href="#_8-5-3-模板" aria-hidden="true">#</a> 8.5.3 模板</h4><p>实质是将模板文件和数据通过模板引擎生成最终的HTML代码。模板技术使得网页中的动态内容和静态内容变得不互相依赖。</p><ol><li><p>模板引擎</p><ul><li>语法分解。提取出普通字符串和表达式。</li><li>处理表达式。将标签表达式转换成普通的语言表达式。</li><li>生成待执行的语句。</li><li>与数据一起执行，生成最终字符串。</li></ul><p>将原始的模板字符串转成一个函数对象，这个过程称为模板编译。</p></li><li><p>with的应用</p><p><code>tpl = &#39;var tpl = &quot;&quot;;\nwith (obj) {&#39; + tpl + &#39;}\nreturn tpl;&#39;;</code></p><p>模板技术需要注意时刻转义。</p></li><li><p>模板逻辑</p></li><li><p>集成文件系统</p></li><li><p>子模板</p></li><li><p>布局视图</p></li><li><p>模板性能</p></li></ol><p>模板引擎模块<strong>EJS</strong>。</p><h4 id="_8-5-4-bigpipe" tabindex="-1"><a class="header-anchor" href="#_8-5-4-bigpipe" aria-hidden="true">#</a> 8.5.4 Bigpipe</h4><p>在数据响应之前，用户看到的是空白页面，这对用户体验十分不友好。Bigpipe的解决思路是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，最终渲染填充框架，完成整个页面的渲染。需要前后端的配合。</p><h2 id="第9章-玩转进程" tabindex="-1"><a class="header-anchor" href="#第9章-玩转进程" aria-hidden="true">#</a> 第9章 玩转进程</h2><p>JavaScript运行在单个进程的单个线程上。</p><h3 id="_9-1-服务模型的变迁" tabindex="-1"><a class="header-anchor" href="#_9-1-服务模型的变迁" aria-hidden="true">#</a> 9.1 服务模型的变迁</h3><h4 id="_9-1-1-石器时代-同步" tabindex="-1"><a class="header-anchor" href="#_9-1-1-石器时代-同步" aria-hidden="true">#</a> 9.1.1 石器时代：同步</h4><p>服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。QPS为1/N。</p><h4 id="_9-1-2-青铜时代-复制进程" tabindex="-1"><a class="header-anchor" href="#_9-1-2-青铜时代-复制进程" aria-hidden="true">#</a> 9.1.2 青铜时代：复制进程</h4><p>通过进程的复制同时服务更多的请求和用户。QPS为M/N。</p><h4 id="_9-1-3-白银时代-多线程" tabindex="-1"><a class="header-anchor" href="#_9-1-3-白银时代-多线程" aria-hidden="true">#</a> 9.1.3 白银时代：多线程</h4><p>一个线程服务一个请求。由于一个CPU核心在一个时刻只能做一件事，操作系统只能通过将CPU切分为时间片的方法，让线程较为均匀地使用CPU资源。</p><p>当线程数量过多时，时间将会被耗用在上下文切换中。QPS为M*L/N。</p><h4 id="_9-1-4-黄金时代-事件驱动" tabindex="-1"><a class="header-anchor" href="#_9-1-4-黄金时代-事件驱动" aria-hidden="true">#</a> 9.1.4 黄金时代：事件驱动</h4><p>采用单线程避免了不必要的内存开销和上下文切换开销。</p><p>对于Node来说，所有请求的上下文都是统一的。</p><h3 id="_9-2-多进程架构" tabindex="-1"><a class="header-anchor" href="#_9-2-多进程架构" aria-hidden="true">#</a> 9.2 多进程架构</h3><p>Node提供了<code>child_process</code>模块实现多核CPU利用。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJJBj.jpg" alt="gjJJBj.jpg"></p><p>Master-Worker，主从模式，主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。</p><p>通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。fork()进程是昂贵的。</p><h4 id="_9-2-1-创建子进程" tabindex="-1"><a class="header-anchor" href="#_9-2-1-创建子进程" aria-hidden="true">#</a> 9.2.1 创建子进程</h4><p><code>child_process</code>模块提供创建子进程的能力，4个方法创建子进程。</p><ul><li>spawn()：启动一个子进程来执行命令。</li><li>exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它由一个回调函数获知子进程的状况。</li><li>execFile()：启动一个子进程来执行可执行文件。</li><li>fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。</li></ul><h4 id="_9-2-2-进程间通信" tabindex="-1"><a class="header-anchor" href="#_9-2-2-进程间通信" aria-hidden="true">#</a> 9.2.2 进程间通信</h4><p>主线程与工作线程之间通过<code>onmessage()</code>和<code>postMessage()</code>进行通信，子进程对象则由<code>send()</code>方法实现主进程向子进程发送数据，<code>message</code>事件实现收听子进程发来的数据。</p><p>父进程与子进程之间会创建IPC通道，通过IPC通道，父子进程之间才能通过message()和send()传递消息。</p><h5 id="进程间通信原理" tabindex="-1"><a class="header-anchor" href="#进程间通信原理" aria-hidden="true">#</a> 进程间通信原理</h5><p>IPC全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。</p><p>进程间通信的技术有命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node的通信技术具体实现有libuv提供，在Window下由命名管道（named pipe）实现，*nix系统由Unix Domain Socket实现。</p><p>父进程在实际创建子进程之前，会创建IPC通信并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。</p><p>由于IPC通道是用命名管道或Domain Socket创建的，属于双向通行。IPC通道被抽象为Stream对象，通过send()发送数据，message事件触发给应用层。</p><h4 id="_9-2-3-句柄传递" tabindex="-1"><a class="header-anchor" href="#_9-2-3-句柄传递" aria-hidden="true">#</a> 9.2.3 句柄传递</h4><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJYHs.jpg" alt="gjJYHs.jpg"></p><p><code>send()</code>方法第二个可选参数可以发送句柄。句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/gjJUNq.jpg" alt="gjJUNq.jpg"></p><h5 id="_1-句柄发送与还原" tabindex="-1"><a class="header-anchor" href="#_1-句柄发送与还原" aria-hidden="true">#</a> 1.句柄发送与还原</h5><p>子进程对象send()方法可以发送的句柄类型如下几种：</p><ul><li>net.Socket。TCP套接字。</li><li>net.Server。TCP服务器，任意建议在TCP服务器上的应用层服务都可以享受到它带来的好处。</li><li>net.Native。C++层面的TCP套接字或IPC管道。</li><li>dgram.Socket。UDP套接字。</li><li>dgram.Native。C++层面的UDP套接字。</li></ul><p>发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符是一个整数值。写入到IPC管道会通过JSON.Stringify()进行序列化，子进程读取时通过JSON.parse()解析还原。</p><h5 id="_2-端口共同监听" tabindex="-1"><a class="header-anchor" href="#_2-端口共同监听" aria-hidden="true">#</a> 2.端口共同监听</h5><p>send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p><p>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。</p><h3 id="_9-3-集群稳定之路" tabindex="-1"><a class="header-anchor" href="#_9-3-集群稳定之路" aria-hidden="true">#</a> 9.3 集群稳定之路</h3><h4 id="_9-3-1-进程事件" tabindex="-1"><a class="header-anchor" href="#_9-3-1-进程事件" aria-hidden="true">#</a> 9.3.1 进程事件</h4><p>除了message事件，还有如下事件：</p><ul><li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时触发该事件。</li><li>exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()被杀死，会得到第二个参数表示杀死进程时的信号。</li><li>close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li><li>disconnect：在父进程或子进程调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC管道。</li></ul><p><code>kill()</code>方法给子进程发送消息，它并不能真正的杀死子进程，子进程需要监听<strong>信号列表</strong>，之后做出回应。</p><h4 id="_9-3-2-自动重启" tabindex="-1"><a class="header-anchor" href="#_9-3-2-自动重启" aria-hidden="true">#</a> 9.3.2 自动重启</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">fork</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">child_process</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">fork</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">cpus</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">os</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">cpus</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">server</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">net</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createServer</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9;">server</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">listen</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">1337</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">workers</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{}</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">createWorker</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">worker</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#88C0D0;">fork</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">pid</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;"> exited.</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">delete</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">workers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">pid</span><span style="color:#D8DEE9FF;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#88C0D0;">createWorker</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">send</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">server</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">server</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">workers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">pid</span><span style="color:#D8DEE9FF;">] </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">worker</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Create worker. pid: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">pid</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">&lt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">cpus</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9FF;">length</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#81A1C1;">++</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#88C0D0;">createWorker</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9;">process</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=&gt;</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">pid</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">in</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">workers</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#D8DEE9;">workers</span><span style="color:#D8DEE9FF;">[</span><span style="color:#D8DEE9;">pid</span><span style="color:#D8DEE9FF;">]</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">kill</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><ol><li><p>自杀信号</p><p>工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止新的连接，当所有连接断开后才退出。</p><p>主进程在接受到自杀任务后，立即创建新的工作进程服务。</p></li><li><p>限量重启</p><p>在单位时间内规定只能重启多少次，超过限制就触发giveup事件。</p></li></ol><h4 id="_9-3-3-负载均衡" tabindex="-1"><a class="header-anchor" href="#_9-3-3-负载均衡" aria-hidden="true">#</a> 9.3.3 负载均衡</h4><p>保证多个处理单元工作量公平的策略叫负载均衡。</p><p>Node默认提供的机制是采用操作系统的抢占式策略。谁抢到谁服务。</p><p>**轮叫调度：**由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i=(i+1)mod n个进程来发送连接。</p><h4 id="_9-3-4-状态共享" tabindex="-1"><a class="header-anchor" href="#_9-3-4-状态共享" aria-hidden="true">#</a> 9.3.4 状态共享</h4><p>实现数据在多个进程之间的共享：</p><ol><li><p>第三方数据存储</p><p>将数据存放到数据库、磁盘文件、缓存服务（如Redis）。</p><p>通过定时轮询实现状态同步。轮询时间不能过密。</p></li><li><p>主动通知</p><p>当数据发生更新时，主动通知子进程。</p><p>为了不混合业务逻辑，可以添加一个通知进程来进行轮询和通知的工作，不处理任何业务逻辑。</p></li></ol><h3 id="_9-4-cluster模块" tabindex="-1"><a class="header-anchor" href="#_9-4-cluster模块" aria-hidden="true">#</a> 9.4 Cluster模块</h3><p>cluster模块解决多核CPU的利用率问题，提供了较完善的API，用以处理进程的健壮性问题。</p><h4 id="_9-4-1-cluster工作原理" tabindex="-1"><a class="header-anchor" href="#_9-4-1-cluster工作原理" aria-hidden="true">#</a> 9.4.1 Cluster工作原理</h4><p>cluster模块就是child_process和net模块的组合应用。</p><p>在cluster模块应用中，一个主进程只能管理一组工作进程。</p><h4 id="_9-4-2-cluster事件" tabindex="-1"><a class="header-anchor" href="#_9-4-2-cluster事件" aria-hidden="true">#</a> 9.4.2 Cluster事件</h4><ul><li>fork：复制一个工作进程后触发该事件。</li><li>online。</li><li>listening。</li><li>disconnect。</li><li>exit。</li><li>setup。</li></ul><h2 id="第10章-测试" tabindex="-1"><a class="header-anchor" href="#第10章-测试" aria-hidden="true">#</a> 第10章 测试</h2><p>测试的意义在于，在用户消费产出的代码之前，开发者首先消费它，给予其重要的质量保证。为自己代码写测试用例是一种行之有效的方法，它能够让开发者明确掌握到代码的行为和性能等。</p><p>测试包含单元测试、性能测试、安全测试和功能测试等几个方面。</p><h3 id="_10-1-单元测试" tabindex="-1"><a class="header-anchor" href="#_10-1-单元测试" aria-hidden="true">#</a> 10.1 单元测试</h3><h4 id="_10-1-1-单元测试的意义" tabindex="-1"><a class="header-anchor" href="#_10-1-1-单元测试的意义" aria-hidden="true">#</a> 10.1.1 单元测试的意义</h4><p>单元测试是最基本的能保证产品的质量的一种方式，如果没自己测试代码，那必然要面对如下问题：</p><ol><li><p>测试工程师是否可依赖？</p></li><li><p>第三方代码是否可依赖？</p></li><li><p>在产品迭代过程中，如何继续保证质量？</p><p>单元测试的意义在于每个测试用例的覆盖都是一种可能的承诺。</p></li></ol><p>缺少单元测试的质量保证，会陷入举步维艰的维护之路，拆东墙补西墙，开发者也渐渐变得只想做新项目，而旧的项目最后变得不可维护或不敢维护。</p><p>当无法为一段代码写出单元测试时，这段代码必然有坏味道，这样的代码最需要重构。好代码的单元测试必然是轻量的，重构和写单元测试之间是一个相互促进的步骤。</p><p>编写可测试代码有以下几个原则可以遵循：</p><ul><li><strong>单一职责</strong>。将职责进行解耦分离，变成两个单一职责的方法。</li><li><strong>接口抽象</strong>。</li><li><strong>层次分离</strong>。逐层测试，逐层保证。</li></ul><h4 id="_10-1-2-单元测试介绍" tabindex="-1"><a class="header-anchor" href="#_10-1-2-单元测试介绍" aria-hidden="true">#</a> 10.1.2 单元测试介绍</h4><p>单元测试主要包括断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面。</p><h5 id="_1-断言" tabindex="-1"><a class="header-anchor" href="#_1-断言" aria-hidden="true">#</a> 1. 断言</h5><p><code>断言</code>就是单元测试中用来保证最小单元是否正常的测试方法。</p><p>Node通过<code>assert</code>模块来实现断言。</p><ul><li>ok()：判断结果是否为真。</li><li>equal()：判断实际值与期望值是否相等。</li><li>notEqualI()。</li><li>deepEqual()：判断实际值与期望值是否深度相等。</li><li>notDeepEqual()。</li><li>strictEqual()：判断实际值与期望值是否严格相等（===）。</li><li>notStrictEqual()。</li><li>throws()：判断代码是否抛出异常。</li><li>doesNotThrow()。</li><li>ifError()：判断实际值是否为一个假值（null、undefined、0、&#39;&#39;、false），如果实际值为真指，将会抛出异常。</li></ul><h5 id="_2-测试框架" tabindex="-1"><a class="header-anchor" href="#_2-测试框架" aria-hidden="true">#</a> 2. 测试框架</h5><p>测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度。</p><p><code>mocha</code>、<code>jest</code>测试框架。</p><p>现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发），它们的差别如下：</p><ul><li>关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。</li><li>表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯。</li></ul><p>BDD采用<code>describe</code>和<code>it</code>组织，还提供了<code>before</code>、<code>after</code>、<code>beforeEach</code>、<code>afterEach</code>四个钩子方法。TDD采用<code>steup</code>和<code>test</code>完成，还提供<code>setup</code>和<code>teardown</code>钩子函数。</p><h5 id="_3-测试代码的文件组织" tabindex="-1"><a class="header-anchor" href="#_3-测试代码的文件组织" aria-hidden="true">#</a> 3. 测试代码的文件组织</h5><p>在package.json的devDependencies添加mocha字段即可。</p><h5 id="_4-测试用例" tabindex="-1"><a class="header-anchor" href="#_4-测试用例" aria-hidden="true">#</a> 4. 测试用例</h5><p>一个测试用例中包含至少一个断言。测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖。</p><ul><li><p>异步测试</p><p>通过it回调函数的实参调用注入通知测试框架当前用例执行完成才能继续执行下一个测试用例。</p></li><li><p>超时设置</p><p>mocha给所有涉及异步的测试用例添加超时限制，防止测试程序卡死。</p><p>可以通过<code>mocha -t &lt;ms&gt;</code>或者在it中调用<code>this.timeout(ms)</code>设置。</p></li></ul><h5 id="_5-测试覆盖率" tabindex="-1"><a class="header-anchor" href="#_5-测试覆盖率" aria-hidden="true">#</a> 5. 测试覆盖率</h5><p>测试覆盖率是单元测试的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况。</p><h5 id="_6-mock" tabindex="-1"><a class="header-anchor" href="#_6-mock" aria-hidden="true">#</a> 6. mock</h5><h5 id="_7-私有方法的测试" tabindex="-1"><a class="header-anchor" href="#_7-私有方法的测试" aria-hidden="true">#</a> 7. 私有方法的测试</h5><p><code>rewire</code>模块提供一种巧妙的方式实现对私有方法的访问。</p><p>每一个被rewire引入的模块的方法都有<code>__set__</code>和<code>__get__</code>方法。</p><h4 id="_10-1-3-工程化和自动化" tabindex="-1"><a class="header-anchor" href="#_10-1-3-工程化和自动化" aria-hidden="true">#</a> 10.1.3 工程化和自动化</h4><h5 id="_1-工程化" tabindex="-1"><a class="header-anchor" href="#_1-工程化" aria-hidden="true">#</a> 1. 工程化</h5><p>使用Makefile等成熟工具</p><ul><li>Makefile文件的缩进必须是tab符号，不能用空格。</li><li>记得在包描述文件中配置blanket。</li></ul><h5 id="_2-持续集成" tabindex="-1"><a class="header-anchor" href="#_2-持续集成" aria-hidden="true">#</a> 2. 持续集成</h5><p>利用travis-ci实现持续集成。</p><h3 id="_10-2-性能测试" tabindex="-1"><a class="header-anchor" href="#_10-2-性能测试" aria-hidden="true">#</a> 10.2 性能测试</h3><p>性能测试包括负载测试、压力测试和基准测试等。</p><h4 id="_10-2-1-基准测试" tabindex="-1"><a class="header-anchor" href="#_10-2-1-基准测试" aria-hidden="true">#</a> 10.2.1 基准测试</h4><p>基准测试要统计的就是在多少时间内执行了多少次某个方法。</p><h4 id="_10-2-1-压力测试" tabindex="-1"><a class="header-anchor" href="#_10-2-1-压力测试" aria-hidden="true">#</a> 10.2.1 压力测试</h4><p>做压力测试需要考查的有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力。</p><p>最常用的工具有ab、siege、http_load等。</p><h4 id="_10-2-3-基准测试驱动开发" tabindex="-1"><a class="header-anchor" href="#_10-2-3-基准测试驱动开发" aria-hidden="true">#</a> 10.2.3 基准测试驱动开发</h4><p>流程：</p><ol><li>写基准测试。</li><li>写/改代码。</li><li>收集数据。</li><li>找出问题。</li><li>回到第2步。</li></ol><h4 id="_10-2-4-测试数据与业务数据的转换" tabindex="-1"><a class="header-anchor" href="#_10-2-4-测试数据与业务数据的转换" aria-hidden="true">#</a> 10.2.4 测试数据与业务数据的转换</h4><p>每天100万的业务访问量换算为QPS，主要访问量集中在10小时以内，QPS=PV/10h，约等于27.7，即服务器需要每秒处理27.7个请求才能胜任业务量。</p><h2 id="第11章-产品化" tabindex="-1"><a class="header-anchor" href="#第11章-产品化" aria-hidden="true">#</a> 第11章 产品化</h2><p>在实际产品中，需要很多非编码相关的工作比如工程化、架构、容灾备份、部署和运维等来保证项目的进展和产品的正常运行等。</p><h3 id="_11-1-项目工程化" tabindex="-1"><a class="header-anchor" href="#_11-1-项目工程化" aria-hidden="true">#</a> 11.1 项目工程化</h3><p>项目工程化，可以理解为项目的组织能力。在项目工程化过程中，最基本的几部是目录结构、构建工具、编码规范和代码审查等。</p><h4 id="_11-1-1-目录结构" tabindex="-1"><a class="header-anchor" href="#_11-1-1-目录结构" aria-hidden="true">#</a> 11.1.1 目录结构</h4><p>项目主要分为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范，Web应用只要遵循单一原则即可。</p><h4 id="_11-1-2-构建工具" tabindex="-1"><a class="header-anchor" href="#_11-1-2-构建工具" aria-hidden="true">#</a> 11.1.2 构建工具</h4><h5 id="_1-makefile" tabindex="-1"><a class="header-anchor" href="#_1-makefile" aria-hidden="true">#</a> 1.MakeFile</h5><p>Makefile文件通常用来管理一些编译相关的工作。</p><h5 id="_2-grunt" tabindex="-1"><a class="header-anchor" href="#_2-grunt" aria-hidden="true">#</a> 2.Grunt</h5><p>Grunt用Node写成，能够在window和*nix平台下运行。</p><p>Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的插入。</p><h4 id="_11-1-3-编码规范" tabindex="-1"><a class="header-anchor" href="#_11-1-3-编码规范" aria-hidden="true">#</a> 11.1.3 编码规范</h4><p>制定良好的编码规范，有助于项目后期的维护。</p><h4 id="_11-1-4-代码审查" tabindex="-1"><a class="header-anchor" href="#_11-1-4-代码审查" aria-hidden="true">#</a> 11.1.4 代码审查</h4><p>代码审查主要是请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等。</p><p>如果不符合规范，就需要重新更改代码，然后再提交审查。</p><h3 id="_11-2-部署流程" tabindex="-1"><a class="header-anchor" href="#_11-2-部署流程" aria-hidden="true">#</a> 11.2 部署流程</h3><h4 id="_11-2-1-部署环境" tabindex="-1"><a class="header-anchor" href="#_11-2-1-部署环境" aria-hidden="true">#</a> 11.2.1 部署环境</h4><p>测试环境(stage)-&gt;预发布环境(pre-release)-&gt;生产环境(product)。</p><h4 id="_11-2-2-部署操作" tabindex="-1"><a class="header-anchor" href="#_11-2-2-部署操作" aria-hidden="true">#</a> 11.2.2 部署操作</h4><p>通过脚本实现应用的启动、停止和重启等操作。</p><h3 id="_11-3-性能" tabindex="-1"><a class="header-anchor" href="#_11-3-性能" aria-hidden="true">#</a> 11.3 性能</h3><ul><li>做专一的事。</li><li>让擅长的工具做擅长的事情。</li><li>将模型简化。</li><li>将风险分离。</li></ul><h4 id="_11-3-1-动静分离" tabindex="-1"><a class="header-anchor" href="#_11-3-1-动静分离" aria-hidden="true">#</a> 11.3.1 动静分离</h4><p>让Node只处理动态请求，静态文件引导到专业的静态文件服务器处理。</p><h4 id="_11-3-2-启用缓存" tabindex="-1"><a class="header-anchor" href="#_11-3-2-启用缓存" aria-hidden="true">#</a> 11.3.2 启用缓存</h4><p>避免不必要的计算能带来性能的显著提升。</p><h4 id="_11-3-3-多进程架构" tabindex="-1"><a class="header-anchor" href="#_11-3-3-多进程架构" aria-hidden="true">#</a> 11.3.3 多进程架构</h4><p>pm、forever、pm2模块用于进程管理。</p><h4 id="_11-3-4-读写分离" tabindex="-1"><a class="header-anchor" href="#_11-3-4-读写分离" aria-hidden="true">#</a> 11.3.4 读写分离</h4><p>数据库读写分离，使用主从设计。</p><h3 id="_11-4-日志" tabindex="-1"><a class="header-anchor" href="#_11-4-日志" aria-hidden="true">#</a> 11.4 日志</h3><h4 id="_11-4-1-访问日志" tabindex="-1"><a class="header-anchor" href="#_11-4-1-访问日志" aria-hidden="true">#</a> 11.4.1 访问日志</h4><p>通过日志中间件记录日志。</p><h4 id="_11-4-2-异常日志" tabindex="-1"><a class="header-anchor" href="#_11-4-2-异常日志" aria-hidden="true">#</a> 11.4.2 异常日志</h4><p>console对象：</p><ul><li>console.log：普通日志。</li><li>console.info：普通信息。</li><li>console.warn：警告信息。</li><li>console.error：错误信息。</li></ul><p>异常尽量由最上层的调用者捕获记录，底层调用或中间层调用中出现的异常只要正常传递给上层的调用方即可。</p><h4 id="_11-4-3-日志与数据库" tabindex="-1"><a class="header-anchor" href="#_11-4-3-日志与数据库" aria-hidden="true">#</a> 11.4.3 日志与数据库</h4><p>不要将日志直接写入数据库，将日志分析和日志记录两个步骤分离是较好的选择。</p><h4 id="_11-4-4-分割日志" tabindex="-1"><a class="header-anchor" href="#_11-4-4-分割日志" aria-hidden="true">#</a> 11.4.4 分割日志</h4><p>当访问量巨大时，将产生的日志按日期分割是一个不错的主意。</p><h3 id="_11-5-监控报警" tabindex="-1"><a class="header-anchor" href="#_11-5-监控报警" aria-hidden="true">#</a> 11.5 监控报警</h3><p>监控分为业务逻辑型的监控和硬件型的监控。</p><h4 id="_11-5-1-监控" tabindex="-1"><a class="header-anchor" href="#_11-5-1-监控" aria-hidden="true">#</a> 11.5.1 监控</h4><h5 id="_1-日志监控" tabindex="-1"><a class="header-anchor" href="#_1-日志监控" aria-hidden="true">#</a> 1.日志监控</h5><p>从访问日志中实现PV和UV的监控，同QPS值一样，通过对PV/UV的监控，可以很好地知道应用的使用者们的习惯、预知访问高峰等。</p><h5 id="_2-响应时间" tabindex="-1"><a class="header-anchor" href="#_2-响应时间" aria-hidden="true">#</a> 2.响应时间</h5><p>通过Nginx的反向代理监控，也可以通过应用自行产生的访问日志来监控。</p><h5 id="_3-进程监控" tabindex="-1"><a class="header-anchor" href="#_3-进程监控" aria-hidden="true">#</a> 3.进程监控</h5><p>检查工作进程的数量，如果低于预估值，就应当发出报警声。</p><h5 id="_4-磁盘监控" tabindex="-1"><a class="header-anchor" href="#_4-磁盘监控" aria-hidden="true">#</a> 4.磁盘监控</h5><p>监控磁盘的用量。</p><h5 id="_5-内存监控" tabindex="-1"><a class="header-anchor" href="#_5-内存监控" aria-hidden="true">#</a> 5.内存监控</h5><p>监控服务器的内存使用状况，可以检查应用中是否存在内存泄漏的情况。</p><h5 id="_6-cpu占用监控" tabindex="-1"><a class="header-anchor" href="#_6-cpu占用监控" aria-hidden="true">#</a> 6.CPU占用监控</h5><p>CPU使用分为用户态（服务器应用开销）、内核态（服务器进程调度和系统调用）、IOWait（CPU等待磁盘I/O操作）等。</p><h5 id="_7-cpu-load监控" tabindex="-1"><a class="header-anchor" href="#_7-cpu-load监控" aria-hidden="true">#</a> 7.CPU load监控</h5><p>CPU load用来描述操作系统当前的繁忙程度。</p><h5 id="_8-i-o负载" tabindex="-1"><a class="header-anchor" href="#_8-i-o负载" aria-hidden="true">#</a> 8.I/O负载</h5><h5 id="_9-网络监控" tabindex="-1"><a class="header-anchor" href="#_9-网络监控" aria-hidden="true">#</a> 9.网络监控</h5><p>网络流量监控的两个主要指标是流入流量和流出流量。</p><h5 id="_10-应用状态监控" tabindex="-1"><a class="header-anchor" href="#_10-应用状态监控" aria-hidden="true">#</a> 10.应用状态监控</h5><h5 id="_11-dns监控" tabindex="-1"><a class="header-anchor" href="#_11-dns监控" aria-hidden="true">#</a> 11.DNS监控</h5><h4 id="_11-5-2-报警的实现" tabindex="-1"><a class="header-anchor" href="#_11-5-2-报警的实现" aria-hidden="true">#</a> 11.5.2 报警的实现</h4><ul><li><p>邮件报警</p><p>通过nodemailer模块实现。</p></li><li><p>短信或电话报警</p></li></ul><h3 id="_11-6-稳定性" tabindex="-1"><a class="header-anchor" href="#_11-6-稳定性" aria-hidden="true">#</a> 11.6 稳定性</h3><ul><li>多机器</li><li>多机房</li><li>容灾备份</li></ul><h3 id="_11-7-异构共存" tabindex="-1"><a class="header-anchor" href="#_11-7-异构共存" aria-hidden="true">#</a> 11.7 异构共存</h3><p>协议几乎是解决异构系统最完美的方案。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: czl624824554@163.com">chenzilin</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog-site/assets/app.06e41ebd.js" defer></script>
  </body>
</html>
