<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/blog-site/578220.ico"><title>第1章 基础 | Leon Chen</title><meta name="description" content="">
    <link rel="modulepreload" href="/blog-site/assets/app.5b55431a.js"><link rel="modulepreload" href="/blog-site/assets/《算法》.html.70222b5c.js"><link rel="modulepreload" href="/blog-site/assets/《算法》.html.fe2a4b60.js"><link rel="modulepreload" href="/blog-site/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blog-site/assets/style.5c2fd74e.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog-site/" class=""><img class="logo" src="/blog-site/578220.png" alt="Leon Chen"><span class="site-name can-hide">Leon Chen</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程书籍笔记"><!--[--><!--]--> 编程书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外书籍笔记"><!--[--><!--]--> 课外书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="编程疑问清单"><!--[--><!--]--> 编程疑问清单 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/leetcode" class="" aria-label="LeetCode题解"><!--[--><!--]--> LeetCode题解 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程书籍笔记"><!--[--><!--]--> 编程书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外书籍笔记"><!--[--><!--]--> 课外书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="编程疑问清单"><!--[--><!--]--> 编程疑问清单 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/leetcode" class="" aria-label="LeetCode题解"><!--[--><!--]--> LeetCode题解 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">第1章 基础 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-1-基础编程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 基础编程模型"><!--[--><!--]--> 1.1 基础编程模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-3-背包、队列和栈" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 背包、队列和栈"><!--[--><!--]--> 1.3 背包、队列和栈 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-3-2-算术表达式求值" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3.2 算术表达式求值"><!--[--><!--]--> 1.3.2 算术表达式求值 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-3-3-链表" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3.3 链表"><!--[--><!--]--> 1.3.3 链表 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-4-算法分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 算法分析"><!--[--><!--]--> 1.4 算法分析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-5-案例研究-union-find算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 案例研究：union-find算法"><!--[--><!--]--> 1.5 案例研究：union-find算法 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-5-2-实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5.2 实现"><!--[--><!--]--> 1.5.2 实现 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-1-初始排序算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 初始排序算法"><!--[--><!--]--> 2.1 初始排序算法 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-1-2-选择排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1.2 选择排序"><!--[--><!--]--> 2.1.2 选择排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-1-3-插入排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1.3 插入排序"><!--[--><!--]--> 2.1.3 插入排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-1-6-希尔排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1.6 希尔排序"><!--[--><!--]--> 2.1.6 希尔排序 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-2-归并排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 归并排序"><!--[--><!--]--> 2.2 归并排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-3-快速排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 快速排序"><!--[--><!--]--> 2.3 快速排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-4-优先队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 优先队列"><!--[--><!--]--> 2.4 优先队列 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#二叉堆" class="router-link-active router-link-exact-active sidebar-item" aria-label="二叉堆"><!--[--><!--]--> 二叉堆 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#多叉堆" class="router-link-active router-link-exact-active sidebar-item" aria-label="多叉堆"><!--[--><!--]--> 多叉堆 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#索引优先队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引优先队列"><!--[--><!--]--> 索引优先队列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#堆排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="堆排序"><!--[--><!--]--> 堆排序 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-5-应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 应用"><!--[--><!--]--> 2.5 应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-1-符号表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 符号表"><!--[--><!--]--> 3.1 符号表 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-1-2-有序符号表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1.2 有序符号表"><!--[--><!--]--> 3.1.2 有序符号表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-1-4-无序链表中的顺序查找" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1.4 无序链表中的顺序查找"><!--[--><!--]--> 3.1.4 无序链表中的顺序查找 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-1-5-有序数组中的二分查找" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1.5 有序数组中的二分查找"><!--[--><!--]--> 3.1.5 有序数组中的二分查找 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-2-二叉查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 二叉查找树"><!--[--><!--]--> 3.2 二叉查找树 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#删除结点" class="router-link-active router-link-exact-active sidebar-item" aria-label="删除结点"><!--[--><!--]--> 删除结点 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-3-平衡查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 平衡查找树"><!--[--><!--]--> 3.3 平衡查找树 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-3查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="2-3查找树"><!--[--><!--]--> 2-3查找树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#红黑二叉查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="红黑二叉查找树"><!--[--><!--]--> 红黑二叉查找树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#删除操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="删除操作"><!--[--><!--]--> 删除操作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#红黑树的性质" class="router-link-active router-link-exact-active sidebar-item" aria-label="红黑树的性质"><!--[--><!--]--> 红黑树的性质 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-4-散列表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 散列表"><!--[--><!--]--> 3.4 散列表 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#散列函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="散列函数"><!--[--><!--]--> 散列函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#碰撞处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="碰撞处理"><!--[--><!--]--> 碰撞处理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-5-应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 应用"><!--[--><!--]--> 3.5 应用 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#集合api" class="router-link-active router-link-exact-active sidebar-item" aria-label="集合API"><!--[--><!--]--> 集合API <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#字典类用例" class="router-link-active router-link-exact-active sidebar-item" aria-label="字典类用例"><!--[--><!--]--> 字典类用例 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#索引类用例" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引类用例"><!--[--><!--]--> 索引类用例 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#稀疏向量" class="router-link-active router-link-exact-active sidebar-item" aria-label="稀疏向量"><!--[--><!--]--> 稀疏向量 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_4-1-无向图" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 无向图"><!--[--><!--]--> 4.1 无向图 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#术语概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="术语概述"><!--[--><!--]--> 术语概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#无向图的数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="无向图的数据类型"><!--[--><!--]--> 无向图的数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#深度优先搜索-dfs" class="router-link-active router-link-exact-active sidebar-item" aria-label="深度优先搜索（DFS）"><!--[--><!--]--> 深度优先搜索（DFS） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#寻找路径" class="router-link-active router-link-exact-active sidebar-item" aria-label="寻找路径"><!--[--><!--]--> 寻找路径 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#广度优先搜索-bfs" class="router-link-active router-link-exact-active sidebar-item" aria-label="广度优先搜索（BFS）"><!--[--><!--]--> 广度优先搜索（BFS） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#连通分量" class="router-link-active router-link-exact-active sidebar-item" aria-label="连通分量"><!--[--><!--]--> 连通分量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#符号图" class="router-link-active router-link-exact-active sidebar-item" aria-label="符号图"><!--[--><!--]--> 符号图 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_4-2-有向图" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 有向图"><!--[--><!--]--> 4.2 有向图 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#有向图的数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="有向图的数据类型"><!--[--><!--]--> 有向图的数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#有向图的可达性" class="router-link-active router-link-exact-active sidebar-item" aria-label="有向图的可达性"><!--[--><!--]--> 有向图的可达性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#环和有向无环图" class="router-link-active router-link-exact-active sidebar-item" aria-label="环和有向无环图"><!--[--><!--]--> 环和有向无环图 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#有向图中的强连通性" class="router-link-active router-link-exact-active sidebar-item" aria-label="有向图中的强连通性"><!--[--><!--]--> 有向图中的强连通性 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_4-3-最小生成树" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 最小生成树"><!--[--><!--]--> 4.3 最小生成树 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="原理"><!--[--><!--]--> 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#加权无向图的数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="加权无向图的数据类型"><!--[--><!--]--> 加权无向图的数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#prim算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Prim算法"><!--[--><!--]--> Prim算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#kruskal算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Kruskal算法"><!--[--><!--]--> Kruskal算法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_4-4-最短路径" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 最短路径"><!--[--><!--]--> 4.4 最短路径 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#最短路径的性质" class="router-link-active router-link-exact-active sidebar-item" aria-label="最短路径的性质"><!--[--><!--]--> 最短路径的性质 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#dijkstra算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Dijkstra算法"><!--[--><!--]--> Dijkstra算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#无环加权有向图中的最短路径算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="无环加权有向图中的最短路径算法"><!--[--><!--]--> 无环加权有向图中的最短路径算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#一般加权有向图中的最短路径问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="一般加权有向图中的最短路径问题"><!--[--><!--]--> 一般加权有向图中的最短路径问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#bellman-ford算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Bellman-Ford算法"><!--[--><!--]--> Bellman-Ford算法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-1-字符串排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 字符串排序"><!--[--><!--]--> 5.1 字符串排序 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-1-1-键索引计数法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1.1 键索引计数法"><!--[--><!--]--> 5.1.1 键索引计数法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#算法思路" class="router-link-active router-link-exact-active sidebar-item" aria-label="算法思路："><!--[--><!--]--> 算法思路： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点："><!--[--><!--]--> 优点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点："><!--[--><!--]--> 缺点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-1-2-低位优先的字符串排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1.2 低位优先的字符串排序"><!--[--><!--]--> 5.1.2 低位优先的字符串排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-1-3-高位优先的字符串排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1.3 高位优先的字符串排序"><!--[--><!--]--> 5.1.3 高位优先的字符串排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#算法思路-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="算法思路："><!--[--><!--]--> 算法思路： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优点-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点："><!--[--><!--]--> 优点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#缺点-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点："><!--[--><!--]--> 缺点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-1-4-三向字符串快速排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1.4 三向字符串快速排序"><!--[--><!--]--> 5.1.4 三向字符串快速排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#排序思路" class="router-link-active router-link-exact-active sidebar-item" aria-label="排序思路："><!--[--><!--]--> 排序思路： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优点-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点："><!--[--><!--]--> 优点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#缺点-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点："><!--[--><!--]--> 缺点： <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-2-单词查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 单词查找树"><!--[--><!--]--> 5.2 单词查找树 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#单词查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="单词查找树"><!--[--><!--]--> 单词查找树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-查找" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 查找："><!--[--><!--]--> 1. 查找： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-插入" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 插入："><!--[--><!--]--> 2. 插入： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_3-删除" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 删除："><!--[--><!--]--> 3. 删除： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#三向单词查找树" class="router-link-active router-link-exact-active sidebar-item" aria-label="三向单词查找树"><!--[--><!--]--> 三向单词查找树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#三向单词查找树的结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="三向单词查找树的结构"><!--[--><!--]--> 三向单词查找树的结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#三向单词查找树的优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="三向单词查找树的优点"><!--[--><!--]--> 三向单词查找树的优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#三向单词查找树的缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="三向单词查找树的缺点"><!--[--><!--]--> 三向单词查找树的缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#与单词查找树-trie-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="与单词查找树（Trie）的区别"><!--[--><!--]--> 与单词查找树（Trie）的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#查找操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="查找操作"><!--[--><!--]--> 查找操作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#插入操作-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="插入操作"><!--[--><!--]--> 插入操作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#删除操作-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="删除操作"><!--[--><!--]--> 删除操作 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-3-子字符串查找" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 子字符串查找"><!--[--><!--]--> 5.3 子字符串查找 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#暴力子字符串查找算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="暴力子字符串查找算法"><!--[--><!--]--> 暴力子字符串查找算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#knuth-morris-pratt-子字符串查找算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Knuth-Morris-Pratt 子字符串查找算法"><!--[--><!--]--> Knuth-Morris-Pratt 子字符串查找算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_1-构造部分匹配表-partial-match-table-也称为前缀表或失败函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 构造部分匹配表（Partial Match Table，也称为前缀表或失败函数）"><!--[--><!--]--> 1. 构造部分匹配表（Partial Match Table，也称为前缀表或失败函数） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_2-搜索算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 搜索算法"><!--[--><!--]--> 2. 搜索算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势"><!--[--><!--]--> 优势 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#dfa的基本概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="DFA的基本概念"><!--[--><!--]--> DFA的基本概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#dfa的应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="DFA的应用"><!--[--><!--]--> DFA的应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#状态-state" class="router-link-active router-link-exact-active sidebar-item" aria-label="状态（State）"><!--[--><!--]--> 状态（State） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#输入-input" class="router-link-active router-link-exact-active sidebar-item" aria-label="输入（Input）"><!--[--><!--]--> 输入（Input） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#转移规则-transition-function" class="router-link-active router-link-exact-active sidebar-item" aria-label="转移规则（Transition Function）"><!--[--><!--]--> 转移规则（Transition Function） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="过程"><!--[--><!--]--> 过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#kmp算法与dfa的联系" class="router-link-active router-link-exact-active sidebar-item" aria-label="KMP算法与DFA的联系"><!--[--><!--]--> KMP算法与DFA的联系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#boyer-moore-字符串查找算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Boyer-Moore 字符串查找算法"><!--[--><!--]--> Boyer-Moore 字符串查找算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#核心思路" class="router-link-active router-link-exact-active sidebar-item" aria-label="核心思路："><!--[--><!--]--> 核心思路： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优点-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点："><!--[--><!--]--> 优点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#缺点-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点："><!--[--><!--]--> 缺点： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="应用场景："><!--[--><!--]--> 应用场景： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#与kmp算法的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="与KMP算法的区别："><!--[--><!--]--> 与KMP算法的区别： <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#rabin-karp-指纹字符串查找算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Rabin-Karp 指纹字符串查找算法"><!--[--><!--]--> Rabin-Karp 指纹字符串查找算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#核心思路-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="核心思路"><!--[--><!--]--> 核心思路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#优点-4" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点"><!--[--><!--]--> 优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#缺点-4" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点"><!--[--><!--]--> 缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#应用场景-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="应用场景"><!--[--><!--]--> 应用场景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-4-正则表达式" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.4 正则表达式"><!--[--><!--]--> 5.4 正则表达式 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#非确定有限状态自动机" class="router-link-active router-link-exact-active sidebar-item" aria-label="非确定有限状态自动机"><!--[--><!--]--> 非确定有限状态自动机 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#确定有限状态自动机-dfa" class="router-link-active router-link-exact-active sidebar-item" aria-label="确定有限状态自动机（DFA）"><!--[--><!--]--> 确定有限状态自动机（DFA） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#非确定有限状态自动机-nfa" class="router-link-active router-link-exact-active sidebar-item" aria-label="非确定有限状态自动机（NFA）"><!--[--><!--]--> 非确定有限状态自动机（NFA） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#转换和等价性" class="router-link-active router-link-exact-active sidebar-item" aria-label="转换和等价性"><!--[--><!--]--> 转换和等价性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#模拟nfa运行" class="router-link-active router-link-exact-active sidebar-item" aria-label="模拟NFA运行"><!--[--><!--]--> 模拟NFA运行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#构造与正则表达式对应的nfa" class="router-link-active router-link-exact-active sidebar-item" aria-label="构造与正则表达式对应的NFA"><!--[--><!--]--> 构造与正则表达式对应的NFA <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#_5-5-数据压缩" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.5 数据压缩"><!--[--><!--]--> 5.5 数据压缩 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#局限" class="router-link-active router-link-exact-active sidebar-item" aria-label="局限"><!--[--><!--]--> 局限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#游程编码" class="router-link-active router-link-exact-active sidebar-item" aria-label="游程编码"><!--[--><!--]--> 游程编码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#工作原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="工作原理"><!--[--><!--]--> 工作原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="应用"><!--[--><!--]--> 应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#局限性" class="router-link-active router-link-exact-active sidebar-item" aria-label="局限性"><!--[--><!--]--> 局限性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#霍夫曼压缩" class="router-link-active router-link-exact-active sidebar-item" aria-label="霍夫曼压缩"><!--[--><!--]--> 霍夫曼压缩 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#工作原理-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="工作原理"><!--[--><!--]--> 工作原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#应用-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="应用"><!--[--><!--]--> 应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#局限性-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="局限性"><!--[--><!--]--> 局限性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#lzw压缩算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="LZW压缩算法"><!--[--><!--]--> LZW压缩算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#工作原理-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="工作原理"><!--[--><!--]--> 工作原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#应用-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="应用"><!--[--><!--]--> 应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#局限性-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="局限性"><!--[--><!--]--> 局限性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="对比"><!--[--><!--]--> 对比 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#游程编码-rle" class="router-link-active router-link-exact-active sidebar-item" aria-label="游程编码 (RLE)"><!--[--><!--]--> 游程编码 (RLE) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#霍夫曼编码" class="router-link-active router-link-exact-active sidebar-item" aria-label="霍夫曼编码"><!--[--><!--]--> 霍夫曼编码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#lzw压缩" class="router-link-active router-link-exact-active sidebar-item" aria-label="LZW压缩"><!--[--><!--]--> LZW压缩 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#总结-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#b-树" class="router-link-active router-link-exact-active sidebar-item" aria-label="B-树"><!--[--><!--]--> B-树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#后缀数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="后缀数组"><!--[--><!--]--> 后缀数组 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#网络流算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="网络流算法"><!--[--><!--]--> 网络流算法 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B.html#ford-fulkerson算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Ford-Fulkerson算法"><!--[--><!--]--> Ford-Fulkerson算法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="第1章-基础" tabindex="-1"><a class="header-anchor" href="#第1章-基础" aria-hidden="true">#</a> 第1章 基础</h1><p>编写一段计算机程序一般都是实现一种已有的方法来解决某个问题。这种方法大多和使用的编程语言无关——它适用于各种计算机以及编程语言。是这种方法而非计算机程序本身描述了解决问题的步骤。在计算机科学领域中，我们用<em>算法</em>这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础，是这个领域研究的核心。</p><p>学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。</p><h2 id="_1-1-基础编程模型" tabindex="-1"><a class="header-anchor" href="#_1-1-基础编程模型" aria-hidden="true">#</a> 1.1 基础编程模型</h2><p>编写递归代码时最重要的三个点：</p><ul><li>递归总有一个最简单的情况——方法的第一条语句总是一个包含return的条件语句。</li><li>递归调用总是去尝试解决一个规模更小的问题，这样递归才能收敛到最简单的情况。</li><li>递归调用的父问题和尝试解决的子问题之间不应该有交集。</li></ul><p>默认情况下，命令行参数、标准输入和标准输出是和应用程序绑定的，而应用程序是由能够接受命令输入的操作系统或是开发环境所支持。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_03_24_IMG_9187.jpg" alt="IMG_9187" style="zoom:25%;"><p>自动将一个原始类型转换为一个封装类型被称为自动装箱，自动将一个封装类型转换为一个原始数据类型被称为自动拆箱。</p><h2 id="_1-3-背包、队列和栈" tabindex="-1"><a class="header-anchor" href="#_1-3-背包、队列和栈" aria-hidden="true">#</a> 1.3 背包、队列和栈</h2><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_06_IMG_9327.jpg" alt="IMG_9327" style="zoom:25%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_06_IMG_9328.jpg" alt="IMG_9328" style="zoom:29%;"><p>背包是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_05_IMG_9321.jpg" alt="IMG_9321" style="zoom:25%;"><p>队列是一种基于**先进先出（FIFO）**策略的集合类型。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_05_IMG_9322.jpg" alt="IMG_9322" style="zoom:25%;"><p>栈是一种基于**后进先出（LIFO）**策略的集合类型。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_05_IMG_9323.jpg" alt="IMG_9323" style="zoom:25%;"><h3 id="_1-3-2-算术表达式求值" tabindex="-1"><a class="header-anchor" href="#_1-3-2-算术表达式求值" aria-hidden="true">#</a> 1.3.2 算术表达式求值</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_06_IMG_9326.jpg" alt="IMG_9326" style="zoom:25%;"><h3 id="_1-3-3-链表" tabindex="-1"><a class="header-anchor" href="#_1-3-3-链表" aria-hidden="true">#</a> 1.3.3 链表</h3><blockquote><p>链表是一种递归的数据结构，它或者为空（null），或者是含有泛型元素的结点和指向另一条链表的引用。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_06_IMG_9329.jpg" alt="IMG_9329" style="zoom:25%;"><p>添加和插入首结点</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_08_IMG_9332.jpg" alt="IMG_9332" style="zoom:25%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_08_IMG_9333.jpg" alt="IMG_9333" style="zoom:34%;"><p>实现任意插入和删除操作的标准解决方案是使用<strong>双向链表</strong>。</p><p>遍历：<code>for (Node x = first; x != null; x = x.next)</code></p><p><strong>栈</strong>和<strong>队列</strong>的实现可以实现链表结构。优点：</p><ul><li>它可以处理任意类型的数据；</li><li>所需的空间总是和集合大小成正比；</li><li>操作所需的时间总是和集合的大小无关。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_08_IMG_9334.jpg" alt="IMG_9334" style="zoom:25%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_08_IMG_9335.jpg" alt="IMG_9335" style="zoom:25%;"><p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。</p><p>两种表示对象集合的方式：<strong>数组（顺序存储）<strong>和</strong>链表（链式存储）</strong>。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_08_IMG_9336.jpg" alt="IMG_9336" style="zoom:25%;"><h2 id="_1-4-算法分析" tabindex="-1"><a class="header-anchor" href="#_1-4-算法分析" aria-hidden="true">#</a> 1.4 算法分析</h2><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_15_IMG_9361.jpg" alt="IMG_9361" style="zoom:33%;"><p>执行最频繁的指令（程序的内循环）决定了程序执行的总时间。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_15_IMG_9362.jpg" alt="IMG_9362" style="zoom:25%;"><p>对于大多数程序，得到其运行时间的数学模型所需的步骤如下：</p><ol><li>确定输入模型，定义问题的规模；</li><li>识别内循环；</li><li>根据内循环中的操作确定成本模型；</li><li>对于给定的输入，判断这些操作的执行频率。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_15_IMG_9363.jpg" alt="IMG_9363" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_15_IMG_9364.jpg" alt="IMG_9364" style="zoom:33%;"><p>在编程领域中，最常见的错误或许就是过于关注程序的性能。首要任务是写出解析正确地代码。第二常见的错误或许是完全忽略了程序的性能。几行优秀的代码有时能够给你带来巨大的收益。</p><h2 id="_1-5-案例研究-union-find算法" tabindex="-1"><a class="header-anchor" href="#_1-5-案例研究-union-find算法" aria-hidden="true">#</a> 1.5 案例研究：union-find算法</h2><blockquote><p>Union-Find 算法，也被称为 Disjoint Set Union (DSU)，是一种处理<strong>集合的合并和查询</strong>问题的数据结构和算法。这种数据结构可以高效地解决一些图论问题。</p><p>Union-Find 算法包括两个主要操作：</p><ol><li>Union：这个操作将两个集合合并为一个集合。具体来说，如果我们有两个元素，我们可以使用 union 操作将它们所在的集合合并。</li><li>Find：这个操作确定一个元素属于哪个集合。具体来说，如果我们有一个元素，我们可以使用 find 操作来查找该元素所在的集合的 &quot;代表&quot; 或 &quot;领导&quot;。</li></ol><p>Union-Find 算法在许多领域都有应用，包括：</p><ol><li>Kruskal&#39;s 算法：这是一种求解最小生成树问题的算法，它依赖于 Union-Find 数据结构来检查添加新的边是否会形成环。</li><li>连通性问题：在网络或图中，我们经常需要快速地检查两个节点是否连接。Union-Find 可以帮助我们有效地解决这类问题。</li><li>并查集也可以应用于一些动态连通性问题，其中连接和查询操作可以在任何时候发生。</li><li>图像分割和计算等价类：在图像处理和模式识别中，Union-Find 可以用来检测和标记连接的组件。</li></ol></blockquote><h3 id="_1-5-2-实现" tabindex="-1"><a class="header-anchor" href="#_1-5-2-实现" aria-hidden="true">#</a> 1.5.2 实现</h3><h4 id="quick-find算法" tabindex="-1"><a class="header-anchor" href="#quick-find算法" aria-hidden="true">#</a> quick-find算法</h4><p>缺点：quick-find算法一般无法处理大型问题，因为对于每一对输入union()都需要扫描整个id[]数组。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_16_IMG_9365.jpg" alt="IMG_9365" style="zoom:33%;"><h4 id="quick-union算法" tabindex="-1"><a class="header-anchor" href="#quick-union算法" aria-hidden="true">#</a> quick-union算法</h4><p>quick-union算法是一种用来解决并查集问题的算法，它的实现是通过构建一个树形结构来表示集合之间的联系。该算法的基本思想是将每个元素看成一个节点，在初始状态下，每个节点都是自己的父节点，表示它们各自为一个集合。在合并两个集合的过程中，我们只需要将其中一个集合的根节点指向另一个集合的根节点，从而将它们合并为一个集合。判断两个元素是否属于同一个集合时，只需要看它们的根节点是否相同即可。由于每次合并操作的复杂度都取决于树的高度，这种算法的时间复杂度通常为$O(NlogN)$，其中$N$是元素的个数。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9366.jpg" alt="IMG_9366" style="zoom:25%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9367.jpg" alt="IMG_9367" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9368.jpg" alt="IMG_9368" style="zoom:30%;"><h4 id="加权quick-union算法" tabindex="-1"><a class="header-anchor" href="#加权quick-union算法" aria-hidden="true">#</a> 加权quick-union算法</h4><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9369.jpg" alt="IMG_9369" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9370.jpg" alt="IMG_9370" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9371.jpg" alt="IMG_9371" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_17_IMG_9372.jpg" alt="IMG_9372" style="zoom:25%;"><h1 id="第2章-排序" tabindex="-1"><a class="header-anchor" href="#第2章-排序" aria-hidden="true">#</a> 第2章 排序</h1><p>排序就是将一组对象按照某种逻辑顺序重新排列的过程。</p><h2 id="_2-1-初始排序算法" tabindex="-1"><a class="header-anchor" href="#_2-1-初始排序算法" aria-hidden="true">#</a> 2.1 初始排序算法</h2><h3 id="_2-1-2-选择排序" tabindex="-1"><a class="header-anchor" href="#_2-1-2-选择排序" aria-hidden="true">#</a> 2.1.2 选择排序</h3><p>思路：找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此反复，直到将整个数组排序。</p><p>选择排序的<em>运行时间与输入无关</em>。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_19_selection.png" alt="Selection sort"></p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_19_Sorting_selection_sort_anim.gif" alt="img"></p><h3 id="_2-1-3-插入排序" tabindex="-1"><a class="header-anchor" href="#_2-1-3-插入排序" aria-hidden="true">#</a> 2.1.3 插入排序</h3><p>与选择排序不同，插入排序所需的时间取决于输入中元素的初始顺序。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_19_insertion.png" alt="Selection sort"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_22_iShot_2023-05-22_08.34.01.gif" alt="iShot_2023-05-22_08.34.01" style="zoom:67%;"><p>插入排序对于部分有序的数组十分高效，也很适合小规模数组。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_22_bars.png" alt="Visualization of selection sort and insertion sort"></p><h3 id="_2-1-6-希尔排序" tabindex="-1"><a class="header-anchor" href="#_2-1-6-希尔排序" aria-hidden="true">#</a> 2.1.6 希尔排序</h3><p>希尔排序是一种基于插入排序的快速排序算法。希尔排序的基本思想是将待排序的数组元素按照某种增量序列进行分组，对每组使用插入排序算法进行排序；然后，每次减小增量，再按组排序，直至增量为1，此时整个数组被看作是一组，再对整体进行一次插入排序。</p><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。透彻理解希尔排序的性能至今仍然是一项挑战。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_22_iShot_2023-05-22_08.50.40.gif" alt="iShot_2023-05-22_08.50.40" style="zoom:80%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_22_IMG_9392.jpg" alt="IMG_9392" style="zoom:33%;"><h2 id="_2-2-归并排序" tabindex="-1"><a class="header-anchor" href="#_2-2-归并排序" aria-hidden="true">#</a> 2.2 归并排序</h2><p>归并排序的优点是它能够保证将任意长度为N的数组排序所需时间和 $Nlog N$ 成正比。主要缺点是它所需的额外空间和 $N$ 成正比。</p><p>归并排序分为<em>自顶向下</em>和<em>自底向上</em>两种。当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。自底向上的归并排序比较适合用链表组织的数据</p><blockquote><p>递归实现的归并排序是算法设计中<strong>分治思想</strong>的典型应用。将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_23_iShot_2023-05-23_06.59.05.gif" alt="iShot_2023-05-23_06.59.05"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_23_mergesortTD.png" alt="Mergesort"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_23_mergesortBU.png" alt="Bottom-up mergesort"><h2 id="_2-3-快速排序" tabindex="-1"><a class="header-anchor" href="#_2-3-快速排序" aria-hidden="true">#</a> 2.3 快速排序</h2><p>快速排序流行的原因是它实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。快速排序的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为N的数组排序所需的时间和$Nlog N$成正比。</p><p>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。归并排序递归调用发生在处理整个数组之前；快速排序递归调用发生在处理整个数组之后。</p><p><em>三向切分</em>的快速排序适合有大量重复元素的数组。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_24_iShot_2023-05-24_07.19.18.gif" alt="iShot_2023-05-24_07.19.18"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_23_quicksort.png" alt="Quicksort trace"><p>经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算法更快。</p><h2 id="_2-4-优先队列" tabindex="-1"><a class="header-anchor" href="#_2-4-优先队列" aria-hidden="true">#</a> 2.4 优先队列</h2><p>删除最大元素和插入元素，这种数据类型叫做<em>优先队列</em>。</p><p>优先队列在很多算法和数据结构中都有应用，以下是一些常见的应用场景：</p><ol><li>Dijkstra算法：Dijkstra算法是一种单源最短路径算法，使用了优先队列来维护待处理的节点集合，每次从集合中选取距离最短的节点进行处理。</li><li>Prim算法：Prim算法是一种最小生成树算法，使用了优先队列来维护待处理的边集合，每次从集合中选取权值最小的边进行处理。</li><li>Huffman编码：Huffman编码是一种无损数据压缩算法，使用优先队列来构建哈夫曼树，每次从队列中选取权值最小的两个节点进行合并。</li><li>模拟系统：优先队列可以用于模拟一些系统，比如操作系统中的进程调度、网络中的数据包处理、事件驱动的仿真等。</li><li>贪心算法：一些贪心算法中，需要维护一个较大或较小的元素集合，这可以通过使用优先队列来实现。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_25_IMG_9400.jpg" alt="IMG_9400" style="zoom:33%;"><h3 id="二叉堆" tabindex="-1"><a class="header-anchor" href="#二叉堆" aria-hidden="true">#</a> 二叉堆</h3><blockquote><p>堆（Heap）是一种特殊的树形数据结构，满足堆的特性：每个节点的值都会大于或等于（或小于或等于）其子节点的值，且每个节点的左右子树也分别是一个堆。堆的两种主要类型是最大堆和最小堆。</p><ol><li><strong>最大堆</strong>：每个节点的值都大于或等于其子节点的值。在最大堆中，根节点包含的是最大值。</li><li><strong>最小堆</strong>：每个节点的值都小于或等于其子节点的值。在最小堆中，根节点包含的是最小值。</li></ol><p>堆的主要操作包括：</p><ol><li><strong>插入</strong>：在堆中插入新元素。这需要通过一种称为“<strong>上浮（swim）</strong>”的过程来保持堆的特性。</li><li><strong>删除</strong>：从堆中删除元素，通常是删除根节点的元素（最大堆中的最大值或最小堆中的最小值）。这需要通过一种称为“<strong>下沉（sink）</strong>”的过程来保持堆的特性。</li><li><strong>堆化</strong>：将一个无序的数组转化为一个堆。</li></ol><p>堆在很多领域都有应用，如优先队列、堆排序以及图形算法（如 Dijkstra&#39;s algorithm 和 Prim&#39;s algorithm）等。</p></blockquote><p>完全二叉树只用数组而不需要指针就可以表示。具体方法是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点分别在位置4、5、6和7，以此类推。</p><blockquote><p>定义：二叉堆是一组能够用堆有序的完全二叉树的元素，并在数组中按照层级储存。</p></blockquote><p>在一个堆中，节点的位置是固定的。当我们用数组来表示堆时，可以根据节点在数组中的索引，找到其父节点和子节点。例如，如果一个节点的索引是 i，那么其父节点的索引是 (i-1)/2（假设数组的起始索引为 0），其左子节点的索引是 2i+1，右子节点的索引是 2i+2。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_25_heap.png" alt="Heap representations"><p>在不适用指针的情况下我们可以通过数组的索引在树中上下移动：从<code>a[k]</code>向上一层就令$k$等于$k/2$，向下一层则令$k$等于$2k$或$2k+1$。用数组（堆）实现的完全二叉树的结构非常严格，但它的灵活性足以高效地实现优先队列。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_25_heap-representations.png" alt="Heap representations"><p>上浮</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_30_swim.png" alt="Bottom-up heapify (swim)"><p>下沉</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_30_sink.png" alt="Top-down heapify (sink)"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_05_30_heap-ops.png" alt="Heap operations"><h3 id="多叉堆" tabindex="-1"><a class="header-anchor" href="#多叉堆" aria-hidden="true">#</a> 多叉堆</h3><p>对于数组中1至N的N个元素，位置 $k$ 的结点大于等于位于$3k-1$、$3k$和$3k+1$的结点，小于等于位于$\lfloor (k+1)/3 \rfloor$。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_02_heap-pq.png" alt="Heap representations" style="zoom:100%;"><h3 id="索引优先队列" tabindex="-1"><a class="header-anchor" href="#索引优先队列" aria-hidden="true">#</a> 索引优先队列</h3><blockquote><p>索引优先队列是一种数据结构，它允许在插入、删除和修改元素时都能保持队列中元素的优先顺序。它的基本操作通常包括插入、删除最大/最小元素、删除任意元素和更改元素的优先级。</p><p>相比于普通的优先队列，索引优先队列的特性是：</p><ul><li>每个元素都有一个唯一的相关索引，这个索引在整个元素在优先队列中的生命周期中保持不变。</li><li>支持通过索引访问元素，并能够更改元素的优先级。</li><li>支持通过索引删除元素。</li></ul><p><strong>优点：</strong></p><ol><li>由于索引和元素之间的关联，因此可以直接通过索引访问、修改或删除元素，这大大提高了操作效率。</li><li>支持更改元素的优先级，这在许多应用中都是必需的。</li></ol><p><strong>缺点：</strong></p><ol><li>实现相对复杂，需要更多的存储空间来保存索引和优先级。</li><li>如果频繁进行优先级更改或删除操作，可能会导致性能下降。</li></ol><p><strong>应用：</strong></p><ol><li>在计算机科学中，索引优先队列常用于图算法，如Dijkstra的最短路径算法、Prim的最小生成树算法等。</li><li>用于实现任务调度或事件驱动模拟，其中的任务或事件可以有各种优先级，并且优先级可能会在运行期间发生更改。</li><li>在网络和操作系统中，索引优先队列可以用于处理具有不同优先级的请求或任务。</li></ol><p>总的来说，索引优先队列在需要动态改变优先级，或者需要快速找到并删除任意元素的情况下特别有用。</p></blockquote><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h3><p>我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去。</p><blockquote><p>堆排序是一种利用堆数据结构设计的一种排序方法，它可以将一个无序数组变成一个有序数组。堆排序的基本思想分为两个主要的步骤：</p><ol><li><strong>建立堆</strong>：首先，需要将待排序的序列构建成一个大顶堆或小顶堆。如果我们希望得到的是升序序列，就应该构建大顶堆；反之，如果希望得到降序序列，就应该构建小顶堆。构建堆的过程，实质上是不断调整堆的过程。从下往上，从右至左，将每个非叶子节点当作根节点，将其和其子树调整为堆。</li><li><strong>调整堆</strong>：堆顶元素是最大（或最小）的元素。删除堆顶元素后，需要将堆底元素调到堆顶，然后再从根节点开始进行一次从上往下的调整（重建堆），调整过程中，较大（或较小）的子节点会上浮，这样就能保证堆顶元素始终是最大（或最小）元素。重复这个过程，直到堆中只剩下一个元素，排序就完成了。</li></ol><p>堆排序的主要优点是其时间复杂度为O(nlogn)，在速度上较快，且是原地排序，不需要额外的存储空间。但是，由于堆排序不稳定（即相等的元素可能会因为排序而改变原来的相对位置），并且在实际数据的排序速度上不及插入排序和快速排序，因此在某些情况下，可能不是最佳的排序选择。</p></blockquote><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_02_heapsort-trace.png" alt="Trace of heapsort"></p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_05_iShot_2023-06-05_06.46.28.gif" alt="iShot_2023-06-05_06.46.28"></p><p>堆排序的缺点是它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。</p><h2 id="_2-5-应用" tabindex="-1"><a class="header-anchor" href="#_2-5-应用" aria-hidden="true">#</a> 2.5 应用</h2><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_05_sort-characteristics.png" alt="Performance characteristics of sorting algorithms"></p><blockquote><p><strong>稳定性</strong>：稳定排序算法是如果两个对象具有相同的键，那么它们的相对位置在排序后的序列中不会改变。换句话说，稳定排序算法维持了相等元素的相对顺序。</p></blockquote><p>在大多数情况中，快速排序是最佳选择。如果稳定性更重要而空间不是问题，归并排序可能是最好的。</p><h1 id="第3章-查找" tabindex="-1"><a class="header-anchor" href="#第3章-查找" aria-hidden="true">#</a> 第3章 查找</h1><h2 id="_3-1-符号表" tabindex="-1"><a class="header-anchor" href="#_3-1-符号表" aria-hidden="true">#</a> 3.1 符号表</h2><p>符号表最主要的目的就是将一个键和一个值联系起来。</p><blockquote><p>定义：<strong>符号表</strong>是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。</p><p><strong>符号表</strong>也称为符号字典或关联数组，其底层实现可以是数组，也可以是其他数据结构，如链表、哈希表、平衡树（如红黑树）等。选择何种数据结构取决于符号表的具体需求，如查找效率、插入效率、删除效率等。</p><p>符号表通常用于存储和查找键值对。每个键对应一个值，这些键可以是任何可比较的类型，如整数、字符串等，值则可以是任何类型。符号表提供一种机制，可以通过键查找到对应的值。</p><p>有序符号表是符号表的一种，它保持了元素（键或键值对）的有序性。在有序符号表中，键（或键值对）按照某种顺序（通常是键的自然顺序或指定顺序）存储。比如，你可以在有序符号表中进行范围查询（找出位于两个给定键之间的所有键），或找出最大和最小的键。</p><p>符号表和字典在大多数编程语言中是相同的概念，都是用于存储和查找键值对的数据结构。在Python中，这种数据结构就叫做字典（Dictionary）。然而，这两个词并非完全等价，字典通常用于指一种无序的键值对集合，而符号表可能指更广义的概念，包括有序或无序的键值对集合。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_07_IMG_9416.jpg" alt="IMG_9416" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_07_symbol-table-api.png" alt="Symbol-table API"><p>数组是最简单的符号表。</p><h3 id="_3-1-2-有序符号表" tabindex="-1"><a class="header-anchor" href="#_3-1-2-有序符号表" aria-hidden="true">#</a> 3.1.2 有序符号表</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_07_ordered-symbol-table-api.png" alt="Ordered Symbol-table API"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_07_ordered-symbol-table-ops.png" alt="Examples of ordered symbol table operations"><h3 id="_3-1-4-无序链表中的顺序查找" tabindex="-1"><a class="header-anchor" href="#_3-1-4-无序链表中的顺序查找" aria-hidden="true">#</a> 3.1.4 无序链表中的顺序查找</h3><p>使用链表实现符号表，插入和查找的时间复杂度为$O(n)$，非常低效。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_08_IMG_9424.jpg" alt="IMG_9424" style="zoom:33%;"><h3 id="_3-1-5-有序数组中的二分查找" tabindex="-1"><a class="header-anchor" href="#_3-1-5-有序数组中的二分查找" aria-hidden="true">#</a> 3.1.5 有序数组中的二分查找</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_08_IMG_9425.jpg" alt="IMG_9425" style="zoom:25%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_09_IMG_9426.jpg" alt="IMG_9426" style="zoom:25%;"><p>基于有序数组中的二分查找的<strong>符号表</strong>的缺点是<code>put()</code>方法太慢了。二分查找减少了比较次数但无法减少运行所需时间。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_09_IMG_9427.jpg" alt="IMG_9427" style="zoom:33%;"><h2 id="_3-2-二叉查找树" tabindex="-1"><a class="header-anchor" href="#_3-2-二叉查找树" aria-hidden="true">#</a> 3.2 二叉查找树</h2><p>二叉查找树（Binary Search Tree，简称 BST）是一种特殊的二叉树，它满足以下性质：</p><ol><li>节点的值：每个节点都有一个与之相关联的键（通常是数字）和可能的关联数据。</li><li>左子树的键小于节点的键：任意节点（记为 N）的左子树中的所有节点的键都要小于节点 N 的键。</li><li>右子树的键大于节点的键：任意节点（记为 N）的右子树中的所有节点的键都要大于节点 N 的键。</li><li>左子树和右子树也是二叉查找树：节点 N 的左子树和右子树也分别是二叉查找树。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_1686525015850.png" alt="1686525015850" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9435.jpg" alt="IMG_9435" style="zoom:33%;"><p>同一个集合可以用多棵不同的二叉查找树表示。</p><p>在查找中，如果查找的键较小就选择左子树，较大则选择右子树。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9436.jpg" alt="IMG_9436" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9437.jpg" alt="IMG_9437" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9438.jpg" alt="IMG_9438" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9439.jpg" alt="IMG_9439" style="zoom:33%;"><p>最好情况下位$lgN$，最坏情况下为$N$。</p><h3 id="删除结点" tabindex="-1"><a class="header-anchor" href="#删除结点" aria-hidden="true">#</a> 删除结点</h3><ul><li>将指向即将被删除的结点的链接保存为t；</li><li>将x指向它的后继结点min(t.right)；</li><li>将x的右链接指向deleMin(t.right)，也就是在删除后所有节点仍然都大于x.key的子二叉查找树；</li><li>将x的左链接设为t.left。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_12_IMG_9440.jpg" alt="IMG_9440" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_13_IMG_9442.jpg" alt="IMG_9442" style="zoom:33%;"><h2 id="_3-3-平衡查找树" tabindex="-1"><a class="header-anchor" href="#_3-3-平衡查找树" aria-hidden="true">#</a> 3.3 平衡查找树</h2><blockquote><p>平衡查找树（Balanced Search Tree）是一种特殊的二叉查找树，它能在增加或删除节点时保持其高度较低。平衡查找树的设计目的是为了解决普通二叉查找树在最坏情况下可能导致时间复杂度退化为 $O(n)$ 的问题。</p><p>平衡查找树的关键特点是任何节点的两个子树的高度差的绝对值不超过一定的限制。这种限制确保了树的高度始终为对数级别，从而使得插入、删除和查找操作的时间复杂度为 $O(log n)$。</p><p>常见的平衡查找树包括：</p><ol><li><strong>AVL树</strong>：AVL树是一种自平衡二叉查找树，要求任何节点的两个子树的高度差的绝对值不超过1。这种限制是较为严格的，因此AVL树的平衡程度较高。</li><li><strong>红黑树</strong>：红黑树是一种自平衡二叉查找树，通过给节点标记颜色并在插入或删除节点时进行调整以保持平衡。红黑树的平衡性不如AVL树严格，但在某些情况下，它的插入和删除操作可能更快。</li><li><strong>B树</strong>：B树是一种自平衡的m叉查找树，通常用于数据库和文件系统。B树的节点可以有多个子节点，并且可以存储多个键。</li><li><strong>Treap</strong>：Treap是一种结合了二叉查找树和堆的数据结构，也被称为树堆。通过随机化和旋转操作，Treap能在平均情况下保持较好的平衡。</li><li><strong>Splay树</strong>：Splay树是一种自调整的二叉查找树，通过一系列旋转操作，把最近访问过的元素移到树的根部，从而试图减小常用元素的访问时间。</li></ol><p>平衡查找树在很多计算机科学和工程领域有广泛应用，如数据库索引、内存管理、数据压缩等。由于它们可以保证操作的高效性，所以在需要维护动态数据集并频繁执行查找、插入和删除操作的场景中具有很大的价值。</p></blockquote><h3 id="_2-3查找树" tabindex="-1"><a class="header-anchor" href="#_2-3查找树" aria-hidden="true">#</a> 2-3查找树</h3><blockquote><p><strong>2-3查找树</strong>是一种自平衡的查找树数据结构，其中的每个节点可以存储一或两个的键以及相应的值，并且可以有两个或三个子节点。这是一个扩展自二叉查找树的概念，使树保持更好的平衡，从而获得更有效的查找性能。</p><p>一颗2-3查找树或为一棵空树，或由以下结点组成：</p><ul><li><strong>2-节点</strong>：包含一个键和两个子节点。这个节点的左子树包含的所有键都小于节点的键，右子树包含的所有键都大于节点的键。</li><li><strong>3-节点</strong>：包含两个键和三个子节点。左子节点包含的所有键都小于较小的键，中间子节点包含的所有键都在两个键的中间，右子节点包含的所有键都大于较大的键。</li></ul><p>2-3查找树的基本操作包括插入、删除和查找：</p><ol><li><strong>插入</strong>：当插入一个新的键时，首先按照二叉查找树的方式找到合适的叶子节点位置。然后，根据叶子节点的类型执行不同的操作。如果是2-节点，直接将其转换为3-节点。如果是3-节点，需要进行一系列的分裂和合并操作来保持树的平衡。</li><li><strong>删除</strong>：删除一个键较为复杂。首先需要找到要删除的键，然后根据情况可能需要从兄弟节点借一个键或者通过合并操作来保持树的平衡。</li><li><strong>查找</strong>：查找操作与常规的二叉查找树类似，但在遇到3-节点时需要比较两个键。</li></ol><p>2-3查找树的优点是它能够自动保持良好的平衡，无论插入和删除的顺序如何。这使得在2-3查找树上的操作具有对数时间复杂度，这对于大型数据集来说是非常高效的。</p><p>2-3查找树是B树的一种特例，是为了理解更复杂的B树和B+树提供基础的一种数据结构。</p><p>2-3树的缺点：</p><ul><li><strong>复杂性</strong>：与普通的二叉查找树相比，2-3树的插入和删除操作更为复杂。需要处理更多的情况，比如节点分裂、合并，以及在兄弟节点间转移键等。</li><li><strong>空间浪费</strong>：在2-3树中，有些节点可能只存储一个键（2-节点）。这意味着这些节点的存储空间没有被充分利用，特别是当键和指针的大小相对较大时，这种空间浪费可能变得更加明显。</li><li><strong>不适合大范围查询</strong>：2-3树不像B+树那样，其叶子节点之间没有链接，因此不适合用于大范围的数据查询。例如，在数据库系统中，B+树通常比2-3树更受欢迎，因为B+树可以更高效地支持范围查询。</li><li><strong>不是最优的平衡查找树</strong>：虽然2-3树保持了较好的平衡性，但在某些情况下，其他平衡查找树（如红黑树、AVL树）的性能可能更好。</li><li><strong>代码实现较复杂</strong>：由于2-3树的节点可以有不同的键的数量，并且插入和删除操作需要处理多种不同的情况，因此代码的实现相对较复杂。</li><li><strong>在连续插入和删除时，可能需要多次调整</strong>：虽然2-3树可以保持良好的平衡，但是在连续的插入或删除操作中可能需要频繁的调整，这在某些情况下可能是低效的。</li></ul></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_1686697779375.png" alt="1686697779375" style="zoom:50%;"><p><strong>查找</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9443.jpg" alt="IMG_9443" style="zoom:33%;"><p><strong>向2-结点中插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9444.jpg" alt="IMG_9444" style="zoom:33%;"><p><strong>向一颗只含有一个3-结点的树中插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9445.jpg" alt="IMG_9445" style="zoom:33%;"><p><strong>向一个父结点为2-结点的3-结点插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9446.jpg" alt="IMG_9446" style="zoom:33%;"><p><strong>向一个父结点为3-结点的3-结点中插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9447.jpg" alt="IMG_9447" style="zoom:33%;"><p><strong>分解根结点</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9448.jpg" alt="IMG_9448" style="zoom:45%;"><p><strong>局部变换</strong></p><p>将一个4-结点分解为一颗2-3树可能有6种情况。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9449.jpg" alt="IMG_9449" style="zoom:33%;"><p><strong>全局性质</strong></p><p>当根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1.</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9450.jpg" alt="IMG_9450" style="zoom:33%;"><p>和标准的二叉树由上向下生长不同，2-3树的生长是由下向上的。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_14_IMG_9451.jpg" alt="IMG_9451" style="zoom:33%;"><h3 id="红黑二叉查找树" tabindex="-1"><a class="header-anchor" href="#红黑二叉查找树" aria-hidden="true">#</a> 红黑二叉查找树</h3><blockquote><p><strong>红黑二叉查找树</strong>（Red-Black Binary Search Tree）是一种自平衡的二叉查找树。在这种数据结构中，每个节点都有一个颜色属性，可以是红色或黑色。通过对节点着色和对树进行少量的额外操作，红黑树能够在插入和删除操作中保持大致平衡，从而保证查找操作的高效性。</p><p>红黑树遵循以下五个性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>树的根节点是黑色的。</li><li>每个叶子节点（通常是NIL或空节点）是黑色的。</li><li>如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，不能有两个连续的红色节点）。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，黑色节点的数量相同（称为黑高）。</li></ol><p>这些性质强制性地限制了树的结构，从而使得在树的最长路径上的节点数不会超过最短路径上的节点数的两倍。这保证了树的高度大致对数级，从而使得插入、删除和查找操作具有 O(log n) 的时间复杂度。</p><p>常见操作：</p><ol><li><strong>插入</strong>：在红黑树中插入节点与在普通的二叉查找树中类似，首先找到合适的位置然后插入节点。通常新插入的节点被标记为红色，然后通过一系列的旋转和重新着色操作来维护红黑树的性质。</li><li><strong>删除</strong>：删除操作比插入操作更复杂。删除节点后，需要通过旋转和重新着色来重新平衡树。</li><li><strong>查找</strong>：查找操作与普通的二叉查找树一样，不需要进行任何特殊的处理。</li></ol><p>红黑树在实际应用中非常广泛，例如，在许多编程语言的库和容器（如C++的 std::map, Java的 TreeMap）以及数据库和文件系统中都使用了红黑树。红黑树的一个优点是它在插入和删除时的最坏情况性能仍然非常良好，而且实现相对于其他高度平衡的树（如AVL树）来说更简单。</p></blockquote><h4 id="插入操作" tabindex="-1"><a class="header-anchor" href="#插入操作" aria-hidden="true">#</a> 插入操作</h4><p>红黑二叉查找树背后的基本思想是<strong>用标准的二叉查找树（完全由2-节点构成）和一些额外的信息（替换3-结点）来表示2-3树。</strong></p><p>树中的链接分为两种类型：红链接将两个2-结点链接起来构成一个3-结点，黑链接则是2-3树中的普通链接。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9453.jpg" alt="IMG_9453" style="zoom:33%;"><p>红黑树的的另一种定义是含有红黑链接并满足下列条件的<strong>二叉查找树</strong>：</p><ol><li>红链接均为左链接。</li><li>没有任何一个节点同时和两条红链接相连。</li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9454.jpg" alt="IMG_9454" style="zoom:33%;"><p>如果我们将红链接的节点合并，得到的就是一颗2-3树。</p><p>一个结点的颜色，指的是指向该结点的链接的颜色。红黑树既是二叉查找树，也是2-3树。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9455.jpg" alt="IMG_9455" style="zoom:33%;"><p><strong>颜色表示：</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9456.jpg" alt="IMG_9456" style="zoom:33%;"><p><strong>旋转：</strong></p><p>在实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。旋转分为<strong>左旋转</strong>和<strong>右旋转</strong>。</p><p>左旋转只是将用两个键中的较小者作为根结点变为将较大者作为根结点。右旋转同理。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9457.jpg" alt="IMG_9457" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_15_IMG_9458.jpg" alt="IMG_9458" style="zoom:33%;"><p><strong>在旋转后重置父结点的链接：</strong></p><p><code>h = rotateLeft(h)</code>，将旋转节点 h 的红色右链接，使得 h 指向了旋转后的子树的根结点。</p><p>在插入新的键时我们可以使用<strong>旋转</strong>操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要特性：有序性和完美平衡性。</p><p><strong>向单个2-结点中插入新键：</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_16_IMG_9459.jpg" alt="IMG_9459" style="zoom:33%;"><p><strong>向树底部的2-结点插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_16_IMG_9460.jpg" alt="IMG_9460" style="zoom:33%;"><p><strong>向一颗双键树（即一个3-结点）中插入新键</strong></p><p>分为三种情况</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9461.jpg" alt="IMG_9461" style="zoom:33%;"><p><strong>颜色转换</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9466.jpg" alt="IMG_9466" style="zoom:33%;"><p><strong>根结点总是为黑色</strong></p><p>在每次插入后都将根结点设为黑色。每当根结点由红变黑时树的黑链接高度就会加1。</p><p><strong>向树底部的3-结点插入新键</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9467.jpg" alt="IMG_9467" style="zoom:33%;"><p><strong>将红链接在树中向上传递</strong></p><p>要在一个3-结点下插入新键，先创建一个临时的4-结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直到遇到一个2-节点或者根结点。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9468.jpg" alt="IMG_9468" style="zoom:33%;"><p>总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，我们就能够保证插入操作后红黑树和2-3树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p><ul><li>如果右子节点是红色的而左子结点是黑色的，进行做旋转；</li><li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；</li><li>如果左右子节点均为红色，进行颜色转换。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9469.jpg" alt="IMG_9469" style="zoom:33%;"><h3 id="删除操作" tabindex="-1"><a class="header-anchor" href="#删除操作" aria-hidden="true">#</a> 删除操作</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9470.jpg" alt="IMG_9470" style="zoom:33%;"><h3 id="红黑树的性质" tabindex="-1"><a class="header-anchor" href="#红黑树的性质" aria-hidden="true">#</a> 红黑树的性质</h3><p>所有基于红黑树的符号表实现都能保证操作的时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比）。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9471.jpg" alt="IMG_9471" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9472.jpg" alt="IMG_9472" style="zoom:33%;"><p>红黑树因为是平衡的，所以查找比二叉查找树更快。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_19_IMG_9473.jpg" alt="IMG_9473" style="zoom:33%;"><p>升序插入</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_20_iShot_2023-06-20_07.32.22.gif" alt="iShot_2023-06-20_07.32.22" style="zoom:50%;"><h2 id="_3-4-散列表" tabindex="-1"><a class="header-anchor" href="#_3-4-散列表" aria-hidden="true">#</a> 3.4 散列表</h2><p>散列表是算法在时间和空间上作出权衡的经典例子。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_20_IMG_9477.jpg" alt="IMG_9477" style="zoom:33%;"><h3 id="散列函数" tabindex="-1"><a class="header-anchor" href="#散列函数" aria-hidden="true">#</a> 散列函数</h3><p>散列函数的作用就是<strong>将键转化为数组的索引</strong>。</p><p>如果我们有一个能够保存M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]范围内的整数）的散列函数。</p><p>散列函数方法：</p><ol><li><p><strong>除留余数法</strong>：</p><ul><li><strong>实现思路</strong>：取键值对一个不大于哈希表表长的素数p，用键值除以该素数，然后取余数作为哈希地址。</li><li><strong>优点</strong>：简单，适用于键值是整数的情况。</li><li><strong>缺点</strong>：需要选择一个合适的素数以减少冲突。</li></ul></li><li><p><strong>乘法散列法</strong>：</p><ul><li><strong>实现思路</strong>：将键值乘以一个0到1之间的常数A（0 &lt; A &lt; 1），然后取结果的小数部分，再乘以哈希表的大小M，并取整作为哈希地址。</li><li><strong>优点</strong>：不太依赖选择的常数A，适合处理实数键。</li><li><strong>缺点</strong>：计算量相对较大。</li></ul></li><li><p><strong>平方取中法</strong>：</p><ul><li><strong>实现思路</strong>：将键值平方，然后取结果的中间几位作为哈希地址。</li><li><strong>优点</strong>：当键值的分布不均匀时，平方值的中间几位往往分布较均匀。</li><li><strong>缺点</strong>：对键值的选择敏感，不同的键值集合可能有不同的效果。</li></ul></li><li><p><strong>折叠法</strong>：</p><ul><li><strong>实现思路</strong>：将键值分成几个部分，然后将这些部分叠加或异或在一起，作为哈希地址。</li><li><strong>优点</strong>：简单，对键值分布不敏感。</li><li><strong>缺点</strong>：可能会产生较多的冲突。</li></ul></li><li><p><strong>数字分析法</strong>：</p><ul><li><strong>实现思路</strong>：选择键值中分布均匀的数字作为哈希地址。</li><li><strong>优点</strong>：当键值的某些数字分布较为均匀时，效果较好。</li><li><strong>缺点</strong>：需要对键值的分布有一定了解。</li></ul></li><li><p><strong>字符串转换法</strong>（对于字符串键）：</p><ul><li><strong>实现思路</strong>：将字符串的字符转换为整数，然后使用另一种散列函数，如除留余数法。</li><li><strong>优点</strong>：可以处理字符串键。</li><li><strong>缺点</strong>：通常计算量较大。</li></ul></li><li><p><strong>哈希函数的组合</strong>：</p><ul><li><strong>实现思路</strong>：结合多种哈希函数，如将两个哈希函数的结果加在一起。</li><li><strong>优点</strong>：可以减少冲突，提高散列的均匀性。</li><li><strong>缺点</strong>：计算量较大，实现较复杂。</li></ul></li></ol><p>一个优秀的散列方法需要满足三个条件：</p><ul><li>一致性——等价的键必然产生相等的散列值；</li><li>高效性——计算简便；</li><li>均匀性——均匀地散列所有的键。</li></ul><h3 id="碰撞处理" tabindex="-1"><a class="header-anchor" href="#碰撞处理" aria-hidden="true">#</a> 碰撞处理</h3><ol><li><p><strong>开放寻址法</strong>：</p><ul><li><strong>实现思路</strong>：当发生冲突时，根据某种探测序列在哈希表中寻找下一个空的位置。</li><li><strong>优点</strong>：不需要额外的存储空间来存储冲突的元素。</li><li><strong>缺点</strong>：随着哈希表填充度增加，冲突的可能性变大，性能下降。</li></ul></li><li><p><strong>链地址法</strong>：</p><ul><li><strong>实现思路</strong>：哈希表的每个位置都存储一个链表或其他数据结构，以存储映射到该位置的所有元素。</li><li><strong>优点</strong>：处理冲突灵活，对哈希函数的选择不是特别敏感。</li><li><strong>缺点</strong>：增加了额外的存储开销，链表过长会影响查找效率。</li></ul></li><li><p><strong>双散列</strong>：</p><ul><li><strong>实现思路</strong>：使用两个独立的哈希函数。当第一个哈希函数导致冲突时，使用第二个哈希函数。</li><li><strong>优点</strong>：通常能有效减少冲突。</li><li><strong>缺点</strong>：增加了计算复杂性。</li></ul></li><li><p><strong>再哈希法</strong>：</p><ul><li><strong>实现思路</strong>：使用多个哈希函数。当一个哈希函数导致冲突时，尝试下一个哈希函数。</li><li><strong>优点</strong>：冲突的概率相对较低。</li><li><strong>缺点</strong>：增加了计算复杂性。</li></ul></li></ol><p>在设计哈希表时，选择适当的哈希函数和解决冲突的方法是非常重要的。这需要根据具体的应用场景和性能需求来进行权衡。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_21_IMG_9480.jpg" alt="IMG_9480" style="zoom:33%;"><p>散列最主要的目的是在于均匀地将键散步开来，因此在计算散列后键的顺序信息就丢失了。如果需要快速找到最大或最小的键，或是查找某个范围内的键，散列表都不是合适的选择，因为这些操作的运行时间都将会是线性的。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_21_IMG_9482.jpg" alt="IMG_9482" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_21_IMG_9483.jpg" alt="IMG_9483" style="zoom:33%;"><h2 id="_3-5-应用" tabindex="-1"><a class="header-anchor" href="#_3-5-应用" aria-hidden="true">#</a> 3.5 应用</h2><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_25_IMG_9502.jpg" alt="IMG_9502" style="zoom:33%;"><h3 id="集合api" tabindex="-1"><a class="header-anchor" href="#集合api" aria-hidden="true">#</a> 集合API</h3><p>某些符号表的用例不需要处理值，它们只需要能够将键插入表中并检测一个键在表中是否存在。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_25_IMG_9503.jpg" alt="IMG_9503" style="zoom:25%;"><h3 id="字典类用例" tabindex="-1"><a class="header-anchor" href="#字典类用例" aria-hidden="true">#</a> 字典类用例</h3><p>许多应用程序都将符号表看做一个可以方便地查询并更新其中信息的动态字典。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_26_IMG_9504.jpg" alt="IMG_9504" style="zoom:33%;"><h3 id="索引类用例" tabindex="-1"><a class="header-anchor" href="#索引类用例" aria-hidden="true">#</a> 索引类用例</h3><p>索引是一个键对应多个值的符号表。将每个键关联的所有值都放入一个数据结构中（比如一个Queue）并用它作为值就可以轻松构造一个索引。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_26_IMG_9505.jpg" alt="IMG_9505" style="zoom:33%;"><h4 id="反向索引" tabindex="-1"><a class="header-anchor" href="#反向索引" aria-hidden="true">#</a> 反向索引</h4><p>反向索引一般指用值来查找键的操作。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_26_IMG_9506.jpg" alt="IMG_9506" style="zoom:33%;"><h3 id="稀疏向量" tabindex="-1"><a class="header-anchor" href="#稀疏向量" aria-hidden="true">#</a> 稀疏向量</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_27_IMG_9507.jpg" alt="IMG_9507" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_27_IMG_9508.jpg" alt="IMG_9508" style="zoom:33%;"><h1 id="第4章-图" tabindex="-1"><a class="header-anchor" href="#第4章-图" aria-hidden="true">#</a> 第4章 图</h1><p>图论是数学的一个分支，研究图的性质和应用。在图论中，图通常是由顶点（节点）和边（连接节点的线段）组成的。图论的应用非常广泛，涵盖了许多领域，以下是一些示例：</p><ol><li><p><strong>计算机网络</strong>：图论在网络的设计、路由和拥塞控制中发挥着至关重要的作用。例如，互联网可以看作是一个庞大的图，其中站点是顶点，而连接是边。</p></li><li><p><strong>社交网络</strong>：社交网络如Facebook, Twitter等可以被模拟成图，其中人们是顶点，他们之间的友谊或关系是边。图论可以用于分析社交网络的结构，如查找社区、影响分析等。</p></li><li><p><strong>交通运输</strong>：图论被用来模拟和优化交通网络，如公路、铁路和航空网络。Dijkstra算法和A*算法是两个常用的图论算法，用于寻找最短路径。</p></li><li><p><strong>供应链和物流</strong>：图论在供应链管理和物流中的应用包括路径规划、仓库位置选择、运输优化等。</p></li><li><p><strong>生物信息学</strong>：在基因组学和蛋白质组学中，生物分子之间的相互作用可以用图来表示。图论算法可用于研究这些结构和相互作用。</p></li><li><p><strong>电力网络</strong>：电力系统的网络可以通过图论来建模，用于分析电力流和优化电网的可靠性。</p></li><li><p><strong>推荐系统</strong>：图论被用于构建推荐系统，如通过用户和项目的关联来生成个性化的推荐。</p></li><li><p><strong>化学</strong>：化学结构，尤其是分子结构，可以用图来表示。图同构算法可以用于判断两个化合物是否具有相同的化学结构。</p></li><li><p><strong>项目管理</strong>：在项目管理中，PERT图和甘特图使用图论来帮助计划和调度任务。</p></li><li><p><strong>游戏</strong>：在电子游戏和棋类游戏中，图论可以用于AI决策制定、路径查找和游戏策略分析。</p></li><li><p><strong>地理信息系统</strong>：在GIS中，图论被用于空间分析，比如寻找最近的店铺或优化送货路线。</p></li></ol><p>这只是图论的一些应用示例，它的应用是非常广泛的，不断涌现的新技术和研究领域也在继续推动图论的应用。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_27_IMG_9509.jpg" alt="IMG_9509" style="zoom:33%;"><h2 id="_4-1-无向图" tabindex="-1"><a class="header-anchor" href="#_4-1-无向图" aria-hidden="true">#</a> 4.1 无向图</h2><blockquote><p>定义：图是由一组顶点和一组能够将两个顶点相连的边组成。</p></blockquote><p>一般使用 $0$ 至 $V-1$ 来表示一张含有 $V$ 个顶点的图中的各个顶点。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_27_IMG_9510.jpg" alt="IMG_9510" style="zoom:33%;"><p>特殊的图：</p><ul><li>自环，即一条连接一个顶点和其自身的边；</li><li>连接同一对顶点的两条边称为平行边。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_27_IMG_9511.jpg" alt="IMG_9511" style="zoom:33%;"><p>含有平行边的图称为<strong>多重图</strong>，没有平行边或自环的图称为<strong>简单图</strong>。</p><h3 id="术语概述" tabindex="-1"><a class="header-anchor" href="#术语概述" aria-hidden="true">#</a> 术语概述</h3><ul><li><strong>子图</strong> - 由原图的一些顶点和一些边组成的图。</li><li><strong>度</strong> - 与一个顶点相关联的边的数量。在有向图中，度分为入度和出度。</li><li><strong>路径</strong> - 顶点的序列，其中每个顶点通过边与下一个顶点相连，由边顺序连接的一系列顶点。</li><li><strong>简单路径</strong> - 一条没有重复顶点的路径。</li><li><strong>环</strong> - 一条路径，其中起点和终点是相同的。</li><li><strong>简单环</strong> - （除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或环的长度为其中所包的边数。</li><li><strong>连通图</strong> - 从任意一个顶点都存在一个路径到达另一个顶点的图。</li><li><strong>无环图</strong> - 不包含环的图。</li><li><strong>树</strong> - 一幅无环连通图。</li><li><strong>森林</strong> - 互不相连的树组成的集合。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9512.jpg" alt="IMG_9512" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9513.jpg" alt="IMG_9513" style="zoom:33%;"><p>当且仅当一幅含有 $V$ 个结点的图 $G$ 满足下列5个条件之一时，它就是一棵树：</p><ul><li><p>G 有 V-1 条边且不含有环；</p></li><li><p>G 有 V-1 条边且是连通的；</p></li><li><p>G 是连通的，但删除任意一条边都会使它不再连通；</p></li><li><p>G 是无环图，但添加任意一条边都会产生一条环；</p></li><li><p>G 中的任意一对顶点之间仅存在一条简单路径。</p></li><li><p><strong>密度</strong> - 已经连接的顶点对占所有可能被连接的顶点对的比例。</p></li><li><p><strong>稀疏图</strong> - 被连接的顶点对很少。</p></li><li><p><strong>稠密图</strong> - 只有少部分顶点没有边连接。</p></li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9514.jpg" alt="IMG_9514" style="zoom:33%;"><ul><li><strong>二分图</strong> - 能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9515.jpg" alt="IMG_9515" style="zoom:33%;"><h3 id="无向图的数据类型" tabindex="-1"><a class="header-anchor" href="#无向图的数据类型" aria-hidden="true">#</a> 无向图的数据类型</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9516.jpg" alt="IMG_9516" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9517.jpg" alt="IMG_9517" style="zoom:50%;"><p>图的数据结构实现包含以下两个要求：</p><ul><li>它必须为可能在应用中碰到的各种类型的图预留出足够的空间；</li><li>Graph的实例方法的实现一定要快——它们是开发处理图的各种用例的基础。</li></ul><p>三种图的数据结构表示方法：</p><ul><li><em>邻接矩阵</em>。使用一个 V × V 的布尔矩阵。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素值为true，否则为false。这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的，$V^2$个布尔值所需的空间不满足。</li><li><em>边的数组</em>。我们可以使用一个Edge类，它含有两个int实例变量。这种表示方法很简洁但不满足第二个条件。</li><li><strong>邻接表数组</strong>。使用一个顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。这种数据结构能够同时满足上述两个条件。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9518.jpg" alt="IMG_9518" style="zoom:33%;"><p>邻接表的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。在这种数据结构中，每条边都会出现两次。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9519.jpg" alt="IMG_9519" style="zoom:33%;"><p>这种Graph的实现的性能有如下特点：</p><ul><li>使用的空间和 V+E 成正比；</li><li>添加一条边所需的时间为常数；</li><li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_28_IMG_9520.jpg" alt="IMG_9520" style="zoom:33%;"><h3 id="深度优先搜索-dfs" tabindex="-1"><a class="header-anchor" href="#深度优先搜索-dfs" aria-hidden="true">#</a> 深度优先搜索（DFS）</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_29_IMG_9522.jpg" alt="IMG_9522" style="zoom:33%;"><blockquote><p>用一个递归方法来遍历所有顶点，在访问其中一个顶点时：</p><ul><li>将它标记为已访问；</li><li>递归地访问它的所有没有被标记过的邻居顶点。</li></ul><p>这种方法称为<strong>深度优先搜索（DFS）</strong></p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9524.jpg" alt="IMG_9524" style="zoom:33%;"><h3 id="寻找路径" tabindex="-1"><a class="header-anchor" href="#寻找路径" aria-hidden="true">#</a> 寻找路径</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9525.jpg" alt="IMG_9525" style="zoom:33%;"><h3 id="广度优先搜索-bfs" tabindex="-1"><a class="header-anchor" href="#广度优先搜索-bfs" aria-hidden="true">#</a> 广度优先搜索（BFS）</h3><p>可以解决例如单点最短路径问题。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9526.jpg" alt="IMG_9526" style="zoom:33%;"><blockquote><p>使用一个队列来保存所有已经被标记过但其邻接表还未被检查的顶点。先将起点加入队列，然后重复以下步骤直到队列为空：</p><ul><li>取队列中的下一个顶点v并标记它；</li><li>将与v相邻的所有未被标记过的顶点加入队列。</li></ul></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9527.jpg" alt="IMG_9527" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9528.jpg" alt="IMG_9528" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_06_30_IMG_9529.jpg" alt="IMG_9529" style="zoom:33%;"><p>深度优先搜索一幅图的方式是寻找离起点更远的顶点，只在碰到死胡同时才访问近处的顶点；广度优先搜索则会首先覆盖起点附近的顶点，只在临近的所有顶点都被访问之后才向前进。</p><p>DFS的路径通常较长且曲折；BFS的路径则短而直接。</p><h3 id="连通分量" tabindex="-1"><a class="header-anchor" href="#连通分量" aria-hidden="true">#</a> 连通分量</h3><blockquote><p>在图论中，连通分量（Connected Component）是一个重要的概念。一个无向图的连通分量是一个子图，这个子图满足两个条件：一是子图内的任意两个顶点都是连通的（即在子图中存在从一个顶点到另一个顶点的路径）；二是子图是最大的，意思是说如果再加入这个子图以外的任何一个顶点，那么它就不再满足条件一。</p></blockquote><p>在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合类似的任务时，更倾向于union-find算法，而深度优先搜索则更适用实现图的抽象数据结构，因为它能更有效地利用已有的数据结构。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_03_IMG_9538.jpg" alt="IMG_9538" style="zoom:33%;"><h3 id="符号图" tabindex="-1"><a class="header-anchor" href="#符号图" aria-hidden="true">#</a> 符号图</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_03_IMG_9539.jpg" alt="IMG_9539" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_04_IMG_9542.jpg" alt="IMG_9542" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_03_IMG_9540.jpg" alt="IMG_9540" style="zoom:33%;"><p>符号图用到3种数据结构：</p><ul><li>一个符号表st，键的类型为String（顶点名），值的类型为int（索引）；</li><li>一个数组keys[]，用作反向索引，保存每个顶点索引所对应的顶点名；</li><li>一个Graph对象G，它使用索引来引用图中顶点。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_04_IMG_9541.jpg" alt="IMG_9541" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_04_IMG_9543.jpg" alt="IMG_9543" style="zoom:33%;"><h2 id="_4-2-有向图" tabindex="-1"><a class="header-anchor" href="#_4-2-有向图" aria-hidden="true">#</a> 4.2 有向图</h2><p>在有向图中，边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_05_IMG_9545.jpg" alt="IMG_9545" style="zoom:33%;"><blockquote><p>定义：一幅有方向性的图（或有向图）是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点。</p></blockquote><p>在一幅有向图中，一个顶点的出度为由该顶点指出的边的总数；一个顶点的入度为指向该顶点的边的总数。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_05_IMG_9546.jpg" alt="IMG_9546" style="zoom:33%;"><h3 id="有向图的数据类型" tabindex="-1"><a class="header-anchor" href="#有向图的数据类型" aria-hidden="true">#</a> 有向图的数据类型</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_05_IMG_9547.jpg" alt="IMG_9547" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9549.jpg" alt="IMG_9549" style="zoom:33%;"><h3 id="有向图的可达性" tabindex="-1"><a class="header-anchor" href="#有向图的可达性" aria-hidden="true">#</a> 有向图的可达性</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9550.jpg" alt="IMG_9550" style="zoom:33%;"><p>应用：</p><ul><li>标记-清除的垃圾收集 <ul><li>在一幅有向图中，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。标记-清除的垃圾回收策略会周期性运行DFS的有向图可达性算法来标记所有可以被访问到的对象，然后清理所有对象，回收没有被标记的对象，以腾出内存供新的对象使用。</li></ul></li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9551.jpg" alt="IMG_9551" style="zoom:33%;"><h3 id="环和有向无环图" tabindex="-1"><a class="header-anchor" href="#环和有向无环图" aria-hidden="true">#</a> 环和有向无环图</h3><blockquote><p><strong>拓扑排序</strong>是一个在<strong>有向无环图</strong>（Directed Acyclic Graph，简称DAG）上的排序算法。在拓扑排序中，节点代表任务，而边代表任务之间的依赖关系。拓扑排序的一个重要性质是，对于图中的任意一条边（u, v），节点u在拓扑排序中都出现在节点v的前面。换句话说，如果任务B依赖于任务A的完成，那么在拓扑排序中，任务A一定排在任务B的前面。</p><p>拓扑排序不仅仅是一个线性顺序，它可能有多个合法的拓扑排序序列，但它必须满足前面提到的依赖关系条件。</p><p>常见的拓扑排序算法有Kahn算法和深度优先搜索算法。</p><p>拓扑排序的应用非常广泛，包括但不限于：</p><ol><li><strong>任务调度</strong>：当你有一系列任务，其中一些任务依赖于其他任务完成时，拓扑排序可以帮助你找出完成这些任务的顺序。</li><li><strong>课程安排</strong>：例如，学生需要完成课程A才能学习课程B，而课程B是课程C的先决条件。在这种情况下，拓扑排序可以帮助确定应该以何种顺序完成课程。</li><li><strong>构建系统</strong>：在软件工程中，当构建一个项目时，必须先构建其依赖项。拓扑排序可以帮助确定依赖项的构建顺序。</li><li><strong>解决约束满足问题</strong>：在某些情况下，问题可以表示为一个有向无环图，其中节点代表变量，边代表约束。通过拓扑排序，可以找到一种满足所有约束的变量赋值顺序。</li><li><strong>数据序列化</strong>：当数据对象之间存在依赖关系时，例如在对象关系映射或网络通信中，拓扑排序可以用于确定正确的序列化和反序列化顺序。</li></ol></blockquote><div style="text-align:center;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9552.jpg" alt="IMG_9552" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9553.jpg" alt="IMG_9553" style="zoom:33%;"></div><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9554.jpg" alt="IMG_9554" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_10_123y7bp0670frn3v9cuj.gif" alt="Graph Algorithm - Topological Sorting - DEV Community" style="zoom:80%;"><p>在处理这种拓扑排序时，该有向图不能是有环的，必须是一个有向无环图（DAG，Directed Acyclic Graph）。</p><p>可以使用DFS来判断一幅有向图是不是DAG。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_06_IMG_9555.jpg" alt="IMG_9555" style="zoom:33%;"><p>有向图中基于深度优先搜索的顶点排序，它的基本思想是深度优先搜索正好只会访问每个顶点一次。如果将dfs()的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。有3种顶点排序方式：</p><ul><li>前序：在递归调用之前将顶点加入队列。</li><li>后序：在递归调用之后将顶点加入队列。</li><li>逆后序：在递归调用之后将顶点压入栈。（一幅有向无环图的拓扑排序即为所有顶点的逆后序排序）</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9561.jpg" alt="IMG_9561" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9562.jpg" alt="IMG_9562" style="zoom:33%;"><p>在实际应用中，拓扑排序和有向环的检测总会一起出现。</p><h3 id="有向图中的强连通性" tabindex="-1"><a class="header-anchor" href="#有向图中的强连通性" aria-hidden="true">#</a> 有向图中的强连通性</h3><blockquote><p>定义：如果两个顶点v和w是互相可达的，则称它们为<strong>强联通</strong>的。也就是说，既存在一条从v到w的有向路径，也存在一条从w到v的有向路径。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9563.jpg" alt="IMG_9563" style="zoom:33%;"><p>强连通性将所有顶点分为了一些等价类，每个等价类都是又相互均为强连通的顶点的最大子集组成，这些子集称为<strong>强连通分量</strong>。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9564.jpg" alt="IMG_9564" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9565.jpg" alt="IMG_9565" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_07_IMG_9566.jpg" alt="IMG_9566" style="zoom:33%;"><h4 id="kosaraju算法" tabindex="-1"><a class="header-anchor" href="#kosaraju算法" aria-hidden="true">#</a> Kosaraju算法</h4><p>Kosaraju算法能实现非平方级别的时间复杂度 $O(V+E)$。它的思路如下：</p><ol><li><strong>第一遍深度优先搜索</strong>：从任意一个顶点开始，对原始图进行深度优先搜索。维护一个栈，每当完成一个顶点的搜索，就把这个顶点压入栈中。这个栈基本上是按照顶点的完成时间来排序的，返回逆后序节点。</li><li><strong>转置图</strong>：得到原图的转置，即将原图中的所有边的方向反转。</li><li><strong>第二遍深度优先搜索</strong>：当栈非空时，弹出一个顶点。从这个顶点开始，对转置图进行深度优先搜索。搜索过程中遍历到的所有顶点都属于同一个强连通分量。标记这些顶点，以便在后续的搜索中不再访问它们。</li><li><strong>重复步骤</strong>：重复第三步，直到栈为空。每一次的深度优先搜索都会找到一个强连通分量。</li></ol><p>Kosaraju算法的精妙之处在于它利用了图的转置以及深度优先搜索的性质。第一遍深度优先搜索确定了一个顶点的处理顺序，而第二遍深度优先搜索则按照这个顺序来找到强连通分量。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_10_0093-scc-kosaraju.gif" alt="算法- 强连通分量Kosaraju 算法| Earth Guardian"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_10_IMG_9581.jpg" alt="IMG_9581" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_10_IMG_9582.jpg" alt="IMG_9582" style="zoom:33%;"><h2 id="_4-3-最小生成树" tabindex="-1"><a class="header-anchor" href="#_4-3-最小生成树" aria-hidden="true">#</a> 4.3 最小生成树</h2><blockquote><p>加权图是一种为每条边关联一个权值或是成本的图模型。</p><p>在一个连通图（Connect Graph）中，一个<strong>生成树</strong>指的是一个子图，<strong>它包含了原图的所有节点</strong>，并且所有的节点都是通过边相连的。也就是说，<strong>生成树</strong>是原图的一个极小连通子图（无环）。</p><p>而<strong>最小生成树（MST）<strong>指的是，给定一幅加权</strong>无向图</strong>，找到它的一颗最小生成树。所有可能的生成树中，所有边的权值和最小的那一个。在计算最小生成树的过程中，经常使用到两个算法，Prim算法和Kruskal算法。</p><p><strong>Prim算法</strong>是从一个节点开始，逐步添加新的边来形成最小生成树。每次添加的都是权值最小的边，且这个边连接的两个节点至少有一个节点已经在生成树中。</p><p><strong>Kruskal算法</strong>则是从所有的边开始，每次添加的都是所有剩余的边中权值最小的，且这个边连接的两个节点不能都已经在生成树中，否则会形成环。</p><p>这两个算法都是贪心算法，通过每一步都取最优解（权值最小的边），最终获得全局最优解（权值和最小的生成树）。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9583.jpg" alt="IMG_9583" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9584.jpg" alt="IMG_9584" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9585.jpg" alt="IMG_9585" style="zoom:33%;"><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h3><p>树的两个重要性质：</p><ul><li>用一条边连接树中的任意两个顶点都会产生一个新的环；</li><li>从树中删去一条边将会得到两颗独立的树。</li></ul><blockquote><p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的集合。横切边是一条连接两个属于不同集合的顶点的边。</p><p>在无向图中，切分（cut）是指将图的顶点集分为两个非空子集。切分的容量是所有从子集一侧指向另一侧的边的权重之和。切分定理（cut theorem）是一种基本的图论结果，它表明对于任何图的切分，存在一条边，其权重小于或等于切分的容量，并且该边是连接源点和汇点的最小费用路径的一部分。</p><p>最小切分问题是在给定无向图和其中的两个点（源点和汇点）的情况下，找到能将源点和汇点分隔开的最小切分。</p></blockquote><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9586.jpg" alt="IMG_9586" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9587.jpg" alt="IMG_9587" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_11_IMG_9588.jpg" alt="IMG_9588" style="zoom:33%;"></p><p>对于每一种切分，权重最小的横切边必然属于最小生成树。不过，权重最小的横切边并不一定是所有横切边种唯一属于图的最小生成树的边。实际上，许多切分都会产生若干条最小生成树的横切边。</p><p>切分定理是解决最小生成树问题的所有算法的基础。使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_12_IMG_9589.jpg" alt="IMG_9589" style="zoom:33%;"><h3 id="加权无向图的数据类型" tabindex="-1"><a class="header-anchor" href="#加权无向图的数据类型" aria-hidden="true">#</a> 加权无向图的数据类型</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_12_IMG_9590.jpg" alt="IMG_9590" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_12_IMG_9591.jpg" alt="IMG_9591" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_12_IMG_9592.jpg" alt="IMG_9592" style="zoom:33%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_13_IMG_9593.jpg" alt="IMG_9593" style="zoom:33%;"><h3 id="prim算法" tabindex="-1"><a class="header-anchor" href="#prim算法" aria-hidden="true">#</a> Prim算法</h3><blockquote><p>Prim的算法是一种贪心算法，用于求解无向图的最小生成树问题。该算法<strong>以任意顶点为起点</strong>，逐渐延伸到覆盖整个图，生成一个最小生成树。</p><p>具体步骤如下：</p><ol><li>首先，选择图中任意一个顶点作为起点。</li><li>接着，每一步都要选择一条连接已经选中顶点和未选中顶点并且权值最小的边，将这条边及其对应的未选中顶点加入到生成树中。</li><li>重复步骤2，直到图中所有的顶点都被选中，这样就得到了一个最小生成树。</li></ol><p>这个算法是以数学家Robert C. Prim命名的。Prim的算法时间复杂度为O(V^2)，其中V是顶点的数量。如果使用优先队列（如斐波那契堆）来存储边，那么复杂度可以降低到O(E+VlogV)，其中E是边的数量。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_13_IMG_9594.jpg" alt="IMG_9594" style="zoom:33%;"><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_17_Prim-animation.gif" alt="File:Prim-animation.gif - Wikipedia"></p><p><strong>Prim算法的即时实现</strong></p><blockquote><p>Prim算法的即时（Immediate）实现主要有以下步骤：</p><ol><li><strong>初始化</strong>：选取一个起始点（可以是任何一个顶点），加入到最小生成树的集合中。</li><li><strong>迭代</strong>：在剩下的顶点中，找到一个距离最小生成树集合最近的顶点，加入到最小生成树的集合中，并将该顶点到最小生成树集合中的边也加入到最小生成树中。</li><li><strong>重复</strong>：重复步骤2，直到所有的顶点都被包含在最小生成树集合中。</li></ol><p>在实现这个算法时，一种有效的策略是使用优先队列（如二叉堆）来保存所有的边，以便在每一步中快速找到最小的边。在算法的每一步，我们可以更新优先队列，以考虑新添加的顶点到其余各顶点的距离。这样，即时Prim算法的时间复杂度可以被优化到O(ElogV)，其中E是边的数量，V是顶点的数量。</p><p>需要注意的是，Prim算法假设图是连通的，也就是从任意一个顶点可以到达其他任何顶点。如果图不是连通的，Prim算法将不能找到一个包含所有顶点的最小生成树。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_17_IMG_9599.jpg" alt="IMG_9599" style="zoom:33%;"><h3 id="kruskal算法" tabindex="-1"><a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a> Kruskal算法</h3><blockquote><p>Kruskal算法的步骤如下：</p><ol><li>将所有边按照权重从小到大排序。</li><li>创建一个空的最小生成树（或森林）。</li><li>从最小权重开始，依次遍历每条边。检查该边的两个顶点是否已经在最小生成树中被连接。如果没被连接，就将这条边加入最小生成树。如果已经被连接，就跳过这条边以避免形成循环（在生成树中不能有循环）。</li><li>重复步骤3，直到生成树包含了图中的所有顶点。</li></ol><p>Kruskal算法的一个重要特性是它的贪心性质：它在每一步都选择当前可用的最小成本边，这就确保了最终生成的树具有最小的总成本。虽然每一步看起来可能并不是全局最优的，但最后的结果确实全局最优的。这就是所谓的贪心策略。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_17_IMG_9600.jpg" alt="IMG_9600" style="zoom:33%;"><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_17_kruskals-algorithm-anim-1.gif" alt="Kruskal&#39;s Algorithm and Minimum Spanning Tree"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_17_IMG_9601.jpg" alt="IMG_9601" style="zoom:33%;"><h2 id="_4-4-最短路径" tabindex="-1"><a class="header-anchor" href="#_4-4-最短路径" aria-hidden="true">#</a> 4.4 最短路径</h2><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_07_18_IMG_9602.jpg" alt="IMG_9602" style="zoom:33%;"><blockquote><p>定义：在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。</p></blockquote><h3 id="最短路径的性质" tabindex="-1"><a class="header-anchor" href="#最短路径的性质" aria-hidden="true">#</a> 最短路径的性质</h3><ul><li>路径是有向的。</li><li>权重不一定等价于距离。权重也可以表示时间、花费或是某种完全无关的东西，也不一定会和距离的远近成正比。</li><li>并不是所有顶点都是可达的。</li><li>负权重会使问题更复杂。</li><li>最短路径不一定是唯一的。</li><li>可能存在平行边和自环。</li></ul><blockquote><p>**最短路径树（SPT）**定义：给定一幅加权有向图和一个顶点s，以s为起点的一颗最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根节点为s，树的每条路径都是有向图中的一条最短路径。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_18_1N7uIp.jpg" alt="IMG_9803" style="zoom:33%;"><p>通过构造最短路径树，可以为用例提供从s到图中任何顶点的最短路径，表示方法为一组指向父结点的链表。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_18_FtgM87.jpg" alt="IMG_9804" style="zoom:33%;"><p>最短路径的数据结构</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_18_HCw82p.jpg" alt="IMG_9805" style="zoom:50%;"><ul><li>最短路径树中的边 edgeTo。</li><li>到达起点的距离 distTo。</li></ul><p>边的松弛（relaxation）</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_18_cMpKbH.jpg" alt="IMG_9807" style="zoom:33%;"><p>顶点的松弛</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_21_LJOMfz.jpg" alt="IMG_9815" style="zoom:50%;"><h3 id="dijkstra算法" tabindex="-1"><a class="header-anchor" href="#dijkstra算法" aria-hidden="true">#</a> Dijkstra算法</h3><blockquote><p>定义：</p><ul><li>初始化：选择一个源点，设置该源点的最短路径估计值为0，其它所有点的最短路径估计值为无穷大。</li><li>从未被访问的节点中选择一个当前最短路径估计值最小的节点，记为当前节点。</li><li>更新当前节点的所有邻居节点的最短路径估计值：如果通过当前节点到该邻居节点的距离小于该邻居节点的当前最短路径估计值，则更新它。</li><li>标记当前节点为已访问。</li><li>重复上述步骤，直到所有节点都被访问过。</li></ul><p>限制：只适用于权重非负的加权图。</p></blockquote><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_22_aAJl7n.gif" alt="Data Structures and Algorithms: Weighted Graph Processing — Part 1: Dijkstra  | by Sethuram.S.V | Medium"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_22_5ieqgS.jpg" alt="IMG_9818" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_09_22_yfs0zo.jpg" alt="IMG_9819" style="zoom:50%;"><h3 id="无环加权有向图中的最短路径算法" tabindex="-1"><a class="header-anchor" href="#无环加权有向图中的最短路径算法" aria-hidden="true">#</a> 无环加权有向图中的最短路径算法</h3><p>特点：</p><ul><li>能够在线性时间内解决单点最短路径问题；</li><li>能够处理负权重的边；</li><li>能够解决相关的问题，例如找出最长的路径。</li></ul><p>将顶点的放松和拓扑排序结合，组成一种解决无环加权有向图中的最短路径问题的算法。</p><p>思路：将<code>distTo[s]</code>初始化为0，其他<code>distTo[]</code>初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_12_ucW1EL.jpg" alt="IMG_0385" style="zoom:33%;"> <img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_12_HCOMjE.jpg" alt="IMG_0386" style="zoom:48%;"></p><h4 id="解决并行任务调度问题" tabindex="-1"><a class="header-anchor" href="#解决并行任务调度问题" aria-hidden="true">#</a> 解决并行任务调度问题</h4><p>问题与无环加权有向图中的最长路径问题是等价的。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_12_1FCpIj.jpg" alt="IMG_0387" style="zoom:33%;"><h3 id="一般加权有向图中的最短路径问题" tabindex="-1"><a class="header-anchor" href="#一般加权有向图中的最短路径问题" aria-hidden="true">#</a> 一般加权有向图中的最短路径问题</h3><p>当图只存在正权重的边时，我们的重点在于寻找近路。如果图存在负权重的边时，我们可能会为了经过负权重的边而绕弯。</p><p>当图中存在负权重的环时，在这种情况下，从s到v的最短路径是不可能存在的，因为可以用这个负权重环构造权重任意小的路径。</p><h3 id="bellman-ford算法" tabindex="-1"><a class="header-anchor" href="#bellman-ford算法" aria-hidden="true">#</a> Bellman-Ford算法</h3><p>Bellman-Ford算法所需的时间和EV成正比，空间和V成正比。</p><h4 id="基于队列的bellman-ford算法" tabindex="-1"><a class="header-anchor" href="#基于队列的bellman-ford算法" aria-hidden="true">#</a> 基于队列的Bellman-Ford算法</h4><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_16_Bt96WI.jpg" alt="IMG_0455" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_16_9QEMsE.jpg" alt="IMG_0456" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_17_IoXy5d.gif" alt="Shortest_path_Dijkstra_vs_BellmanFord" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_17_UNLOo7.jpg" alt="IMG_0459" style="zoom:50%;"><h1 id="第5章-字符串" tabindex="-1"><a class="header-anchor" href="#第5章-字符串" aria-hidden="true">#</a> 第5章 字符串</h1><h2 id="_5-1-字符串排序" tabindex="-1"><a class="header-anchor" href="#_5-1-字符串排序" aria-hidden="true">#</a> 5.1 字符串排序</h2><h3 id="_5-1-1-键索引计数法" tabindex="-1"><a class="header-anchor" href="#_5-1-1-键索引计数法" aria-hidden="true">#</a> 5.1.1 键索引计数法</h3><blockquote><p>键索引计数法是一种用于小整数键的排序方法。它是许多字符串排序算法，如高位优先（MSD）和低位优先（LSD）的基础。</p><h3 id="算法思路" tabindex="-1"><a class="header-anchor" href="#算法思路" aria-hidden="true">#</a> 算法思路：</h3><p>考虑我们有一系列对象，其中每个对象都有一个 0 到 R-1 之间的整数键（R 是整数键的范围）。键索引计数法的步骤如下：</p><ol><li><strong>计数</strong>：为每个键值 k，计算出小于 k 的键的数量。这可以通过一个简单的遍历和一个计数数组来完成。</li><li><strong>转移</strong>：将对象移动到其在排序结果中的最终位置。你可以创建一个辅助数组，然后遍历原始数组，利用计数数组放置每个对象在正确的位置。</li><li><strong>复制回去</strong>：从辅助数组中复制对象回原始数组。</li></ol><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点：</h3><ol><li><strong>线性时间复杂度</strong>：对于固定大小的 R，键索引计数法可以在 O(N) 时间内完成，其中 N 是要排序的对象的数量。</li><li><strong>简单易懂</strong>：算法的基本思路相对直观，容易实现。</li><li><strong>稳定性</strong>：这种排序方法是稳定的，即具有相同键的对象之间的相对顺序在排序后不会改变。</li></ol><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点：</h3><ol><li><strong>限定的键类型</strong>：键索引计数法主要用于小范围的整数键。对于较大范围的整数或非整数键，该方法不适用或需要进行修改。</li><li><strong>额外的空间</strong>：需要一个计数数组和一个辅助数组，这可能会增加额外的空间需求。</li></ol><p>总的来说，键索引计数法是一个非常高效且稳定的排序方法，特别适合小范围的整数键。但它的应用范围受到键的类型和范围的限制。</p></blockquote><blockquote><p><strong>算法思路举例：</strong></p><p>假设你是一名老师，你手里有一堆学生的考试卷，你想根据他们的成绩进行排序。但这次的考试特别简单，只有5分，所以学生们的分数只有0分、1分、2分、3分、4分或5分。</p><p>这就意味着，你完全可以预测学生的分数范围。所以你在桌子上放置了6个桶（因为有6个可能的分数），分别标记为0、1、2、3、4和5。</p><p>现在你开始一个接一个地看学生的考试卷：</p><ol><li>如果某个学生得了3分，你就把他的卷子放到标记为“3”的桶里。</li><li>如果另一个学生得了0分，你就把他的卷子放到标记为“0”的桶里。</li></ol><p>你这样做，直到所有的卷子都被放到对应的桶里。</p><p>最后，你只需要从左到右（从0到5）依次取出每个桶里的卷子，这样你就得到了一个按分数排序的考试卷堆。</p><p><strong>键索引计数法的核心就是这样</strong>：因为你知道了“键”的可能范围（在这个例子中，就是分数的范围），你可以为每一个可能的键值预留一个位置（桶）。然后，你只需要把数据放到对应的位置上，再从左到右收集数据，就得到了排序好的结果。</p></blockquote><p>键索引计数法的基本思路如下：</p><ol><li><strong>计数</strong>：计算出每个键值的数量。例如，键值为 k 的字符串有 C[k] 个。</li><li><strong>累加</strong>：根据键值计数来确定每个键值在排序结果中的起始位置。比如说，键值 k 的起始位置就是前 k 个键值的数量之和。</li><li><strong>排序</strong>：遍历原始数据，根据每个元素的键值和相应的位置，放到结果数组的正确位置，并更新键值对应的位置。</li><li><strong>复制回原数组</strong>：从结果数组中复制到原始数组。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_21_zzjyJd.jpg" alt="IMG_0463" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_21_NUAtYL.jpg" alt="IMG_0464" style="zoom:50%;"><div class="language-java ext-java line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#81A1C1;">int</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">N</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">a</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">length</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8FBCBB;">String</span><span style="color:#ECEFF4;">[]</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">aux</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">new</span><span style="color:#D8DEE9FF;"> </span><span style="color:#8FBCBB;">String</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">N</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#81A1C1;">int</span><span style="color:#ECEFF4;">[]</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">count</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">new</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">int</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">R</span><span style="color:#81A1C1;">+</span><span style="color:#B48EAD;">1</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;">// 计算出现频率</span></span>
<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#81A1C1;">int</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i </span><span style="color:#81A1C1;">&lt;</span><span style="color:#D8DEE9FF;"> N</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  count</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">a</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">i</span><span style="color:#ECEFF4;">].</span><span style="color:#88C0D0;">key</span><span style="color:#ECEFF4;">()</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">+</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">1</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">++;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#616E88;">// 将频率转换为索引</span></span>
<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#81A1C1;">int</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">r</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> r </span><span style="color:#81A1C1;">&lt;</span><span style="color:#D8DEE9FF;"> R</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> r</span><span style="color:#81A1C1;">++</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  count</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">r</span><span style="color:#81A1C1;">+</span><span style="color:#B48EAD;">1</span><span style="color:#ECEFF4;">]</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">+=</span><span style="color:#D8DEE9FF;"> count</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">r</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#616E88;">// 将元素分类</span></span>
<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#81A1C1;">int</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i </span><span style="color:#81A1C1;">&lt;</span><span style="color:#D8DEE9FF;"> N</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  aux</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">count</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">a</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">i</span><span style="color:#ECEFF4;">].</span><span style="color:#88C0D0;">key</span><span style="color:#ECEFF4;">()]</span><span style="color:#81A1C1;">++</span><span style="color:#ECEFF4;">]</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> a</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">i</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"><span style="color:#616E88;">// 回写</span></span>
<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">(</span><span style="color:#81A1C1;">int</span><span style="color:#D8DEE9FF;"> </span><span style="color:#D8DEE9;">i</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i </span><span style="color:#81A1C1;">&lt;</span><span style="color:#D8DEE9FF;"> N</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#ECEFF4;">)</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">{</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  a</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">i</span><span style="color:#ECEFF4;">]</span><span style="color:#D8DEE9FF;"> </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9FF;"> aux</span><span style="color:#ECEFF4;">[</span><span style="color:#D8DEE9FF;">i</span><span style="color:#ECEFF4;">]</span><span style="color:#81A1C1;">;</span></span>
<span class="line"><span style="color:#ECEFF4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_5-1-2-低位优先的字符串排序" tabindex="-1"><a class="header-anchor" href="#_5-1-2-低位优先的字符串排序" aria-hidden="true">#</a> 5.1.2 低位优先的字符串排序</h3><blockquote><p>低位优先（Least Significant Digit First，LSD）的字符串排序。</p><ul><li>这种方法主要用于固定长度的字符串。</li><li>从字符串的最右侧（也就是最低位）开始排序。</li><li>例如，对于 &quot;329&quot;, &quot;457&quot;, &quot;657&quot;, &quot;123&quot; 这样的数字字符串，我们首先根据最后一位数字（个位）进行排序，然后再根据倒数第二位（十位）进行排序，最后根据倒数第三位（百位）进行排序。</li><li>这种排序方法常用计数排序实现，因为它可以保证稳定性。</li><li>该方法的优势在于对于具有相同前缀的字符串，它可以很快地将它们按照后缀来排序。</li></ul></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_21_nMfoWj.jpg" alt="IMG_0465" style="zoom:50%;"><h3 id="_5-1-3-高位优先的字符串排序" tabindex="-1"><a class="header-anchor" href="#_5-1-3-高位优先的字符串排序" aria-hidden="true">#</a> 5.1.3 高位优先的字符串排序</h3><blockquote><p>高位优先的字符串排序（Most Significant Digit, MSD 字符串排序）是一种基数排序方法，适用于字符串数据。它从字符串的最高位（即最左边的字符）开始进行排序，并逐渐考虑较低的位。</p><h3 id="算法思路-1" tabindex="-1"><a class="header-anchor" href="#算法思路-1" aria-hidden="true">#</a> 算法思路：</h3><ol><li>对于字符串的第一个字符（最高位），使用键索引计数法对数组进行排序。</li><li>根据第一个字符将字符串数组分成几部分，每一部分内部的字符串在第一个字符上都是相同的。</li><li>递归地对每一部分的字符串使用高位优先的排序，但是对第二个字符进行排序，以此类推。</li><li>递归的基准情况可以是字符串的长度或子数组的大小。</li></ol><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点：</h3><ol><li><strong>适应性</strong>：对于随机的字符串，MSD 排序通常比其他字符串排序算法更快。</li><li><strong>局部性</strong>：当存在大量公共前缀或小的子数组时，算法可以非常高效。</li><li><strong>预测性</strong>：对于某些应用，高位优先的排序可以提前确定某些结果，这在某些场景下可能非常有用。</li></ol><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点：</h3><ol><li><strong>额外的空间</strong>：需要额外的空间来存储计数和辅助数组。</li><li><strong>处理小数组低效</strong>：对于小数组，MSD 排序的开销可能比简单的排序算法要大。</li><li><strong>过于复杂</strong>：与其他简单的字符串排序算法相比，它的实现稍微复杂一些。</li><li><strong>不稳定性</strong>：原始的 MSD 排序是不稳定的，但可以进行修改使其稳定。</li></ol></blockquote><p>思路：首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个字母所对应的子数组排序。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_21_bwxpii.jpg" alt="IMG_0466" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_24_v3N4XF.jpg" alt="IMG_0476" style="zoom:50%;"><p>高位优先的字符串排序的最坏情况是<strong>所有的键均相同</strong>。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_24_YQsTGY.jpg" alt="IMG_0477" style="zoom:50%;"><h3 id="_5-1-4-三向字符串快速排序" tabindex="-1"><a class="header-anchor" href="#_5-1-4-三向字符串快速排序" aria-hidden="true">#</a> 5.1.4 三向字符串快速排序</h3><p>三向字符串快速排序是普通的的快速排序和高位优先的字符串排序的结合。</p><blockquote><p>三向字符串快速排序（3-way string quicksort）是一种处理字符串数组的排序方法，特别适用于存在大量重复字符串的数组。它是标准的快速排序和键索引计数法的结合。</p><h3 id="排序思路" tabindex="-1"><a class="header-anchor" href="#排序思路" aria-hidden="true">#</a> 排序思路：</h3><ol><li>选择一个字符为分割字符（如当前考虑的所有字符串的第 k 个字符）。</li><li>将数组划分为三部分： <ul><li>所有小于分割字符的字符串。</li><li>所有等于分割字符的字符串。</li><li>所有大于分割字符的字符串。</li></ul></li><li>递归地对小于分割字符的字符串和大于分割字符的字符串进行排序。</li><li>对于等于分割字符的字符串，递归地考虑下一个字符。</li></ol><h3 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点：</h3><ol><li><strong>处理重复字符串高效</strong>：对于有大量重复的字符串，它可能比其他算法快很多倍。</li><li><strong>适应性</strong>：即使在没有太多重复字符串的情况下，它仍然具有很好的性能。</li></ol><h3 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点：</h3><ol><li><strong>额外的空间</strong>：与标准的快速排序相比，三向字符串快速排序在递归调用时可能需要额外的空间。</li><li><strong>复杂性</strong>：相对于其他基础的排序算法，三向字符串快速排序在实现上稍微复杂一些。</li></ol></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_25_LP0oDM.jpg" alt="IMG_0478" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_25_FzwfDP.jpg" alt="IMG_0479" style="zoom:50%;"><h2 id="_5-2-单词查找树" tabindex="-1"><a class="header-anchor" href="#_5-2-单词查找树" aria-hidden="true">#</a> 5.2 单词查找树</h2><h3 id="单词查找树" tabindex="-1"><a class="header-anchor" href="#单词查找树" aria-hidden="true">#</a> 单词查找树</h3><blockquote><p>单词查找树（Trie），也被称为前缀树或字典树，是一种用于存储动态字符串集合的树状数据结构。在Trie中，键不是直接与其节点关联的，而是通过键中的字符与从根到指定节点的路径关联。</p><p>Trie的特点：</p><ol><li>根节点不包含字符，除根节点外的每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><p><strong>优点</strong>：</p><ol><li><strong>查找效率高</strong>：对于长度为k的字符串，查找的时间复杂度近似于O(k)。</li><li><strong>有前缀的存储和查找</strong>：非常适合查找前缀相关的字符串，例如“aut”可以快速找到“auto”、“automatic”等词。</li><li><strong>节约空间</strong>：对于有大量公共前缀的字符串集合，Trie可以节约存储空间。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>空间开销</strong>：如果字符串集合没有很多共同的前缀，那么Trie可能会占用比其他数据结构更多的空间。</li><li><strong>复杂性</strong>：实现Trie比较复杂，特别是当涉及到删除操作和其他一些高级功能时。</li><li><strong>速度不一定总是最快的</strong>：尽管Trie的查找速度非常快，但是在某些情况下，基于散列表或平衡树的实现可能会更有效。</li></ol><p><strong>实际应用</strong>：</p><ol><li><strong>自动补全</strong>：如搜索引擎在输入时给出的推荐词汇。</li><li><strong>拼写检查</strong>：找到与错误拼写词最接近的正确单词。</li><li><strong>路由器的IP路由选择</strong>。</li><li><strong>数字电话书</strong>：用于存储电话号码。</li><li><strong>字典</strong>：快速查找某个词是否存在。</li></ol></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_25_QYr5B2.jpg" alt="IMG_0480" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_25_Lu5Zid.jpg" alt="IMG_0481" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_10_25_b71aBJ.jpg" alt="IMG_0483" style="zoom:50%;"><blockquote><p>单词查找树（Trie）的操作通常都是基于前缀的搜索。以下是查找、插入和删除操作的基本思路：</p><h3 id="_1-查找" tabindex="-1"><a class="header-anchor" href="#_1-查找" aria-hidden="true">#</a> 1. 查找：</h3><p><strong>目标</strong>：确定一个字符串是否存在于Trie中。</p><p><strong>步骤</strong>：</p><ol><li>从根节点开始。</li><li>对于输入字符串的每个字符，按照该字符从当前节点向下搜索。</li><li>如果存在一个匹配的子节点，移动到该子节点，继续下一个字符的搜索。</li><li>如果在某个字符处没有匹配的子节点，那么该字符串不在Trie中，返回false。</li><li>如果已经处理了输入字符串的所有字符并且最后一个字符的节点标记为结束节点（通常用于表示一个完整的单词），则字符串存在于Trie中。</li></ol><h3 id="_2-插入" tabindex="-1"><a class="header-anchor" href="#_2-插入" aria-hidden="true">#</a> 2. 插入：</h3><p><strong>目标</strong>：将一个字符串插入到Trie中。</p><p><strong>步骤</strong>：</p><ol><li>从根节点开始。</li><li>对于输入字符串的每个字符，按照该字符从当前节点向下搜索。</li><li>如果存在一个匹配的子节点，移动到该子节点，继续下一个字符的搜索。</li><li>如果在某个字符处没有匹配的子节点，创建一个新的子节点，并继续插入后续的字符。</li><li>在插入的字符串的最后一个字符所在的节点，标记为结束节点。</li></ol><h3 id="_3-删除" tabindex="-1"><a class="header-anchor" href="#_3-删除" aria-hidden="true">#</a> 3. 删除：</h3><p><strong>目标</strong>：从Trie中删除一个字符串。</p><p><strong>步骤</strong>：</p><ol><li>使用查找操作来找到该字符串。</li><li>如果字符串存在，从字符串的最后一个字符开始回溯。</li><li>删除每一个字符的节点，但在以下情况中停止： <ul><li>如果当前节点有其他子节点（这意味着存在其他共享该前缀的字符串）。</li><li>如果当前节点被标记为另一个字符串的结束节点。</li></ul></li><li>删除字符串的过程结束。</li></ol><p>需要注意的是，删除操作可能不会从Trie中删除所有关于字符串的信息。如果Trie中的其他字符串与待删除的字符串共享前缀，则这些前缀仍然会保留在Trie中。</p><p>这些操作确保Trie可以高效地存储和查询字符串，尤其是当需要查询前缀或者插入和删除时。</p></blockquote><h3 id="三向单词查找树" tabindex="-1"><a class="header-anchor" href="#三向单词查找树" aria-hidden="true">#</a> 三向单词查找树</h3><blockquote><p>三向单词查找树（Ternary Search Tree，TST）是一种用于存储字符串的数据结构，可以看作是二叉查找树（BST）和标准单词查找树（Trie）的折衷方案。它结合了这两种数据结构的一些优点，同时也有自己独特的特性。</p><h3 id="三向单词查找树的结构" tabindex="-1"><a class="header-anchor" href="#三向单词查找树的结构" aria-hidden="true">#</a> 三向单词查找树的结构</h3><p>在三向单词查找树中，每个节点包含一个字符、三个子节点（左子节点、中子节点和右子节点），以及一个标记（用于标记字符串的结束）。</p><ul><li><strong>左子节点</strong>：包含比当前节点字符小的字符。</li><li><strong>中子节点</strong>：包含与当前节点字符相同的下一个字符。</li><li><strong>右子节点</strong>：包含比当前节点字符大的字符。</li></ul><h3 id="三向单词查找树的优点" tabindex="-1"><a class="header-anchor" href="#三向单词查找树的优点" aria-hidden="true">#</a> 三向单词查找树的优点</h3><ol><li><strong>空间效率</strong>：相比标准的Trie，TST通常使用更少的空间，特别是当字符串集合中的许多字符串共享相同的前缀时。</li><li><strong>查找效率</strong>：对于大多数场景，TST提供了很好的查找效率，尤其是当字符串长度不均匀时。</li><li><strong>灵活性</strong>：它更适合处理那些变化较大的字符串集合，例如自然语言处理中的单词。</li><li><strong>前缀查询</strong>：TST能高效地支持前缀查询操作。</li></ol><h3 id="三向单词查找树的缺点" tabindex="-1"><a class="header-anchor" href="#三向单词查找树的缺点" aria-hidden="true">#</a> 三向单词查找树的缺点</h3><ol><li><strong>性能不稳定</strong>：其性能依赖于数据的特点和树的结构，有时可能不如标准Trie或平衡二叉查找树。</li><li><strong>实现复杂度</strong>：相比普通的二叉查找树，TST的实现更复杂。</li></ol><h3 id="与单词查找树-trie-的区别" tabindex="-1"><a class="header-anchor" href="#与单词查找树-trie-的区别" aria-hidden="true">#</a> 与单词查找树（Trie）的区别</h3><ol><li><strong>空间占用</strong>：Trie由于每个节点分支数量等于字母表的大小，因此可能会占用大量空间，特别是在存储大量短字符串时。TST通常更加空间高效。</li><li><strong>查找速度</strong>：Trie的查找操作可能在某些情况下比TST更快，特别是在字母表大小较小且字符串长度大致相同的场景中。</li><li><strong>实现复杂性</strong>：Trie的结构通常比TST更简单，易于实现和理解。</li></ol><p>总的来说，三向单词查找树在处理具有共同前缀的字符串集合时，提供了一种既节省空间又保持较高查询效率的解决方案，但其性能受数据特性和树结构的影响较大。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_mXYeKx.jpg" alt="IMG_0525" style="zoom:50%;"><blockquote><p>三向单词查找树（Ternary Search Tree，TST）的查找、插入和删除操作都是基于树的递归遍历，这些操作与传统的二叉查找树相似，但需要考虑每个节点的三个子树（左、中、右）。</p><h3 id="查找操作" tabindex="-1"><a class="header-anchor" href="#查找操作" aria-hidden="true">#</a> 查找操作</h3><p>查找操作是根据给定的键（字符串）来定位树中的特定节点。</p><ol><li><strong>开始</strong>：从根节点开始。</li><li><strong>字符比较</strong>：将键的当前字符与节点的字符比较。</li><li><strong>导航树</strong>： <ul><li>如果键的字符小于节点的字符，转到左子树。</li><li>如果键的字符大于节点的字符，转到右子树。</li><li>如果键的字符等于节点的字符，转到中子树，并移动到键的下一个字符。</li></ul></li><li><strong>找到或未找到</strong>：如果能够逐个字符地遍历完整个键而且最后一个字符对应的节点标记为字符串结束，则成功找到。如果在任何时候节点为null或键中的字符无法完全匹配，说明键不在树中。</li></ol><h3 id="插入操作-1" tabindex="-1"><a class="header-anchor" href="#插入操作-1" aria-hidden="true">#</a> 插入操作</h3><p>插入操作用于将一个新的键添加到树中。</p><ol><li><strong>开始</strong>：从根节点开始。</li><li><strong>字符比较</strong>：将键的当前字符与节点的字符比较。</li><li><strong>导航和创建</strong>： <ul><li>如果键的字符小于节点的字符，如果左子树为空，则创建新节点，否则转到左子树。</li><li>如果键的字符大于节点的字符，如果右子树为空，则创建新节点，否则转到右子树。</li><li>如果键的字符等于节点的字符，如果中子树为空并且还有更多的字符，创建新的中间节点，否则转到中子树。</li></ul></li><li><strong>完成插入</strong>：当所有键的字符都已被遍历，并到达合适的插入点，标记最后一个节点为字符串的结束。</li></ol><h3 id="删除操作-1" tabindex="-1"><a class="header-anchor" href="#删除操作-1" aria-hidden="true">#</a> 删除操作</h3><p>删除操作在TST中比较复杂，因为它可能需要重新连接树的多个部分。</p><ol><li><strong>查找要删除的键</strong>：首先按照查找操作找到要删除的键。</li><li><strong>删除标记</strong>：如果找到了该键，去除最后一个字符节点上的结束标记。</li><li><strong>清理无用节点</strong>：如果去除结束标记的节点之后没有子节点，该节点变成了无用节点，需要删除。这可能会引起一连串的删除，直到遇到一个有中子节点或者有结束标记的节点为止。</li><li><strong>递归删除</strong>：从删除节点的父节点开始，递归地检查并清理无用节点。</li></ol><p>在实际应用中，删除操作相对复杂且不常用。一些实现可能选择不实现删除操作，或者标记删除而不是物理删除节点。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_IgQfiq.jpg" alt="IMG_0526" style="zoom:50%;"><p>与其他所有二叉查找树一样，每个单词查找树结点的二叉查找树表示也取决于键的插入顺序。</p><p>空间：三次单词查找树每个键只含有三个节点，因此三向单词查找树所需要的空间远小于对应的单词查找树。</p><p>最坏情况：一个结点可能变成一个完全的R向结点，不平衡且像一条链表一样展开。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_6wGnA0.jpg" alt="IMG_0531" style="zoom:50%;"><h2 id="_5-3-子字符串查找" tabindex="-1"><a class="header-anchor" href="#_5-3-子字符串查找" aria-hidden="true">#</a> 5.3 子字符串查找</h2><p>定义：给定一段长度为N的文本和一个长度为M的模式（pattern）字符串，在文本中找到一个和该模式相符的子字符串。</p><h3 id="暴力子字符串查找算法" tabindex="-1"><a class="header-anchor" href="#暴力子字符串查找算法" aria-hidden="true">#</a> 暴力子字符串查找算法</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_tPsnho.jpg" alt="IMG_0532" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_BcYZgQ.jpg" alt="IMG_0533" style="zoom:50%;"><h3 id="knuth-morris-pratt-子字符串查找算法" tabindex="-1"><a class="header-anchor" href="#knuth-morris-pratt-子字符串查找算法" aria-hidden="true">#</a> Knuth-Morris-Pratt 子字符串查找算法</h3><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_01_pI67g0.gif" alt="v2-e33c0391971a733a7039c8608b5d2c63_b"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_09_RL7VSu.jpg" alt="IMG_0557" style="zoom:50%;"><blockquote><p>KMP算法的核心思路可以分为两个主要部分：</p><h3 id="_1-构造部分匹配表-partial-match-table-也称为前缀表或失败函数" tabindex="-1"><a class="header-anchor" href="#_1-构造部分匹配表-partial-match-table-也称为前缀表或失败函数" aria-hidden="true">#</a> 1. 构造部分匹配表（Partial Match Table，也称为前缀表或失败函数）</h3><p>这个表是KMP算法的关键，它记录了模式串中每个位置之前的子串中，最长的相等的前缀和后缀的长度。通过这个表，我们可以在不匹配时，找到一个更好的开始匹配的位置，而不是像简单的匹配算法那样，仅仅从下一个位置开始。</p><p>举例来说，对于模式串 &quot;ABCDABD&quot;，它的部分匹配表是：</p><div class="language-text ext-text line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#d8dee9ff;">=</span></span>
<span class="line"><span style="color:#d8dee9ff;">A B C D A B D</span></span>
<span class="line"><span style="color:#d8dee9ff;">0 0 0 0 1 2 0</span></span>
<span class="line"><span style="color:#d8dee9ff;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个表告诉我们，例如在模式串的第六个字符（&#39;B&#39;）处不匹配时，我们知道在这之前的子串 &quot;ABCDAB&quot; 的最长相等前后缀是 &quot;AB&quot;（长度为2）。这意味着我们可以将模式串向右移动4位（6 - 2），而不是一位一位地移动。</p><h3 id="_2-搜索算法" tabindex="-1"><a class="header-anchor" href="#_2-搜索算法" aria-hidden="true">#</a> 2. 搜索算法</h3><p>在进行实际的搜索时，KMP算法会利用这个部分匹配表来移动模式串：</p><ul><li>当模式串的某个字符与文本串不匹配时，我们可以查找部分匹配表，看在模式串中最后一个匹配的字符前的最长相等前后缀的长度，然后相应地移动模式串。</li><li>如果没有匹配的部分（即表中的值为0），则简单地将模式串向右移动一位。</li><li>如果整个模式串遍历完成，那么表明找到了一个匹配。</li></ul><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3><p>KMP算法的优势在于它避免了无谓的比较。在最坏的情况下，KMP算法的时间复杂度是O(n)，其中n是文本字符串的长度。相比之下，朴素的字符串搜索算法在最坏情况下的时间复杂度是O(mn)，其中m是模式串的长度。</p></blockquote><blockquote><p>KMP通俗易懂思路：</p><p>想象你在一本书里查找一个特定的词语（比如&quot;abcdabd&quot;），你会从书的开头开始，一直对照这个词语读下去。在用普通方法查找时，每当你发现字不匹配时，你会把注意力重新放在词语的第一个字母上，并从书里你停下的下一个字母开始再次对比。</p><p>但这种方法有点浪费时间，因为你在重复检查一些你已经知道不匹配的部分。这就像你在寻找&quot;abcdabd&quot;，当你读到&quot;abcdabc&quot;时发现不匹配，普通的方法会让你从&quot;b&quot;（即第二个字母）开始重新比较，但其实你已经知道前面的&quot;abc&quot;是匹配的，完全没必要重头开始。</p><p>KMP算法就是为了解决这个问题而生的。它首先会预先分析这个词语，创建一个所谓的&quot;部分匹配表&quot;。这个表帮助你确定在不匹配的情况下可以跳过多少个字符。</p><p>继续用&quot;abcdabd&quot;为例，KMP算法会先分析它，然后得出一个表，这个表告诉你每个字符后面有多少个字符是可以在不匹配的情况下跳过的。比如，到了&quot;abcdabd&quot;的第四个字母&quot;d&quot;发现不匹配，你可以直接跳过接下来的三个字母，因为根据之前的分析，你知道接下来的三个字母不可能构成你要找的词语。</p><p>这样，KMP算法就通过避免重复检查已知不匹配的部分，显著提高了查找效率。这在长字符串或者有很多重复模式的文本中尤其有用。</p></blockquote><blockquote><p>DFA（确定性有限自动机，Deterministic Finite Automaton）是有限状态机的一种特殊形式，其中每个状态对于给定的输入都只有一个唯一的后继状态。DFA在理论计算机科学、语言处理、软件工程等领域中非常重要，它们是理解和设计语言解析和模式识别算法的基础。</p><h3 id="dfa的基本概念" tabindex="-1"><a class="header-anchor" href="#dfa的基本概念" aria-hidden="true">#</a> DFA的基本概念</h3><ol><li><strong>状态（States）</strong>： <ul><li>DFA包含一组有限的状态。</li><li>其中有一个特定的状态被定义为起始状态。</li><li>也可能有一个或多个状态被定义为接受状态，它们表示成功完成了某种计算或识别过程。</li></ul></li><li><strong>输入字母表（Input Alphabet）</strong>： <ul><li>DFA基于一个定义好的输入字母表运行。</li><li>字母表是有效输入字符的集合。</li></ul></li><li><strong>转移函数（Transition Function）</strong>： <ul><li>DFA的核心是转移函数，它定义了如何根据当前状态和输入字符转移到下一个状态。</li><li>对于DFA来说，给定当前状态和一个输入字符，有且只有一个唯一的状态作为输出。</li></ul></li><li><strong>接受状态（Accepting States）</strong>： <ul><li>当DFA到达接受状态时，它表示接受了输入字符串。</li><li>一个字符串是否被DFA接受取决于它是否能从起始状态经过一系列状态转移最终到达接受状态。</li></ul></li></ol><h3 id="dfa的应用" tabindex="-1"><a class="header-anchor" href="#dfa的应用" aria-hidden="true">#</a> DFA的应用</h3><p>DFA在计算机科学中有多种应用，例如：</p><ul><li><strong>模式匹配</strong>：例如在文本处理中识别特定的字符串模式。</li><li><strong>词法分析</strong>：在编译器中，词法分析器用DFA来识别语言中的词汇单元（如变量名、关键字）。</li><li><strong>协议设计</strong>：在网络或通信协议中用于确定有效的消息序列。</li><li><strong>游戏开发</strong>：在游戏设计中，用于建立角色或系统的不同状态。</li></ul></blockquote><blockquote><p>通俗易懂理解DFA：</p><p>想象你开车来到一个自动化的停车场。停车场入口处有一个自动门和一个票务机器，它们共同构成了一个DFA。</p><h3 id="状态-state" tabindex="-1"><a class="header-anchor" href="#状态-state" aria-hidden="true">#</a> 状态（State）</h3><ul><li><strong>初始状态</strong>：门是关闭的，机器等待车辆靠近。</li><li><strong>中间状态</strong>：门打开，车辆进入。</li><li><strong>接受状态</strong>：门关闭，车辆已进入。</li></ul><h3 id="输入-input" tabindex="-1"><a class="header-anchor" href="#输入-input" aria-hidden="true">#</a> 输入（Input）</h3><ul><li><strong>车辆靠近</strong>：你驾车向门靠近。</li><li><strong>车辆离开</strong>：车辆通过门并离开入口区域。</li></ul><h3 id="转移规则-transition-function" tabindex="-1"><a class="header-anchor" href="#转移规则-transition-function" aria-hidden="true">#</a> 转移规则（Transition Function）</h3><ul><li>当<strong>门关闭</strong>且<strong>车辆靠近</strong>时，门会开启。</li><li>当<strong>门开启</strong>且<strong>车辆通过门离开</strong>时，门会关闭。</li></ul><h3 id="过程" tabindex="-1"><a class="header-anchor" href="#过程" aria-hidden="true">#</a> 过程</h3><ol><li><strong>开始</strong>：门关闭。你驾车接近停车场（输入：车辆靠近），这是你向DFA提供的输入。</li><li><strong>门开启</strong>：票务机器检测到车辆，发送指令打开门。状态从“门关闭”变为“门开启”。</li><li><strong>通过门</strong>：你开车通过门（输入：车辆离开）。</li><li><strong>门关闭</strong>：你通过后，门关闭。状态从“门开启”变为“门关闭”。</li><li><strong>结束</strong>：停车场成功接收了你的车辆，你完成了从起始状态（门关闭，车外）到接受状态（门关闭，车内）的转换。</li></ol><p>在这个例子中，停车场门的开关状态可以看作是DFA的不同状态，车辆的靠近和离开是输入信号，而票务机器的逻辑就是根据当前状态和输入确定下一状态的转移函数。每个状态和输入的组合都有一个明确的结果，这正是“确定性”的含义。</p></blockquote><blockquote><p>KMP（Knuth-Morris-Pratt）算法本身并不直接使用确定性有限自动机（DFA），但其背后的思想与DFA有着紧密的联系。KMP算法是一种高效的字符串匹配算法，主要用于在一个文本字符串中查找一个模式（或子串）的出现位置。它的核心在于预处理模式串，构建一个部分匹配表（也称为“失配表”或“前缀函数”），这个表在本质上和DFA有相似之处。</p><h3 id="kmp算法与dfa的联系" tabindex="-1"><a class="header-anchor" href="#kmp算法与dfa的联系" aria-hidden="true">#</a> KMP算法与DFA的联系</h3><p>在KMP算法中，部分匹配表是根据模式串的前缀信息构建的。对于模式串中的每个位置，表中的值指示当在文本串中匹配到该位置发生失配时，模式串应该回溯到哪个位置继续匹配。这个“回溯位置”其实就是在模式串中最长的相等的前缀和后缀的长度。KMP算法利用这个表来避免从头开始重新匹配，从而提高了匹配效率。</p><p>而在DFA中，针对一个特定的输入和当前状态，自动机会转移到一个新的状态。构建一个针对模式串的DFA意味着为模式串的每个可能的前缀定义状态，并为每个可能的字符输入定义状态转移。理论上，可以将KMP算法的部分匹配表转换为一个DFA，其中每个状态对应于模式串的一个前缀，并且转移是根据部分匹配表和下一个输入字符确定的。</p></blockquote><h3 id="boyer-moore-字符串查找算法" tabindex="-1"><a class="header-anchor" href="#boyer-moore-字符串查找算法" aria-hidden="true">#</a> Boyer-Moore 字符串查找算法</h3><blockquote><p>Boyer-Moore字符串搜索算法是由Robert S. Boyer和J Strother Moore在1977年提出的一种高效的字符串搜索算法。它被认为是在实践中最快的单模式字符串搜索算法之一，尤其是当被搜索的字符串非常长时。</p><h3 id="核心思路" tabindex="-1"><a class="header-anchor" href="#核心思路" aria-hidden="true">#</a> 核心思路：</h3><p>Boyer-Moore算法的主要思想是从目标字符串的末尾开始匹配模式字符串。算法维护两个启发式的规则——坏字符规则（Bad Character Rule）和好后缀规则（Good Suffix Rule），用以在不匹配时跳过尽可能多的字符。</p><ol><li><p><strong>坏字符规则</strong>：</p><ul><li>当发生不匹配时，算法查看文本中参与不匹配的字符（坏字符）。</li><li>如果坏字符不包含在模式中，模式可以完全跳过坏字符之前的部分。</li><li>如果坏字符在模式中，则模式滑动至模式中最右边的坏字符与文本中的坏字符对齐。</li></ul></li><li><p><strong>好后缀规则</strong>：</p><ul><li>当模式中的一部分（后缀）与文本匹配，但随后出现一个不匹配的字符时，算法利用已经匹配的部分（好后缀）信息。</li><li>算法搜索模式中是否存在另一个相同的后缀，并将模式滑动至这个重复后缀的位置。</li><li>如果不存在，算法会尝试找到好后缀的后缀与模式的前缀匹配的情况，相应地滑动模式。</li></ul></li></ol><p>这两个规则结合起来使得算法在每次不匹配发生时可以跳过尽可能多的字符。</p><h3 id="优点-3" tabindex="-1"><a class="header-anchor" href="#优点-3" aria-hidden="true">#</a> 优点：</h3><ol><li><strong>高效率</strong>：在最好情况下，Boyer-Moore算法的时间复杂度可以达到O(N/M)（N是文本长度，M是模式长度），远远超过其他算法。</li><li><strong>后移位数更多</strong>：由于它使用了坏字符规则和好后缀规则，所以它通常可以跳过更多的字符，这使得其平均性能很好。</li><li><strong>对长文本更友好</strong>：在处理非常长的文本时，Boyer-Moore表现出更加出色的性能。</li></ol><h3 id="缺点-3" tabindex="-1"><a class="header-anchor" href="#缺点-3" aria-hidden="true">#</a> 缺点：</h3><ol><li><strong>预处理时间</strong>：算法需要预处理模式字符串来构建坏字符表和好后缀表，这需要额外的时间和空间。</li><li><strong>复杂性</strong>：相对于其他算法（如KMP），Boyer-Moore的实现相对复杂，难以理解和编码。</li><li><strong>不稳定</strong>：在最坏情况下，性能可能会下降到O(N*M)，虽然这在实践中很少见。</li></ol><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景：</h3><ul><li>文本编辑器的查找功能。</li><li>数据库文本搜索。</li><li>全文搜索引擎。</li><li>任何需要高效字符串搜索的场合，尤其是搜索长文本。</li></ul><h3 id="与kmp算法的区别" tabindex="-1"><a class="header-anchor" href="#与kmp算法的区别" aria-hidden="true">#</a> 与KMP算法的区别：</h3><ul><li><strong>算法策略</strong>：KMP算法侧重于避免重新检查已匹配的字符，而Boyer-Moore算法侧重于通过利用不匹配的信息来跳过尽可能多的字符。</li><li><strong>搜索方向</strong>：KMP从头至尾单向搜索，Boyer-Moore通常从尾至头逆向搜索。</li><li><strong>预处理</strong>：KMP算法预处理模式字符串，构造一个部分匹配表（也称为失败函数），而Boyer-Moore预处理坏字符表和好后缀表。</li><li><strong>性能</strong>：Boyer-Moore在实际应用中通常比KMP快，尤其是在模式字符串与目标文本匹</li></ul></blockquote><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_06_OmJlMk.gif" alt="boyerMooreStringSearch-2"></p><h3 id="rabin-karp-指纹字符串查找算法" tabindex="-1"><a class="header-anchor" href="#rabin-karp-指纹字符串查找算法" aria-hidden="true">#</a> Rabin-Karp 指纹字符串查找算法</h3><blockquote><p>Rabin-Karp 算法是一种用于字符串查找的算法，它通过哈希函数来避免在主文本字符串中检查每一个子串。这个算法由 Michael Rabin 和 Richard Karp 在 1987 年发明。</p><h3 id="核心思路-1" tabindex="-1"><a class="header-anchor" href="#核心思路-1" aria-hidden="true">#</a> 核心思路</h3><p>Rabin-Karp 算法的核心在于它使用了滚动哈希（也称为 Rabin 指纹）来快速筛选可能匹配的子串。</p><ol><li><strong>预处理：</strong> 首先计算模式串（待查找的字符串）的哈希值。</li><li><strong>滚动哈希：</strong> 对主文本进行遍历，计算每个与模式串长度相等的子串的哈希值。</li><li><strong>哈希比较：</strong> 如果某个子串的哈希值与模式串的哈希值相同，则进行进一步的逐字符比较来确认是否真的匹配。</li><li><strong>哈希更新：</strong> 当移动到下一个子串时，不需要重新计算整个子串的哈希值，而是可以通过去掉前一个字符的贡献，并添加新字符的贡献来更新哈希值。</li></ol><h3 id="优点-4" tabindex="-1"><a class="header-anchor" href="#优点-4" aria-hidden="true">#</a> 优点</h3><ol><li><strong>高效的最坏情况时间复杂度：</strong> Rabin-Karp 算法的最坏情况下的时间复杂度为 O(nm)，但平均情况下通常比直接的字符串比较方法要快。</li><li><strong>常数时间的滑动窗口更新：</strong> 由于其滚动哈希的特性，更新哈希值只需要常数时间。</li><li><strong>同时比较多个模式串：</strong> Rabin-Karp 可以被扩展用于同时查找多个模式串，因为它可以同时处理多个哈希值。</li><li><strong>检测两个字符串的相似度：</strong> 它也常用于检测两个字符串的相似度，例如在查重系统中。</li></ol><h3 id="缺点-4" tabindex="-1"><a class="header-anchor" href="#缺点-4" aria-hidden="true">#</a> 缺点</h3><ol><li><strong>哈希碰撞：</strong> 如果不同的子串可能产生相同的哈希值，这会导致算法误判并执行更多的逐字符比较。</li><li><strong>依赖于哈希函数：</strong> 哈希函数的选择对于避免冲突和保证算法的效率至关重要。</li><li><strong>最坏情况性能：</strong> 当所有哈希值都相同时（例如在有大量重复字符的文本中），算法的性能会退化到 O(nm)。</li></ol><h3 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h3><ol><li><strong>文本编辑器：</strong> 用于搜索文档中的字符串。</li><li><strong>数据比对：</strong> 如版本控制系统中比对文件的不同版本。</li><li><strong>防止抄袭：</strong> 检测文档中的剽窃情况。</li><li><strong>生物信息学：</strong> 搜索DNA序列中的模式。</li><li><strong>网络安全：</strong> 在一些网络安全应用中，如入侵检测系统中用于检测已知的恶意签名。</li></ol><p>综上所述，Rabin-Karp 算法由于其平均情况下较高的效率和对多模式串搜索的支持，在许多涉及字符串查找的应用中被广泛使用。然而，选择合适的哈希函数来降低哈希碰撞的几率是实现这个算法时需要特别注意的地方。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_07_whguCa.gif" alt="Rabin-Karp Pattern Matching Algorithm | by Utsav Poudel | Level Up Coding" style="zoom:80%;"><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_07_gHeYwg.jpg" alt="IMG_0554" style="zoom:50%;"><h2 id="_5-4-正则表达式" tabindex="-1"><a class="header-anchor" href="#_5-4-正则表达式" aria-hidden="true">#</a> 5.4 正则表达式</h2><blockquote><p>算法核心思路：</p><ol><li><strong>编译阶段</strong>: <ul><li>正则表达式首先被编译成一种内部表示，通常是一个状态机，比如确定性有限自动机（DFA）或非确定性有限自动机（NFA）。</li><li>每个符号或符号组合（如字符集、量词等）在这个状态机中都有一个相应的状态或状态集。</li></ul></li><li><strong>匹配阶段</strong>: <ul><li>文本字符串从左到右扫描。</li><li>对于每个字符，状态机尝试找到从当前状态通过该字符可以到达的下一个状态。</li><li>如果有状态转移，状态机进入下一个状态；如果没有，它尝试其他路径或报告匹配失败。</li></ul></li><li><strong>回溯</strong>: <ul><li>在使用NFA时，可能会存在多条路径可以匹配。</li><li>如果一个路径失败，算法将回溯到上一个决策点，并尝试另一条路径。</li></ul></li><li><strong>成功与失败</strong>: <ul><li>如果状态机到达一个接受状态，并且所有输入字符都被消耗，那么匹配成功。</li><li>如果没有路径能够消耗所有输入字符，那么匹配失败。</li></ul></li></ol></blockquote><h3 id="非确定有限状态自动机" tabindex="-1"><a class="header-anchor" href="#非确定有限状态自动机" aria-hidden="true">#</a> 非确定有限状态自动机</h3><p>正则表达式使用的是NFA（非确定有限状态自动机）。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_08_hxarOp.jpg" alt="IMG_0556" style="zoom:50%;"><p>当且仅当一个NFA从状态0开始从头读取了一段文本中的所有字符，进行了一系列状态转换并最终到达了接受状态时，称该NFA识别了一个文本字符串。</p><blockquote><p>确定有限状态自动机（DFA, Deterministic Finite Automaton）和非确定有限状态自动机（NFA, Nondeterministic Finite Automaton）是两种用来识别字符串是否属于某个特定语言的计算模型。尽管它们在理论上是等价的——它们识别的语言类别是相同的（即正则语言）——但是在定义和操作上有一些显著的差异。</p><h3 id="确定有限状态自动机-dfa" tabindex="-1"><a class="header-anchor" href="#确定有限状态自动机-dfa" aria-hidden="true">#</a> 确定有限状态自动机（DFA）</h3><p>在DFA中，对于每一个状态和输入符号，都有一个确定的状态转移。这意味着：</p><ol><li><strong>唯一性</strong>：对于自动机中的每一个状态和输入字母，都有一个且只有一个明确的转移状态。</li><li><strong>无ε转移</strong>：DFA中不允许使用ε转移，也就是说，不允许在没有输入符号的情况下进行状态转移。</li><li><strong>完备性</strong>：每个状态对于所有可能的输入符号都有一个转移状态定义。如果对于某个状态没有为某个输入定义下一个状态，那么这通常会被解释为转移到一个隐含的死状态，该状态不是接受状态，且从该状态出发没有任何转移能够到达接受状态。</li><li><strong>确定性</strong>：在任何时刻，自动机的下一个状态是唯一确定的。</li></ol><h3 id="非确定有限状态自动机-nfa" tabindex="-1"><a class="header-anchor" href="#非确定有限状态自动机-nfa" aria-hidden="true">#</a> 非确定有限状态自动机（NFA）</h3><p>NFA在定义上比DFA更为宽松，因为它允许：</p><ol><li><strong>多重性</strong>：对于自动机中的某些状态和输入字母，可能有多个或零个转移状态。</li><li><strong>ε转移</strong>：NFA允许ε转移，也就是说，自动机可以在没有输入符号的情况下进行状态转移。</li><li><strong>非完备性</strong>：并不要求每个状态对于所有可能的输入符号都有转移状态定义。如果没有定义转移，那么自动机在读入该符号时保持在原状态（不考虑ε转移）。</li><li><strong>非确定性</strong>：在任何时刻，自动机的下一个状态可能是不确定的，它可能根据当前状态和输入符号转移到多个不同的状态。</li></ol><h3 id="转换和等价性" tabindex="-1"><a class="header-anchor" href="#转换和等价性" aria-hidden="true">#</a> 转换和等价性</h3><p>尽管在定义和操作上DFA和NFA不同，但它们是等价的，因为任何NFA都可以被转换成一个识别同一语言的DFA。这个转换是通过所谓的子集构造法实现的，它可能会导致DFA的状态数呈指数级增长，因为DFA必须表示NFA中的所有可能状态组合。然而，对于任何给定的正则语言，都存在一个最小化的DFA，它的状态数是所有识别该语言的DFA中最少的。</p><p>简而言之，DFA和NFA在表达力上是相同的，但在实际构造和理解上有不同的便利性：DFA通常更易于实现（比如在硬件中），而NFA则通常更简洁易于构造，特别是在正则表达式转换为自动机的情况下。</p></blockquote><h3 id="模拟nfa运行" tabindex="-1"><a class="header-anchor" href="#模拟nfa运行" aria-hidden="true">#</a> 模拟NFA运行</h3><p>用<strong>有向图</strong>来表示自动机。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_09_g2eFi7.jpg" alt="IMG_0558" style="zoom:50%;"><h3 id="构造与正则表达式对应的nfa" tabindex="-1"><a class="header-anchor" href="#构造与正则表达式对应的nfa" aria-hidden="true">#</a> 构造与正则表达式对应的NFA</h3><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_10_L2VV5c.jpg" alt="IMG_0559" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_10_hZt42B.jpg" alt="IMG_0559 2" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_10_XEibiK.jpg" alt="IMG_0560" style="zoom:50%;"><h2 id="_5-5-数据压缩" tabindex="-1"><a class="header-anchor" href="#_5-5-数据压缩" aria-hidden="true">#</a> 5.5 数据压缩</h2><p>压缩数据的原因：</p><ul><li>节省保存信息所需的空间；</li><li>节省传输信息所需的时间。</li></ul><p>任何数据压缩算法的效果都十分依赖输入的特征。</p><blockquote><p>数据压缩是一种减少数据表示所需位数（bits）的技术，以减少存储空间和提高数据传输效率。数据压缩可分为两类：无损压缩和有损压缩。</p><ol><li><p><strong>无损压缩</strong>：在这种方法中，原始数据可以从压缩数据完全恢复。无损压缩技术适用于文本、程序代码和某些类型的图像和音频文件。常见的无损压缩算法包括哈夫曼编码、LZ77、LZ78及其变体（如LZW算法）。</p></li><li><p><strong>有损压缩</strong>：与无损压缩不同，有损压缩在压缩过程中会丢失一些原始数据，因此无法完全还原原始数据。这种方法通常用于视频和音频数据，其中一些数据的丢失不会显著影响用户体验。JPEG（用于图像）和MP3（用于音频）是常见的有损压缩格式。</p></li></ol><p>数据压缩的基本思想是去除或减少数据中的冗余。在文本文件中，这可能意味着替换重复出现的字符串；在图像文件中，可能意味着减少颜色的精确度或去除人眼不容易察觉的细节。</p><p>数据压缩对于存储和传输大量数据非常重要，尤其是在网络带宽有限或存储成本较高的情况下。然而，需要注意的是，压缩效率和数据质量之间往往存在权衡。有损压缩虽然可以实现更高的压缩率，但可能会牺牲数据的一部分质量。无损压缩则保留了数据的完整性，但压缩比通常低于有损压缩。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_12_9THshU.png" alt="1699796467676" style="zoom:15%;"><h3 id="局限" tabindex="-1"><a class="header-anchor" href="#局限" aria-hidden="true">#</a> 局限</h3><p>通用性的数据压缩是不可能存在的。</p><p>数据流的已知结构：</p><ul><li>小规模的字母表；</li><li>较长的连续相同的位或字符；</li><li>频繁使用的字符；</li><li>较长的连续重复的位或字符。</li></ul><h3 id="游程编码" tabindex="-1"><a class="header-anchor" href="#游程编码" aria-hidden="true">#</a> 游程编码</h3><blockquote><p>游程编码（Run-Length Encoding, RLE）是一种简单的数据压缩技术，主要用于压缩包含大量连续重复数据的数据流。它通过将连续重复的数据元素替换为单个数据值和该值的重复次数来减少数据大小。这种技术在处理具有大量相同值的连续区域的数据（如单色位图图像）时特别有效。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h3><p>在游程编码中，连续出现的相同数据值被替换为两部分：一个是数据值本身，另一个是这个值重复的次数（称为“游程长度”）。例如，序列 &quot;AAAABBBCCDAA&quot; 可以被编码为 &quot;4A3B2C1D2A&quot;，表示字符 &#39;A&#39; 连续出现了 4 次，字符 &#39;B&#39; 连续出现了 3 次，依此类推。</p><h3 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h3><ol><li><p><strong>图像压缩</strong>：在图像处理中，特别是在处理不含太多细节的单色图像时，游程编码被广泛使用。例如，在扫描文档或简单的线条艺术中，游程编码可以有效地减少文件大小。</p></li><li><p><strong>数据传输</strong>：在某些数据传输应用中，尤其是当传输的数据包含大量重复信息时，使用游程编码可以减少所需的带宽。</p></li></ol><h3 id="局限性" tabindex="-1"><a class="header-anchor" href="#局限性" aria-hidden="true">#</a> 局限性</h3><ol><li><p><strong>不适用于高熵数据</strong>：对于缺乏重复或具有高度随机性的数据（即高熵数据），游程编码可能不仅无法有效压缩数据，甚至可能导致数据膨胀。</p></li><li><p><strong>简单性限制</strong>：游程编码是一种非常基础的压缩技术，它没有利用更高级的模式识别或预测算法，因此在许多复杂的数据集上效果有限。</p></li><li><p><strong>特定应用场景</strong>：由于其特性，游程编码主要适用于某些特定类型的数据，如某些类型的图像或简单文本文件，而不适用于音频、视频或大多数类型的文档数据。</p></li></ol><p>总的来说，虽然游程编码在某些应用中非常有效，但它是一种有其特定适用范围的压缩技术，对于复杂或高熵的数据集效果有限。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_13_78v702.jpg" alt="IMG_0584" style="zoom:50%;"><h3 id="霍夫曼压缩" tabindex="-1"><a class="header-anchor" href="#霍夫曼压缩" aria-hidden="true">#</a> 霍夫曼压缩</h3><blockquote><p>霍夫曼编码（Huffman Coding）是一种广泛使用的无损数据压缩算法，由大卫·霍夫曼（David Huffman）在1952年提出。它是一种基于数据字符出现频率进行编码的算法，通常用于文本和图像压缩。霍夫曼编码的核心思想是使用较短的位序列表示频繁出现的字符，而用较长的位序列表示不常出现的字符。</p><h3 id="工作原理-1" tabindex="-1"><a class="header-anchor" href="#工作原理-1" aria-hidden="true">#</a> 工作原理</h3><ol><li><p><strong>频率分析</strong>：首先分析数据集中各个字符的出现频率。</p></li><li><p><strong>构建霍夫曼树</strong>：基于字符频率构建一个二叉树，其中每个叶子节点代表一个字符。树的构建过程是从叶子节点开始，将频率最低的两个节点组合成一个新节点，这个新节点的频率是它的两个子节点频率之和。重复这个过程直到构建出一个完整的树。</p></li><li><p><strong>生成编码</strong>：根据霍夫曼树为每个字符生成一个唯一的二进制编码。从根节点到叶子节点的每一步，向左走代表0，向右走代表1。因此，频繁出现的字符将有更短的编码路径。</p></li><li><p><strong>编码原始数据</strong>：使用生成的编码替换原始数据中的每个字符。</p></li><li><p><strong>解码</strong>：接收方可以使用相同的霍夫曼树来解码接收到的二进制数据，恢复原始数据。</p></li></ol><h3 id="应用-1" tabindex="-1"><a class="header-anchor" href="#应用-1" aria-hidden="true">#</a> 应用</h3><p>霍夫曼编码在多种数据压缩应用中被广泛使用，包括文件压缩（如ZIP文件格式）和图像压缩（如JPEG格式的一部分）。它也常与其他压缩算法结合使用，以优化压缩效果。</p><h3 id="局限性-1" tabindex="-1"><a class="header-anchor" href="#局限性-1" aria-hidden="true">#</a> 局限性</h3><ol><li><p><strong>预处理开销</strong>：霍夫曼编码需要先分析整个数据集来构建霍夫曼树，这可能会导致额外的计算开销，尤其是对于大型数据集。</p></li><li><p><strong>不适合非重复数据</strong>：对于没有明显频率差异的数据或高熵数据，霍夫曼编码的压缩效果有限。</p></li><li><p><strong>动态数据问题</strong>：对于实时或动态变化的数据，不断更新霍夫曼树可能会导致效率低下。</p></li></ol><p>尽管存在这些局限性，霍夫曼编码仍是一种高效且广泛应用的无损压缩技术。</p></blockquote><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220906180456/6.png" alt="Huffman Coding | Greedy Algo-3 - GeeksforGeeks" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_13_QNnyYS.jpg" alt="IMG_0585" style="zoom:50%;"><p>单词查找树构建：</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_13_0MXS6T.gif" alt="File:Huffman huff demo.gif - Wikimedia Commons"></p><h3 id="lzw压缩算法" tabindex="-1"><a class="header-anchor" href="#lzw压缩算法" aria-hidden="true">#</a> LZW压缩算法</h3><blockquote><p>LZW（Lempel-Ziv-Welch）压缩是一种流行且高效的无损数据压缩算法，由阿布拉罕·莱赫尔（Abraham Lempel）、雅各布·齐夫（Jacob Ziv）和特里·韦尔奇（Terry Welch）开发。LZW算法在1980年代初期被发明，并被广泛用于各种文件和图像格式，如GIF和TIFF。</p><h3 id="工作原理-2" tabindex="-1"><a class="header-anchor" href="#工作原理-2" aria-hidden="true">#</a> 工作原理</h3><p>LZW压缩的核心思想是将输入数据流中的字符串序列替换为较短的代码。它通过构建一个从输入数据中学习的字符串字典来实现这一点，这个字典在压缩过程中动态生成。算法的基本步骤如下：</p><ol><li><p><strong>初始化字典</strong>：LZW算法开始时，字典被初始化为所有可能的单字符字符串。</p></li><li><p><strong>处理输入数据</strong>：算法逐个读取输入数据中的字符，并尝试在字典中找到最长的匹配字符串。</p></li><li><p><strong>更新字典</strong>：每次找到匹配时，算法将匹配字符串后的下一个字符加入到字典中，作为新的字符串序列。</p></li><li><p><strong>输出代码</strong>：对于每个找到的匹配字符串，算法输出代表该字符串的字典索引。</p></li><li><p><strong>重复</strong>：重复这个过程直到整个输入数据被处理完毕。</p></li></ol><h3 id="应用-2" tabindex="-1"><a class="header-anchor" href="#应用-2" aria-hidden="true">#</a> 应用</h3><p>LZW算法由于其高效的压缩率和简单的实现，被广泛应用于多种文件压缩和图像压缩格式。最著名的应用之一是GIF图像格式，LZW算法使得GIF在网络上的传输变得更加高效。</p><h3 id="局限性-2" tabindex="-1"><a class="header-anchor" href="#局限性-2" aria-hidden="true">#</a> 局限性</h3><ol><li><p><strong>专利问题</strong>：LZW算法曾经受到专利保护，这限制了它的广泛应用。尽管这些专利现在已经过期，但在专利有效期间，这是一个重要的限制因素。</p></li><li><p><strong>不适用于所有类型的数据</strong>：对于一些没有明显重复模式的数据（如已经压缩过的数据），LZW压缩的效率可能不是很高。</p></li><li><p><strong>内存使用</strong>：由于字典的动态生成，LZW算法可能需要相对较多的内存来存储这些字典条目，尤其是在处理大型数据集时。</p></li></ol><p>尽管有这些局限性，LZW压缩算法因其平衡的性能和效率，在数据压缩领域仍然占有一席之地。</p></blockquote><p>压缩</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_14_TQCwGL.png" alt="LZW (Lempel–Ziv–Welch) Compression technique - GeeksforGeeks" style="zoom:50%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_14_Gdtfaz.jpg" alt="IMG_0587" style="zoom:50%;"><p>展开</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_14_IPVwFO.jpg" alt="IMG_0588" style="zoom:50%;"><h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h3><blockquote><h3 id="游程编码-rle" tabindex="-1"><a class="header-anchor" href="#游程编码-rle" aria-hidden="true">#</a> 游程编码 (RLE)</h3><ul><li><strong>基本原理</strong>：将连续重复的数据用一个计数和该数据值来表示。例如，“AAAABBB”编码为“4A3B”。</li><li><strong>优点</strong>：实现简单，对于具有大量连续重复数据的场景（如某些类型的图像）效果很好。</li><li><strong>缺点</strong>：对于数据中重复较少或完全没有重复的数据效果不佳。</li><li><strong>适用场景</strong>：单色图像、简单的图形数据。</li></ul><h3 id="霍夫曼编码" tabindex="-1"><a class="header-anchor" href="#霍夫曼编码" aria-hidden="true">#</a> 霍夫曼编码</h3><ul><li><strong>基本原理</strong>：基于字符频率进行变长编码。频繁出现的字符使用较短的编码，不频繁的使用较长的编码。</li><li><strong>优点</strong>：为不均匀分布的数据提供了很好的压缩效果，无损压缩，保留了原始数据的完整性。</li><li><strong>缺点</strong>：需要先分析整个数据集来构建编码树，对于实时压缩或数据流压缩可能不太适用。</li><li><strong>适用场景</strong>：文本数据、任何需要无损压缩的场景。</li></ul><h3 id="lzw压缩" tabindex="-1"><a class="header-anchor" href="#lzw压缩" aria-hidden="true">#</a> LZW压缩</h3><ul><li><strong>基本原理</strong>：动态构建一个字符串字典，将输入数据中的字符串序列替换为较短的代码。</li><li><strong>优点</strong>：不需要知道数据的先验统计信息，适合于动态数据和实时压缩，广泛应用于各种文件格式。</li><li><strong>缺点</strong>：对于已经高度压缩的数据或非常随机的数据，压缩效率可能不高。</li><li><strong>适用场景</strong>：图像文件（如GIF）、一些文档文件格式。</li></ul><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h3><ul><li><strong>游程编码</strong>简单直观，适用于连续重复数据较多的场景。</li><li><strong>霍夫曼编码</strong>提供有效的无损压缩，特别适合非均匀分布的数据，如文本。</li><li><strong>LZW压缩</strong>适合广泛的应用，特别是在不需要先验数据分析的场景中表现良好。</li></ul></blockquote><h1 id="第6章-背景" tabindex="-1"><a class="header-anchor" href="#第6章-背景" aria-hidden="true">#</a> 第6章 背景</h1><h2 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B-树</h2><p>定义：B树是2-3树的扩展。对于M阶的B树，每个节点最多含有M-1对键和链接，最少含有M/2对键和链接。根结点除外。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_15_e9afQ1.jpg" alt="IMG_0591" style="zoom:50%;"><blockquote><p>B树和2-3树都是自平衡的搜索树结构，但它们在结构和操作上有一些关键的区别：</p><ol><li><p><strong>节点的子树数量</strong>:</p><ul><li><strong>B树</strong>：B树的节点可以有多个子树，其中节点的子树数量受到树的度数 ( T ) 的限制。对于度数为 ( T ) 的B树，每个节点最多有 ( 2T-1 ) 个键和 ( 2T ) 个子节点。</li><li><strong>2-3树</strong>：2-3树是B树的一个特例，具体是一个度数为2的B树。它的每个节点可以有2个或3个子节点（即节点可以是2-节点或3-节点）。2-节点包含一个键和两个子节点，而3-节点包含两个键和三个子节点。</li></ul></li><li><p><strong>键的数量和节点类型</strong>:</p><ul><li><strong>B树</strong>：B树的节点可以有不同数量的键，取决于树的度数。</li><li><strong>2-3树</strong>：2-3树的节点要么有一个键（2-节点），要么有两个键（3-节点）。</li></ul></li><li><p><strong>平衡操作</strong>:</p><ul><li><strong>B树</strong>：当插入或删除操作导致节点键的数量超出或低于允许的范围时，B树通过分裂过满的节点或合并/借用键来自平衡。</li><li><strong>2-3树</strong>：2-3树也通过分裂和合并节点来保持平衡，但其操作相对简单，因为节点类型只有两种。</li></ul></li><li><p><strong>应用场景</strong>:</p><ul><li><strong>B树</strong>：由于其灵活性和能够处理更高度数的节点，B树在实际应用中更为常见，尤其是在数据库和文件系统的索引结构中。</li><li><strong>2-3树</strong>：2-3树通常用于教学和理论研究，因为它提供了B树的一个简化模型。</li></ul></li></ol><p>总结来说，虽然2-3树可以看作是B树的一种特殊形式，但B树提供了更高的灵活性和适应性，使其更适合于处理大量数据的实际应用。</p></blockquote><p>插入</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_15_zZqKCu.jpg" alt="IMG_0592" style="zoom:50%;"><h2 id="后缀数组" tabindex="-1"><a class="header-anchor" href="#后缀数组" aria-hidden="true">#</a> 后缀数组</h2><blockquote><p>后缀数组（Suffix Array）是一种在字符串处理中非常重要的数据结构，它为给定字符串的所有后缀创建了一个有序数组。具体来说，对于一个字符串 ( S )，其后缀数组是一个整数数组 ( SA )，其中 ( SA[i] ) 表示在按字典序排序的 ( S ) 的所有后缀中排名为 ( i ) 的后缀的起始位置。</p><p>后缀数组通常与后缀树结合使用，因为它们能够更有效地占用存储空间，同时提供类似的功能。后缀数组的构建通常通过更复杂的后缀树来完成，然后将后缀树转换为后缀数组。</p><p>后缀数组的应用非常广泛，主要包括：</p><ol><li><strong>字符串搜索</strong>：后缀数组可以用来快速查找一个字符串是否为另一个字符串的子串。</li><li><strong>字符串比较</strong>：可以使用后缀数组快速比较两个字符串。</li><li><strong>最长公共前缀（LCP）</strong>：通过后缀数组，可以高效地计算两个后缀的最长公共前缀。</li><li><strong>数据压缩</strong>：在某些数据压缩算法中，后缀数组被用来找到重复的字符串，以减少存储空间。</li><li><strong>生物信息学</strong>：在基因序列分析中，后缀数组被用于快速匹配DNA序列。</li></ol><p>构建后缀数组是一个复杂的过程，通常涉及对字符串的所有后缀进行排序。高效的后缀数组构建算法如SA-IS、DC3等，可以在 ( O(n) ) 或 ( O(n \log n) ) 时间内完成，其中 ( n ) 是字符串的长度。</p></blockquote><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_20_6q8h1y.jpg" alt="IMG_0629" style="zoom:50%;"><h2 id="网络流算法" tabindex="-1"><a class="header-anchor" href="#网络流算法" aria-hidden="true">#</a> 网络流算法</h2><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_20_7rbJDs.jpg" alt="IMG_0630" style="zoom:50%;"><blockquote><p>定义：一个网络流量是一张边的权重为正的加权有向图。一个st-流量网络有两个已知的顶点，即起点s和终点t。</p></blockquote><h3 id="ford-fulkerson算法" tabindex="-1"><a class="header-anchor" href="#ford-fulkerson算法" aria-hidden="true">#</a> Ford-Fulkerson算法</h3><p>Ford-Fulkerson算法，也被称为<strong>增广路径算法</strong>。</p><blockquote><p><strong>算法思路</strong></p><ol><li><strong>初始化</strong>：最初，假设网络中的流量为零。</li><li><strong>寻找增广路径</strong>：使用深度优先搜索（DFS）或广度优先搜索（BFS）在剩余网络中寻找从源点到汇点的路径。剩余网络是指原网络减去已有流量的网络。</li><li><strong>流量调整</strong>：沿着找到的增广路径，计算可以增加的最大流量（即该路径上最小的剩余容量）。</li><li><strong>更新流量</strong>：更新网络中的流量，增加找到的路径上的流量，同时减少相应的反向边上的流量（如果有的话）。</li><li><strong>重复</strong>：重复步骤2到4，直到无法再找到增广路径为止。</li><li><strong>输出最大流</strong>：此时网络中的流量配置就是最大流。</li></ol></blockquote><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_20_ryQxI5.gif" alt="File:FordFulkerson.gif - Wikimedia Commons"></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2023_11_20_oKOrl3.gif" alt="File:FordFulkersonDemo.gif - Wikipedia" style="zoom:50%;"><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: czl624824554@163.com">chenzilin</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog-site/assets/app.5b55431a.js" defer></script>
  </body>
</html>
