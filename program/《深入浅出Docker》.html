<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/blog-site/578220.ico"><title>第一部分 Docker概览 | Leon Chen</title><meta name="description" content="">
    <link rel="modulepreload" href="/blog-site/assets/app.5b55431a.js"><link rel="modulepreload" href="/blog-site/assets/《深入浅出Docker》.html.ddf3b9d5.js"><link rel="modulepreload" href="/blog-site/assets/《深入浅出Docker》.html.bea35ce8.js"><link rel="modulepreload" href="/blog-site/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blog-site/assets/style.5c2fd74e.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog-site/" class=""><img class="logo" src="/blog-site/578220.png" alt="Leon Chen"><span class="site-name can-hide">Leon Chen</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程书籍笔记"><!--[--><!--]--> 编程书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外书籍笔记"><!--[--><!--]--> 课外书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="编程疑问清单"><!--[--><!--]--> 编程疑问清单 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/leetcode" class="" aria-label="LeetCode题解"><!--[--><!--]--> LeetCode题解 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog-site/program" class="router-link-active" aria-label="编程书籍笔记"><!--[--><!--]--> 编程书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/promote" class="" aria-label="课外书籍笔记"><!--[--><!--]--> 课外书籍笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/questions" class="" aria-label="编程疑问清单"><!--[--><!--]--> 编程疑问清单 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog-site/leetcode" class="" aria-label="LeetCode题解"><!--[--><!--]--> LeetCode题解 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">第一部分 Docker概览 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第1章-容器发展之路" class="router-link-active router-link-exact-active sidebar-item" aria-label="第1章 容器发展之路"><!--[--><!--]--> 第1章 容器发展之路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第2章-走进docker" class="router-link-active router-link-exact-active sidebar-item" aria-label="第2章 走进Docker"><!--[--><!--]--> 第2章 走进Docker <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#docker" class="router-link-active router-link-exact-active sidebar-item" aria-label="Docker"><!--[--><!--]--> Docker <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#docker运行时与编排引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="Docker运行时与编排引擎"><!--[--><!--]--> Docker运行时与编排引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#开放容器计划" class="router-link-active router-link-exact-active sidebar-item" aria-label="开放容器计划"><!--[--><!--]--> 开放容器计划 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第3章-docker安装" class="router-link-active router-link-exact-active sidebar-item" aria-label="第3章 Docker安装"><!--[--><!--]--> 第3章 Docker安装 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#docker引擎-engine-升级" class="router-link-active router-link-exact-active sidebar-item" aria-label="Docker引擎（Engine）升级"><!--[--><!--]--> Docker引擎（Engine）升级 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#docker存储驱动的选择" class="router-link-active router-link-exact-active sidebar-item" aria-label="Docker存储驱动的选择"><!--[--><!--]--> Docker存储驱动的选择 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第4章-纵观docker" class="router-link-active router-link-exact-active sidebar-item" aria-label="第4章 纵观Docker"><!--[--><!--]--> 第4章 纵观Docker <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#运维视角" class="router-link-active router-link-exact-active sidebar-item" aria-label="运维视角"><!--[--><!--]--> 运维视角 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#开发视角" class="router-link-active router-link-exact-active sidebar-item" aria-label="开发视角"><!--[--><!--]--> 开发视角 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第5章-docker引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="第5章 Docker引擎"><!--[--><!--]--> 第5章 Docker引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第6章-docker镜像" class="router-link-active router-link-exact-active sidebar-item" aria-label="第6章 Docker镜像"><!--[--><!--]--> 第6章 Docker镜像 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#docker镜像" class="router-link-active router-link-exact-active sidebar-item" aria-label="Docker镜像"><!--[--><!--]--> Docker镜像 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#镜像和分层" class="router-link-active router-link-exact-active sidebar-item" aria-label="镜像和分层"><!--[--><!--]--> 镜像和分层 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第7章-docker-容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="第7章 Docker 容器"><!--[--><!--]--> 第7章 Docker 容器 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#容器进程" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器进程"><!--[--><!--]--> 容器进程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#容器生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器生命周期"><!--[--><!--]--> 容器生命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#利用重启策略进行容器的自我修复" class="router-link-active router-link-exact-active sidebar-item" aria-label="利用重启策略进行容器的自我修复"><!--[--><!--]--> 利用重启策略进行容器的自我修复 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#容器——命令" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器——命令"><!--[--><!--]--> 容器——命令 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第8章-应用的容器化" class="router-link-active router-link-exact-active sidebar-item" aria-label="第8章 应用的容器化"><!--[--><!--]--> 第8章 应用的容器化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#单体应用容器化" class="router-link-active router-link-exact-active sidebar-item" aria-label="单体应用容器化"><!--[--><!--]--> 单体应用容器化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#生产环境的多阶段构建" class="router-link-active router-link-exact-active sidebar-item" aria-label="生产环境的多阶段构建"><!--[--><!--]--> 生产环境的多阶段构建 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#最佳实践" class="router-link-active router-link-exact-active sidebar-item" aria-label="最佳实践"><!--[--><!--]--> 最佳实践 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第9章-使用-docker-compose-部署" class="router-link-active router-link-exact-active sidebar-item" aria-label="第9章 使用 Docker Compose 部署"><!--[--><!--]--> 第9章 使用 Docker Compose 部署 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#背景" class="router-link-active router-link-exact-active sidebar-item" aria-label="背景"><!--[--><!--]--> 背景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#compose文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="Compose文件"><!--[--><!--]--> Compose文件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#使用-docker-compose-管理应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用 Docker Compose 管理应用"><!--[--><!--]--> 使用 Docker Compose 管理应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#命令" class="router-link-active router-link-exact-active sidebar-item" aria-label="命令"><!--[--><!--]--> 命令 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第10章-docker-swarm" class="router-link-active router-link-exact-active sidebar-item" aria-label="第10章 Docker Swarm"><!--[--><!--]--> 第10章 Docker Swarm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-site/program/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E3%80%8B.html#第11章-docker网络" class="router-link-active router-link-exact-active sidebar-item" aria-label="第11章 Docker网络"><!--[--><!--]--> 第11章 Docker网络 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="第一部分-docker概览" tabindex="-1"><a class="header-anchor" href="#第一部分-docker概览" aria-hidden="true">#</a> 第一部分 Docker概览</h1><h2 id="第1章-容器发展之路" tabindex="-1"><a class="header-anchor" href="#第1章-容器发展之路" aria-hidden="true">#</a> 第1章 容器发展之路</h2><p><strong>虚拟机</strong>是一种具有划时代意义的技术。</p><p>虚拟机的缺点：虚拟机依赖其专用的操作系统（OS），OS会占用额外的CPU、RAM和存储，这些资源本可以用于运行更多的应用。虚拟机的启动通常比较慢，可移植性也比较差。</p><p><strong>容器</strong>跟<strong>虚拟机</strong>的区别是容器运行不会独占操作系统，这样能节省大量的系统资源。容器具有启动快和便于迁移等优势。</p><p><strong>容器</strong>技术起源于<strong>Linux</strong>，<strong>容器</strong>技术的复杂度是阻止其实际应用的主要原因，直到<strong>Docker</strong>技术横空出世，<strong>容器</strong>才真正被大众所接受。</p><p><strong>Windows容器</strong>已经支持在Windows10以上平台使用，Docker在Windows平台上的使用体验上跟在Linux几乎一致。</p><p>运行中的容器共享宿主机的内核，所以Windows容器化应用无法再Linux主机上运行，同样Linux容器化应用也无法在Windows主机上运行。（最新版的Docker可能可以）</p><p><strong>Mac容器</strong>目前还没出现，但可以使用Docker of Mac来运行Linux容器，这是通过在Mac启动一个轻量级Linux VM，然后再其中无缝地运行Linux容器来实现。</p><p><strong>Kubernetes</strong>是谷歌的一个开源项目，简称<strong>K8S</strong>，<strong>Kubernetes</strong>是保证容器部署和运行的软件体系中很重要的一部分。<strong>Kubernetes</strong>已经采用<strong>Docker</strong>作为默认容器运行时。</p><h2 id="第2章-走进docker" tabindex="-1"><a class="header-anchor" href="#第2章-走进docker" aria-hidden="true">#</a> 第2章 走进Docker</h2><h3 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h3><p>Docker是一种运行与Linux和Windows上的软件，用于创建、管理和编排容器。Docker是在Github上开发的Moby开源项目的一部分。</p><h3 id="docker运行时与编排引擎" tabindex="-1"><a class="header-anchor" href="#docker运行时与编排引擎" aria-hidden="true">#</a> Docker运行时与编排引擎</h3><p>Docker引擎是用于<strong>运行和编排容器</strong>的基础设施工具。Docker引擎是运行容器的核心容器运行时。</p><h3 id="开放容器计划" tabindex="-1"><a class="header-anchor" href="#开放容器计划" aria-hidden="true">#</a> 开放容器计划</h3><p>开放容器计划（OCI）在对容器基础架构中的基础组件进行标准化的管理委员会。</p><h2 id="第3章-docker安装" tabindex="-1"><a class="header-anchor" href="#第3章-docker安装" aria-hidden="true">#</a> 第3章 Docker安装</h2><p>Windows版Docker是社区版本（Community Edition，CE）。</p><p>Mac版Docker的Docker daemon（称为Docker引擎或Docker服务端）是运行在一个轻量级的Linux VM之上的。</p><p>Windows版Docker和Mac版Docker安装了包括Docker引擎、Docker Compose、Docker Machine以及Docker Notary命令行。</p><p>Linux版Docker提供社区版本和企业版本（Enterprise Edition，EE）。</p><p>Linux版安装，运行<code>wget -qO- https://get/docker.com/ || sh</code>，安装之后将用户移到docker组，<code>sudo usermod -aG docker your-user</code>。</p><h3 id="docker引擎-engine-升级" tabindex="-1"><a class="header-anchor" href="#docker引擎-engine-升级" aria-hidden="true">#</a> Docker引擎（Engine）升级</h3><p>Linux上升级</p><ol><li><p>更新apt包</p><p><code>apt-get update</code></p></li><li><p>卸载当前Docker</p><p><code>apt-get remove docker docker-engine docker-ce docker.io -y</code></p></li><li><p>安装新版本Docker</p><p><code>wget -qO- https://get/docker.com/ || sh</code></p></li><li><p>将Docker配置为开机自启动</p><p><code>systemctl enable docker</code></p></li></ol><h3 id="docker存储驱动的选择" tabindex="-1"><a class="header-anchor" href="#docker存储驱动的选择" aria-hidden="true">#</a> Docker存储驱动的选择</h3><p>每个Docker容器都有一个本地存储空间，用于保存层叠的<strong>镜像层</strong>（Image Layer）以及挂载的容器文件系统。默认情况下，容器的所有读写操作都发生在其镜像层上或挂载的文件系统中，所以存储是每个容器的性能和稳定性不可或缺的一个环节。</p><p>在Linux上，Docker可选择的一些存储驱动包括<strong>AUFS</strong>（最原始也是最老的）、<strong>Overlay2</strong>（可能是未来的最佳选择）、<strong>Device Mapper</strong>、<strong>Btrfs</strong>和<strong>ZFS</strong>。</p><p>Docker在Windows系统上只支持一种存储驱动，Windows Filter。</p><p>查看当前的存储驱动类型：<code>docker system info</code>。Storage Driver 字段显示的当前的驱动类型。</p><h4 id="device-mapper-配置" tabindex="-1"><a class="header-anchor" href="#device-mapper-配置" aria-hidden="true">#</a> Device Mapper 配置</h4><p>Device Mapper 存储驱动默认采用loopback mounted sparse file作为底层实现来为Docker提供存储支持。默认方式的性能很差，并不支持生产环境。</p><p>为了达到Device Mapper在生产环境中的最佳性能，需要将底层修改为direct-lvm模式。</p><h2 id="第4章-纵观docker" tabindex="-1"><a class="header-anchor" href="#第4章-纵观docker" aria-hidden="true">#</a> 第4章 纵观Docker</h2><p>Play With Docker(PWD)是一个基于Web界面的Docker环境，并且可以免费使用。</p><h3 id="运维视角" tabindex="-1"><a class="header-anchor" href="#运维视角" aria-hidden="true">#</a> 运维视角</h3><p>Docker分为两个主要组件：Docker客户端和Docker daemon。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_03_qxfzPF.png" alt="2022_08_03_qxfzPF" style="zoom:67%;"><h4 id="镜像" tabindex="-1"><a class="header-anchor" href="#镜像" aria-hidden="true">#</a> 镜像</h4><p>将Docker镜像理解为一个包含OS文件系统和应用的对象，或者将镜像理解为一个类（Class），镜像实际上等价于未运行的容器。</p><p>Docker主机上获取镜像的操作被称为拉取（pulling）。在Linux中，拉取ubuntu:latest镜像，使用<code>docker image pull ubuntu:latest</code>命令。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_03_flAJWD.png" alt="2022_08_03_flAJWD" style="zoom:67%;"><p>拉取的ubuntu镜像有一个精简版的Ubuntu Linux文件系统，包含部分Ubuntu常用工具。如果拉取了如nginx或microsoft/iss这样的应用容器，则会得到一个包含操作系统的镜像，镜像中还包括运行Nginx或IIS所需的代码。</p><p>Docker的每个镜像都有自己的唯一ID。可以通过引用镜像的ID或名称来使用镜像。</p><h4 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h4><p>可以使用<code>docker container run</code>从镜像来启动容器，<code>docker container run -it ubuntu:latest /bin/bash</code>在Linux中启动容器，其中<code>-it</code>参数告诉Docker开启容器的交互模式并将读者当前的Shell连接到容器端，接下来<code>unbunt:latest</code>告诉Docker用户想基于<code>unbunt:latest</code>镜像启动容器，最后告诉Docker用户想在容器内部运行哪个进程，上面写的是<code>bash shell</code>进程。</p><p>按<code>Ctril+P+Q</code>可以退出容器并保持容器运行。<code>docker container ls</code>查看系统内全部处于运行状态的容器，加上<code>-a</code>选项可以查看所有包括停止中的容器。</p><h4 id="连接到运行中的容器" tabindex="-1"><a class="header-anchor" href="#连接到运行中的容器" aria-hidden="true">#</a> 连接到运行中的容器</h4><p><code>docker container exec</code>命令将Shell连接到一个运行中的容器终端。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_03_2JTWYy.png" alt="2022_08_03_2JTWYy" style="zoom:67%;"><p><code>docker container stop</code>命令停止容器，<code>docker container rm</code>命令杀死容器。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_03_MBiGkv.png" alt="2022_08_03_MBiGkv" style="zoom:67%;"><h3 id="开发视角" tabindex="-1"><a class="header-anchor" href="#开发视角" aria-hidden="true">#</a> 开发视角</h3><p><code>Dockerfile</code>是一个纯文本文件，其中描述如何将应用构建到Docker镜像当中。<code>Dockerfile</code>每一行都代表一个用于构建镜像的指令。</p><div class="language-docker ext-docker line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;"># Test web-app to use with Pluralsight courses and Docker Deep Dive book</span></span>
<span class="line"><span style="color:#616E88;"># Linux x64</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> alpine</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">LABEL</span><span style="color:#D8DEE9FF;"> maintainer=</span><span style="color:#A3BE8C;">&quot;nigelpoulton@hotmail.com&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Install Node and NPM</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> apk add --update nodejs npm curl</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Copy app to /src</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> . /src</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /src</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Install dependencies</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;">  npm install</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">EXPOSE</span><span style="color:#D8DEE9FF;"> 8080</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81A1C1;">ENTRYPOINT</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#A3BE8C;">&quot;node&quot;</span><span style="color:#D8DEE9FF;">, </span><span style="color:#A3BE8C;">&quot;./app.js&quot;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>使用<code>docker image build</code>命令根据<code>Dockerfile</code>中的指令来创建新的镜像。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_04_76Kcrd.png" alt="2022_08_04_76Kcrd" style="zoom:67%;"><h1 id="第二部分-docker技术" tabindex="-1"><a class="header-anchor" href="#第二部分-docker技术" aria-hidden="true">#</a> 第二部分 Docker技术</h1><h2 id="第5章-docker引擎" tabindex="-1"><a class="header-anchor" href="#第5章-docker引擎" aria-hidden="true">#</a> 第5章 Docker引擎</h2><p>Docker引擎是用来运行和管理容器的核心软件。Docker引擎由许多专用的工具协同工作，从而可以创建和运行容器，例如API、执行驱动、运行时、shim进程等。</p><p>Docker引擎由如下的主要的组件构成：Docker客户端（Docker Client）、Docker守护进程（Docker daemon）、containerd以及runc。它们共同负责容器的创建和运行。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_04_IMG_6664.jpg" alt="2022_08_04_IMG_6664" style="zoom:67%;"><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_04_IMG_6665.jpg" alt="2022_08_04_IMG_6665" style="zoom:50%;"><p><strong>runc</strong>是OCI容器运行时规范的参考实现。runc只有一个作用——创建容器，runc基于Libcontainer。</p><p><strong>containerd</strong>的主要任务是管理容器的生命周期——start|stop|pause|rm...</p><p>执行<code>docker container run --name ctrl -it alpine:latest sh</code>时，Docker客户端会将其转换为合适的API格式，并发生到正确的API端点。API是在<strong>daemon</strong>中实现的，一旦<strong>daemon</strong>接受到创建容器的命令，它就会像<strong>containerd</strong>发出调用。<strong>containerd</strong>将Docker镜像转换为OCI bundle，并让<strong>runc</strong>基于此创建一个新的容器，<strong>runc</strong>与操作系统内核接口进行通信，基于所有必要的工具（Namespace、CGroup等）来创建容器。容器进程作为<strong>runc</strong>的子进程启动，启动完毕后<strong>runc</strong>将会退出。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_04_IMG_6666.jpg" alt="2022_08_04_IMG_6666" style="zoom:50%;"><p><strong>shim</strong></p><p>shim是实现无daemon的容器不可或缺的工具。</p><p>一旦容器进程的父进程runc退出，相关联的containerd-shim进程就会成为容器的父进程。作为容器的父进程，shim的部分职责如下。</p><ul><li>保持所有STDIN和STDOUT流是开启状态，从而当daemon重启的时候，容器不会因为管道（pipe）的关闭而终止。</li><li>将容器的退出状态反馈给daemon。</li></ul><p><strong>daemon的作用</strong></p><p>随着越来越多的功能从daemon中拆解出来并被模块化，daemon目前的主要功能包括镜像管理、镜像构建、REST API、身份验证安全、核心网络以及编排。</p><h2 id="第6章-docker镜像" tabindex="-1"><a class="header-anchor" href="#第6章-docker镜像" aria-hidden="true">#</a> 第6章 Docker镜像</h2><h3 id="docker镜像" tabindex="-1"><a class="header-anchor" href="#docker镜像" aria-hidden="true">#</a> Docker镜像</h3><p>镜像可以从镜像仓库服务中拉取镜像，常见的镜像仓库服务是Docker Hub，拉取操作会将镜像下载到本地Docker主机，可以使用镜像启动一个或多个容器。</p><p>镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象，镜像内部是一个小巧的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。</p><p>镜像可以理解为一种构建时（build-time）结构，而容器可以理解为运行时（run-time）结构。</p><p>一旦容器从镜像启动后，二者就变成了相互依赖的关系，并且在镜像上启动的容器全部停止之前，镜像是无法被删除的。</p><p>Docker镜像的体积通常较小，镜像不包含内核——容器都是共享所在Docker主机的内核。Windows镜像通常比Linux镜像大一些。</p><p>Linux Docker主机本地镜像仓库通常位于**<code>/var/lib/docker/&lt;storage-driver&gt;</code>**下。</p><p><strong>镜像仓库服务</strong></p><p>Docker镜像存储在<strong>镜像仓库服务</strong>（Image Registry）中，Docker客户端的<strong>镜像仓库服务</strong>是可配置的，默认使用Docker Hub。</p><p><strong>镜像仓库服务</strong>包含多个<strong>镜像仓库</strong>（Image Repository），一个<strong>镜像仓库</strong>可以包含多个<strong>镜像</strong>。</p><p>Docker Hub也分为官方仓库（Official Repository）和非官方仓库（Unofficial Repository）。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_05_IMG_6677.jpg" alt="2022_08_05_IMG_6677" style="zoom:50%;"><p><strong>镜像命名和标签</strong></p><p>只需给出镜像的名字和标签，就能在官方仓库中定位一个镜像（采用“<code>:</code>”分隔符）。</p><p>从<strong>官方仓库</strong>拉取镜像：<code>docker image pull &lt;repository&gt;:&lt;tag&gt;</code>。</p><p>例：<code>docker image pull unbuntu:latest</code> or <code>docker image pull alpine:latest</code>。</p><p>注意：如果没有指定标签，则Docker会默认用户希望拉取为<code>latest</code>的镜像。标有<code>latest</code>标签的也不能保证是仓库中的最新镜像，例如<code>Alpine</code>仓库最新镜像的标签通常是<code>edge</code>。</p><p>拉取<strong>非官方镜像</strong>只需在仓库名称前加上Docker Hub的用户名或者组织名称。</p><p>例：<code>docker image pull nigelpoulton/tu-demo:v2</code>，从nigelpoulton这个用户的仓库中拉取tu-demo这个镜像，标签为v2。</p><p>拉取<strong>第三方镜像仓库</strong>中的镜像，只需在镜像仓库名称前加上第三方镜像仓库服务的DNS名称。</p><p>例：<code>docker pull gcr.io/nigelpoulton/tu-demo:v2</code>。</p><p><strong>为镜像打多个标签</strong></p><p>在<code>docker image pull</code>命令指定<code>-a</code>参数可以拉取仓库中的全部镜像。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_PY5YGA.png" alt="2022_08_07_PY5YGA" style="zoom:67%;"><p>上图两个不同标签的镜像实际指向同一个镜像，换句话说，这个镜像拥有两个标签。</p><p><strong>过滤 docker image ls 的输出内容</strong></p><p><code>--filter</code>参数过滤返回的镜像列表内容。</p><p>例：<code>docker image ls --filter dangling=true</code>，该指令返回悬虚（dangling）镜像，悬虚镜像是指在列表展示为<code>&lt;none&gt;:&lt;none&gt;</code>的镜像，这种镜像是因为构建了一个新镜像，然后为镜像打了一个已存在的标签，此时Docker会移除旧镜像上面的标签，旧镜像就称为了悬虚镜像。</p><p><code>docker image prune</code>命令会移除全部的悬虚镜像，加上<code>-a</code>则会移除包括没有被使用的镜像。</p><p>Docker目前支持如下的过滤器：</p><ul><li><code>dangling</code>，可以指定true或者false。</li><li><code>before</code>，需要镜像名称或者ID作为参数，返回在指定镜像之前被创建的全部镜像。</li><li><code>since</code>，与<code>before</code>相似，返回的是指定镜像之后创建的全部镜像。</li><li><code>label</code>，根据标注（label）的名称或值，对镜像进行过滤。</li><li><code>reference</code>，其他的过滤方式使用这个。</li></ul><p>例：<code>docker image ls --filter reference=&quot;*:latest&quot;</code>。</p><p><strong>通过 CLI 方式搜索Docker Hub</strong></p><p><code>docker seaerch</code>命令允许通过CLI的方式搜索Docker Hub。通过“NAME”字段的内容进行匹配。</p><p>例：<code>docker search nginx</code>。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_AkxSwA.png" alt="2022_08_07_AkxSwA" style="zoom:67%;"><p><code>--filter &quot;is-official=true&quot;</code>选项返回官方镜像。<code>--filter &quot;is-automated=true&quot;</code>返回自动创建的创建。</p><p>默认情况下，Docker只返回25条结果，可以指定<code>--limit</code>参数增加返回的内容条数，最多为100条。</p><h3 id="镜像和分层" tabindex="-1"><a class="header-anchor" href="#镜像和分层" aria-hidden="true">#</a> 镜像和分层</h3><p>Docker镜像由一些松耦合的只读镜像层组成。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_IMG_6700.jpg" alt="2022_08_07_IMG_6700" style="zoom:67%;"><p>Docker负责堆叠这些镜像层，并将它们表示为单个统一的镜像。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_L5qfoJ.png" alt="2022_08_07_L5qfoJ" style="zoom:50%;"><p>上图中，一个Pull complete代表一层。</p><p><code>docker image inspect</code>命令可以查看镜像分层的方式。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_pmUVLW.png" alt="2022_08_07_pmUVLW" style="zoom:67%;"><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>假如基于 Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_IMG_6701.jpg" alt="2022_08_07_IMG_6701" style="zoom:67%;"><p>在添加额外的镜像层的同时，镜像层保持是当前所有镜像层的组合。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_IMG_6702.jpg" alt="2022_08_07_IMG_6702" style="zoom:67%;"><p>上图中展示了一个三层镜像，在外部看来整个镜像只有6个文件，这是因为上层中的文件7是文件5的一个更新版本，上层镜像层中的文件覆盖了底层镜像层中的文件。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_IMG_6703.jpg" alt="2022_08_07_IMG_6703" style="zoom:67%;"><p><strong>共享镜像层</strong></p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_07_IpAYwn.png" alt="2022_08_07_IpAYwn" style="zoom:67%;"><p>上图中，那些标 Already exists 结尾的行，就是共享镜像层。当 pull 时，Docker注意到两个镜像的镜像层有一部分已经存在，此时会共享镜像层，这样做的好处是节省存储空间并提升性能。Docker 在 Linux 支持很多存储引擎，每个存储引擎都有自己的镜像分层、镜像层共享以及写时复制技术的具体实现，但其最终效果和用户体验是完全一致的。</p><p><strong>根据摘要拉取镜像</strong></p><p>镜像摘要（Image Digest），每一个镜像都有一个基于内容的密码散列值。镜像内容的变更一定会导致散列值的变更，每个镜像对应一个摘要，这意味着摘要是不可变的。</p><p><code>docker image ls ---digests</code>显示镜像的摘要。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_Lq2U54.png" alt="2022_08_08_Lq2U54" style="zoom:67%;"><p>上图显示镜像的两个摘要。</p><p><strong>镜像散列值（摘要）</strong></p><p>镜像本身就是一个配置对象，其中包含了镜像层的列表以及一些元数据信息。</p><p>镜像层才是实际数据存储的地方（比如文件等，镜像层之间是完全独立的，并没有从属于某个镜像集合的概念）。</p><p>镜像的唯一标识是一个加密ID，即配置对象本身的散列值。每个镜像层也由一个加密ID区分，其值为镜像层本身内容的散列值。这意味着修改镜像的内容或其他任意的镜像层，都会导致加密散列值的变化。所以，镜像和镜像层都是不可变的，任何改动都能很轻松地被辨别。这就是所谓的<strong>内容散列</strong>（Content Hash）。</p><p>在推送和拉取镜像的时候，都会对镜像层进行压缩，压缩会改变镜像内容，这以为着内容散列值会与镜像内容不相符，为了避免这个问题，每个镜像层同时会包含一个分发散列值（Distribution Hash），这是一个压缩版镜像的散列值，该散列值会用于校验拉取的镜像是否被篡改过。</p><p><strong>多架构的镜像</strong></p><p>多架构镜像（Multi-architecture Image）解决开发者在拉取镜像考虑是否与当前运行环境的架构匹配的问题。</p><p>Docker 通过 <strong>Manifest</strong> 列表来指定某个镜像标签支持的架构列表。其支持的每种架构，都有自己的 <strong>Manifest</strong> 定义，其中列举了该镜像的构成。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_IMG_6704.jpg" alt="2022_08_08_IMG_6704" style="zoom:33%;"><p>原理：在拉取镜像的时候，客户端会调用 Docker Hub 镜像仓库服务响应的 API 完成拉取，如果该镜像有 <strong>Manifest</strong> 列表且存在当前运行环境的架构，则 Docker Client 就会找到该架构对应的 <strong>Manifest</strong> 并解析出组成该镜像的镜像层加密ID，然后从 Docker Hub 二进制存储中拉取每个镜像层。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_aCd4gd.png" alt="2022_08_08_aCd4gd" style="zoom:67%;"><p>上图显示拉取 Golang 镜像，以容器方式启动，并执行 <code>go version</code> 命令，输出Go的版本和主机 OS/CPU 架构信息。</p><p><strong>删除镜像</strong></p><p><code>docker image rm</code>命令删除镜像。</p><p>删除操作会在当前主机上删除该镜像以及相关的镜像层。如果某个镜像层被多个镜像共享，那么只有当全部依赖该镜像层的镜像被删除后，该镜像层才会被删除。</p><p><code>docker image ls -q</code>获取全部镜像ID。<code>docker image rm $(docker image ls -q) -f</code>删除所有镜像。</p><h2 id="第7章-docker-容器" tabindex="-1"><a class="header-anchor" href="#第7章-docker-容器" aria-hidden="true">#</a> 第7章 Docker 容器</h2><p>容器是镜像的运行时实例。与虚拟机完整的操作系统之上相比，容器会共享其所在主机的操作系统/内核。</p><p><code>docker container run</code>命令启动容器，基础格式是<code>docker container run &lt;image&gt; &lt;app&gt;</code>，指定了启动所需的镜像以及要运行的应用。</p><ul><li><code>-it</code>参数可以将当前终端连接到容器的Shell终端之上。</li><li><code>--name xxx</code>参数为容器命名。</li><li><code>-d</code>参数指定容器在后台运行。</li><li><code>-p</code>参数将 Docker 主机的端口映射到容器内。</li></ul><p>容器会随着其中运行应用的退出而终止。Linux 容器会在Bash Shell退出后终止，Windows 容器会在PowerShell 进程终止后退出。</p><ul><li><code>docker container stop &lt;container-id or container-name&gt;</code> 命令手动停止容器运行。</li><li><code>docker container pause</code>暂停容器。</li><li><code>docker container start</code> 再次启动该容器。</li><li><code>docker container rm</code> 删除容器。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_IMG_6705.jpg" alt="2022_08_08_IMG_6705" style="zoom:67%;"><p>上图为虚拟机。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_IMG_6706.jpg" alt="2022_08_08_IMG_6706" style="zoom:67%;"><p>上图为容器。</p><p>Hypervisor 是<strong>硬件虚拟化</strong>（Hardware Virtualization）——Hypervisor将硬件物理资源划分为虚拟资源；容器是<strong>操作系统虚拟化</strong>（OS Virtuallization）——容器将系统资源划分为虚拟资源。</p><p><strong>虚拟机的额外开销</strong></p><p>虚拟机模型将底层资源划分到虚拟机当中，每个虚拟机都是包含了虚拟CPU、虚拟RAM等等资源，虚拟机的每个操作系统都需要消耗一点CPU、一点RAM、一点存储空间等，每个操作系统都面临被攻击的风险等问题。</p><p>容器模型具有在宿主机操作系统中运行的单个内核。容器共享一个操作系统/内核，大大节省资源。</p><p><strong>检查Docker daemon</strong></p><p>登录 Docker 主机后的第一件事是检查 Docker 是否正在运行。使用<code>docker version</code>命令。当命令输出包含 Client 和 Server 的内容时，说明 Docker 正在运行。</p><p>检查 Docker daemon 是否运行，<code>service docker status</code>命令，<code>systemctl is-active docker</code>命令这两条命令都可以检查。</p><p><strong>启动一个简单容器</strong></p><p>运行命令基础格式：<code>docker container run &lt;options&gt; &lt;image&gt;:&lt;tag&gt; &lt;app&gt;</code>。</p><p>例：<code>docker container run -it ubuntu:latest /bin/bash</code>。运行一个容器化版本的Ubuntu Linux。</p><h3 id="容器进程" tabindex="-1"><a class="header-anchor" href="#容器进程" aria-hidden="true">#</a> 容器进程</h3><p>启动 Ubuntu 容器之时，让容器运行 Bash Shell。这使得 Bash Shell 称为容器中运行的且唯一运行的进程。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_08_dQg4eQ.png" alt="2022_08_08_dQg4eQ" style="zoom:67%;"><p>上图中，容器只允许了一个 bash 的进程。这意味着如果通过<code>exit</code>退出 Bash Shell，那么容器也会退出（终止）。原因是容器如果不运行任何进程则无法存在——<strong>杀死容器中的主进程，则容器也会被杀死</strong>。</p><p>按下 <code>Ctrl+P+Q</code> 组合键会退出容器但不终止容器运行，保持容器在后台运行。</p><p><code>docker container exec</code>命令将终端重新连接到 Docker。例：<code>docker container exec -it 3027eb644874 bash</code>。</p><h3 id="容器生命周期" tabindex="-1"><a class="header-anchor" href="#容器生命周期" aria-hidden="true">#</a> 容器生命周期</h3><p>容器支持持久化技术，停止容器运行并不会损毁容器或者其中的数据。</p><p>容器的生命周期包含停止、启动、暂停以及重启容器，这些操作执行得很快。</p><p><strong>优雅地停止容器</strong></p><p>停止容器应该先停止容器运行，再进行删除操作，如果突然删除正在运行中的容器，会令容器和应用猝不及防，来不及处理后事。</p><h3 id="利用重启策略进行容器的自我修复" tabindex="-1"><a class="header-anchor" href="#利用重启策略进行容器的自我修复" aria-hidden="true">#</a> 利用重启策略进行容器的自我修复</h3><p>重启策略应用于每个容器，可以作为参数被强制传入 docker-container run 命令中，或者在 Compose 文件声明。</p><p>容器支持的重启策略包括 <strong>always</strong>、<strong>unless-stopped</strong> 和 <strong>on-failed</strong>。</p><p><strong>always</strong> 策略，除非容器被<code>docker container stop</code>命令停止，否则该策略会一直尝试重启处于停止状态的容器。当 Docker daemon 重启时，停止的容器也会被重启。使用<code>--restart always</code>参数指定该策略。</p><p>例：<code>docker container run --name neversaydie -it --restart always alpine sh</code>。当容器启动时，如果执行<code>exit</code>命令，容器将在停止后立马重启。</p><p><strong>unless-stopped</strong> 策略和 <strong>always</strong> 策略的区别是当 Docker daemon 重启时，<strong>unless-stopped</strong> 策略的容器不会被重启。</p><p><code>systemctl restart docker</code>命令重启 Docker daemon。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_09_FNT7Cp.png" alt="2022_08_09_FNT7Cp" style="zoom:67%;"><p><strong>on-failure</strong> 策略会退出容器并且返回值不是0的时候，重启容器。就算容器处于 stopped 状态，在 daemon 重启的时候，容器也会被重启。</p><p><strong>Web服务器示例</strong></p><p><code>docker container run -d --name webserver -p 80:8080 nigelpoulton/pluralsight-docker-ci</code>。将主机80端口映射到容器的8080端口，</p><p><strong>查看容器详情</strong></p><p>当构建 Docker 镜像的时候，可以通过嵌入指令来列出希望容器运行时启动的默认应用。<code>docker image inspect</code>命令查看运行容器时的镜像。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_09_PKiqTT.png" alt="2022_08_09_PKiqTT" style="zoom:67%;"><p>Cmd 一项中展示了容器将会执行的命令或应用，除非在启动的时候读者指定另外的应用。</p><p>在构建镜像时指定默认命令是一种很普遍的做法，因为这样可以简化容器的启动。</p><p><strong>快速清理</strong></p><p><code>docker container rm $(docker container ls -aq) -f</code>可以快速清除全部容器，<strong>这种操作一定不能在生产环境或者运行着重要容器的系统上运行！</strong></p><h3 id="容器——命令" tabindex="-1"><a class="header-anchor" href="#容器——命令" aria-hidden="true">#</a> 容器——命令</h3><ul><li><code>docker container run</code></li><li><code>docker container ls</code></li><li><code>docker container exec</code></li><li><code>docker container stop</code></li><li><code>docker container start</code></li><li><code>docker container rm</code></li><li><code>docker container inspect</code></li></ul><h2 id="第8章-应用的容器化" tabindex="-1"><a class="header-anchor" href="#第8章-应用的容器化" aria-hidden="true">#</a> 第8章 应用的容器化</h2><p>Docker 的核心思想就是如何将应用整合到容器中，并且能在容器中实际运行。将应用整合到容器中并且运行起来的这个过程，称为“容器化”（Containerizing），有时也叫“Docker化”（Dockerizing）。</p><p>容器能够简化应用的构建、部署和运行过程。</p><p>完整的应用容器化主要分为以下几个步骤：</p><ol><li>编写应用代码</li><li>创建一个 <strong>Dockerfile</strong>，其中包含应用的描述、依赖以及该如何运行这个应用。</li><li>对该 <strong>Dockerfile</strong> 执行<code>docker image build</code>命令。</li><li>等待 Docker 将应用程序构建到 Docker 镜像中。</li></ol><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_09_IMG_6714.jpg" alt="2022_08_09_IMG_6714" style="zoom:50%;"><h3 id="单体应用容器化" tabindex="-1"><a class="header-anchor" href="#单体应用容器化" aria-hidden="true">#</a> 单体应用容器化</h3><p><strong>Dockerfile</strong> 通常放到构建应用的根目录下。</p><p><strong>Dockerfile</strong> 的两个主要用途：</p><ul><li>对当前应用的描述。</li><li>指导 Docker 完成应用的容器化。</li></ul><div class="language-docker ext-docker line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;"># 将 alpine 作为当前镜像基础</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> alpine</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 指定维护者为nigelpoulton@hotmail.com</span></span>
<span class="line"><span style="color:#81A1C1;">LABEL</span><span style="color:#D8DEE9FF;"> maintainer=</span><span style="color:#A3BE8C;">&quot;nigelpoulton@hotmail.com&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Install Node and NPM</span></span>
<span class="line"><span style="color:#616E88;"># 安装 Node 和 Npm</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> apk add --update nodejs npm curl</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Copy app to /src</span></span>
<span class="line"><span style="color:#616E88;"># 将代码复制到镜像当中</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> . /src</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 设置新的工作目录</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /src</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># Install dependencies</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> npm install</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 记录应用的网络端口</span></span>
<span class="line"><span style="color:#81A1C1;">EXPOSE</span><span style="color:#D8DEE9FF;"> 8080</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 将 app.js 设置为默认运行应用</span></span>
<span class="line"><span style="color:#81A1C1;">ENTRYPOINT</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#A3BE8C;">&quot;node&quot;</span><span style="color:#D8DEE9FF;">, </span><span style="color:#A3BE8C;">&quot;./app.js&quot;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><ul><li>每个 <strong>Dockerfile</strong> 文件第一行都是<code>FROM</code>命令，<code>FROM</code>命令指定镜像作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新增镜像层添加到基础镜像层之上。</li><li><code>LABEL</code> 设置镜像的标签，每个标签是一个键值对，在一个镜像中可以通过添加标签的方式来为镜像添加自定义元数据。备注维护者信息又助于为该镜像的潜在使用者提供沟通途径。</li><li><code>RUN</code>指令会在<code>FROM</code>指定的镜像基础之上运行命令。</li><li><code>COPY</code>指令将应用相关文件从构建上下文复制到当前镜像中，并且新建一个镜像层来存储。</li><li><code>WORKDIR</code>指令为 <strong>Dockerfile</strong> 中尚未执行的指令设置工作目录。该指令通过镜像元数据的形式保存下来，不会新增镜像层。</li><li><code>EXPOSE</code>指令完成相应端口的设置。该指令通过镜像元数据的形式保存下来，不会新增镜像层。</li><li><code>ENTRYPOINT</code>指令来指定当前镜像的入口程序。该指令通过镜像元数据的形式保存下来，不会新增镜像层。</li></ul><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_09_IMG_6715.jpg" alt="2022_08_09_IMG_6715" style="zoom:50%;"><p>例：<code>docker image build -t web:latest .</code>容器化该应用。</p><p><code>-t</code>参数指定要创建的目标镜像。</p><p>注意：一定要在命令最后包含这个点，.表示Dockerfile文件路径。</p><p><strong>推送镜像到仓库</strong></p><p><code>docker login</code>命令登录到 Docker Hub。</p><p>推送 Docker 镜像之前，还需要为镜像打标签。这是因为 Docker 在镜像推送的过程中需要如下信息：</p><ul><li>Registry（镜像仓库服务）。</li><li>Repository（镜像仓库）。</li><li>Tag（镜像标签）。</li></ul><p>当没有为 Registry 和 Tag 指定值时，Docker 默认<code>Registry=docker.io、Tag=latest</code>。</p><p><code>docker image tag &lt;current-tag&gt; &lt;new-tag&gt;</code>为镜像打标签。</p><p><code>docker image push &lt;current-tag&gt;</code>推送镜像到Docker Hub。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_10_IMG_6716.jpg" alt="2022_08_10_IMG_6716" style="zoom:50%;"><p><strong>运行容器应用</strong></p><p><code>docker container run -d --name c1 -p 80:8080 web:latest</code>运行容器并将容器的8080端口映射到主机80端口。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_10_os2ntp.png" alt="2022_08_10_os2ntp" style="zoom:50%;"><p><strong>详述</strong></p><p><strong>Dockerfile</strong> 的指令不区分大小写，通常都是大写的方式。</p><p>关于如何区分命令是否会新建镜像层，一个基本原则是，如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层；如果只是告诉 Docker 如何完成构建或者如何运行应用程序，那么就只会添加镜像的元数据。</p><p><code>docker image histroy xxx</code>查看在构建镜像的过程中都执行了哪些指令。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_10_4HvXVf.png" alt="2022_08_10_4HvXVf" style="zoom:50%;"><p>上图中，顺序是自下而上的。SIZE有大小的指令会新建镜像层。</p><p>使用<code>FROM</code>引用官方基础镜像是一个很好的习惯，因为官方的镜像通常会遵循一些最佳实践。</p><h3 id="生产环境的多阶段构建" tabindex="-1"><a class="header-anchor" href="#生产环境的多阶段构建" aria-hidden="true">#</a> 生产环境的多阶段构建</h3><p>对于 Docker 镜像来说，过大的体积并不好。越大则越慢，这意味着更难使用，而且可能更加脆弱，更容易遭受攻击。</p><p>Docker 镜像应该尽量小，对于生产环境镜像来说，目标是将其缩小到仅包含运行应用所必须的内容即可。</p><p>**多阶段构建（Multi-Stage Build）**能够在不增加复杂性的情况下优化构建过程。</p><p>多阶段构建方式使用一个Dockerfile，其中包含多个<code>FROM</code>指令。每一个<code>FORM</code>指令都是一个新的构建阶段（Build Stage），并且可以方便地复制之前阶段的构件。</p><div class="language-docker ext-docker line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;"># 第一个构建阶段，别名 storefront</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> node:latest </span><span style="color:#81A1C1;">AS</span><span style="color:#D8DEE9FF;"> storefront</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /usr/src/atsea/app/react-app</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> react-app .</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> npm install</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> npm run build</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 第二个构建阶段，别名 appserver</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> maven:latest </span><span style="color:#81A1C1;">AS</span><span style="color:#D8DEE9FF;"> appserver</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /usr/src/atsea</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> pom.xml .</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency:resolve</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> . .</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 第三个构建阶段，别名 production</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> java:8-jdk-alpine </span><span style="color:#81A1C1;">AS</span><span style="color:#D8DEE9FF;"> production</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> adduser -Dh /home/gordon gordon</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /static</span></span>
<span class="line"><span style="color:#616E88;"># 从 storefront 阶段生成的镜像中复制一些应用代码过来</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> --from=storefront /usr/src/atsea/app/react-app/build/ .</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /app</span></span>
<span class="line"><span style="color:#616E88;"># 从 appserver 阶段生成的镜像中复制应用相关的代码</span></span>
<span class="line"><span style="color:#81A1C1;">COPY</span><span style="color:#D8DEE9FF;"> --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .</span></span>
<span class="line"><span style="color:#81A1C1;">ENTRYPOINT</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#A3BE8C;">&quot;java&quot;</span><span style="color:#D8DEE9FF;">, </span><span style="color:#A3BE8C;">&quot;-jar&quot;</span><span style="color:#D8DEE9FF;">, </span><span style="color:#A3BE8C;">&quot;/app/AtSea-0.0.1-SNAPSHOT.jar&quot;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"><span style="color:#81A1C1;">CMD</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#A3BE8C;">&quot;--spring.profiles.active=postgres&quot;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><code>COPY --from</code>指令从之前的阶段构建的镜像中，<strong>仅复制生产环境相关的应用代码</strong>，不会复制生产环境不需要的构件。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_10_PE4hzG.png" alt="2022_08_10_PE4hzG" style="zoom:50%;"><p>上面经过三个阶段的构建，会产生多个镜像，最终的production镜像将是精简的生产环境镜像。</p><h3 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a> 最佳实践</h3><ol><li><p>利用构建缓存</p><p>Docker 的构建过程利用了缓存机制，会第二次构建开始将重复利用第一次缓存下来的镜像层，节省构建时间。</p><p>Docker 会检查 Dockerfile 每一条指令是否命中与该指令对应的镜像层，如果有则缓存命中（Cache Hit）。</p><p>一旦有指令在缓存中未命中，则后续的整个构建过程将不再使用缓存。</p><p>对<code>docker image build</code>指令加上<code>--no-cache=true</code>参数强制忽略对缓存的使用。</p></li><li><p>合并镜像</p><p>当进行中层数太多时，合并是一个不错的优化方式。</p><p>合并镜像的缺点是无法共享镜像层。这会导致存储空间的低效利用。</p><p>执行<code>docker image build</code>命令时添加<code>--squash</code>参数来创建一个合并的镜像。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_10_IMG_6723.jpg" alt="2022_08_10_IMG_6723" style="zoom:33%;"></li><li><p>使用 no-install-recommends</p><p>使用<strong>apt</strong>包管理器时，应该在执行<code>apt-get install</code>时添加<code>no-install-recommends</code>参数，确保<strong>apt</strong>仅安装核心依赖。</p></li></ol><h2 id="第9章-使用-docker-compose-部署" tabindex="-1"><a class="header-anchor" href="#第9章-使用-docker-compose-部署" aria-hidden="true">#</a> 第9章 使用 Docker Compose 部署</h2><p>多数现代应用通过多个更小的服务互相协同来组成一个完整可用的应用。部署和管理繁多的服务是困难的，这正是<strong>Docker Compose</strong>要解决的问题。</p><p><strong>Docker Compose</strong>通过一个声明式的配置文件描述整个应用，从而使用一条命令完成部署。应用部署成功后，还可以通过一系列简单的命令实现对齐完整生命周期的管理。</p><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h3><p><strong>Docker Compose</strong>的前身是<strong>Fig</strong>，<strong>Fig</strong>是由 Orchard 公司开发的一个基于<strong>Docker</strong>的<strong>Python</strong>工具，允许用户基于一个<strong>YAML</strong>文件定义多容器应用，可以使用<code>fig</code>命令行工具进行应用的部署，还可以对应用进行全生命周期的管理。</p><p>2014年Docker公司收购了 Orchard 公司，将<strong>Fig</strong>更名为<strong>Docker Compose</strong>。命令行工具也从<code>fig</code>更名为<code>docker-compose</code>。</p><p><strong>安装</strong></p><p><strong>Docker Compose</strong>在 mac 会随 Docker 安装附带上，Linux 需要自行安装。</p><h3 id="compose文件" tabindex="-1"><a class="header-anchor" href="#compose文件" aria-hidden="true">#</a> Compose文件</h3><p><strong>Docker Compose</strong>使用<strong>YAML</strong>文件来定义多服务的应用，<strong>YAML</strong>是<strong>JSON</strong>的一个子集，因此也可以使用<strong>JSON</strong>。</p><p><strong>Docker Compose</strong>默认使用文件名<code>docker-compose.yml</code>，也可以使用<code>-f</code>参数指定具体文件。</p><div class="language-yaml ext-yml line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;"># 版本号3.5</span></span>
<span class="line"><span style="color:#8FBCBB;">version</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">3.5</span><span style="color:#ECEFF4;">&quot;</span></span>
<span class="line"><span style="color:#616E88;"># 定义两个服务，一个是web-fe，另一个是redis</span></span>
<span class="line"><span style="color:#8FBCBB;">services</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#ECEFF4;">	</span><span style="color:#616E88;"># web-fe作为容器名</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#8FBCBB;">web-fe</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#ECEFF4;">  	</span><span style="color:#616E88;"># 指定Docker基于当前目录下Dockerfile（在下面的代码块中）中定义的指令来构建一个新镜像。该镜像会被用于启动该服务的容器。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">build</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">.</span></span>
<span class="line"><span style="color:#ECEFF4;">    </span><span style="color:#616E88;"># 指定Docker在容器中执行名为app.py的Python脚本作为主程序。不过这一点在Dockerfile中可以做到。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">command</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#A3BE8C;">python app.py</span></span>
<span class="line"><span style="color:#ECEFF4;">    </span><span style="color:#616E88;"># 指定Docker将容器内（-target）的5000端口映射到主机（published）的5000端口。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">ports</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#ECEFF4;">-</span><span style="color:#D8DEE9FF;"> </span><span style="color:#8FBCBB;">target</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">5000</span></span>
<span class="line"><span style="color:#D8DEE9FF;">        </span><span style="color:#8FBCBB;">published</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">5000</span></span>
<span class="line"><span style="color:#ECEFF4;">    </span><span style="color:#616E88;"># 使得Docker可以将服务连接到指定的网络上。这个网络应该是已经存在的，或者是networks一级key中定义的网络。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">networks</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#ECEFF4;">-</span><span style="color:#D8DEE9FF;"> </span><span style="color:#A3BE8C;">counter-net</span></span>
<span class="line"><span style="color:#ECEFF4;">    </span><span style="color:#616E88;"># 指定Docker将counter-vol卷（source:）挂载到容器的/code（target:）。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">volumes</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#ECEFF4;">-</span><span style="color:#D8DEE9FF;"> </span><span style="color:#8FBCBB;">type</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#A3BE8C;">volume</span></span>
<span class="line"><span style="color:#D8DEE9FF;">        </span><span style="color:#8FBCBB;">source</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#A3BE8C;">counter-vol</span></span>
<span class="line"><span style="color:#D8DEE9FF;">        </span><span style="color:#8FBCBB;">target</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#A3BE8C;">/code</span></span>
<span class="line"><span style="color:#ECEFF4;">  </span><span style="color:#616E88;"># redis作为容器名</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#8FBCBB;">redis</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#ECEFF4;">  	</span><span style="color:#616E88;"># 基于redis:alpine镜像启动一个名为redis的容器。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">image</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> </span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">redis:alpine</span><span style="color:#ECEFF4;">&quot;</span></span>
<span class="line"><span style="color:#ECEFF4;">    </span><span style="color:#616E88;"># 配置redis容器连接到counter-net网络。</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#8FBCBB;">networks</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">      </span><span style="color:#8FBCBB;">counter-net</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 定义了一个名为counter-net的网络</span></span>
<span class="line"><span style="color:#8FBCBB;">networks</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#8FBCBB;">counter-net</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"></span>
<span class="line"><span style="color:#616E88;"># 定义一个名为counter-vol的卷</span></span>
<span class="line"><span style="color:#8FBCBB;">volumes</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">  </span><span style="color:#8FBCBB;">counter-vol</span><span style="color:#ECEFF4;">:</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><div class="language-docker ext-docker line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#616E88;"># 基础镜像</span></span>
<span class="line"><span style="color:#81A1C1;">FROM</span><span style="color:#D8DEE9FF;"> python:3.7-alpine</span></span>
<span class="line"><span style="color:#616E88;"># 将app复制到镜像中</span></span>
<span class="line"><span style="color:#81A1C1;">ADD</span><span style="color:#D8DEE9FF;"> . /code</span></span>
<span class="line"><span style="color:#81A1C1;">WORKDIR</span><span style="color:#D8DEE9FF;"> /code</span></span>
<span class="line"><span style="color:#81A1C1;">RUN</span><span style="color:#D8DEE9FF;"> pip install -r requirements.txt</span></span>
<span class="line"><span style="color:#81A1C1;">CMD</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#A3BE8C;">&quot;python&quot;</span><span style="color:#D8DEE9FF;">, </span><span style="color:#A3BE8C;">&quot;app.py&quot;</span><span style="color:#D8DEE9FF;">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><code>version</code>必须指定，且总是位于文件的第一行，它定义Compose文件格式的版本。</li><li><code>services</code>用于定义不同的应用服务。<strong>Docker Compose</strong>会将每个服务部署在各自的容器中。</li><li><code>networks</code>用于指引 Docker 创建新的网络。默认情况下<strong>Docker Compose</strong>会创建<strong>bridge</strong>网络。这是一种单主机网络，只能够实现同一主机上容器的连接。可以使用<code>driver</code>属性来指定不同的网络类型。</li><li><code>volumes</code>用于指引 Docker 来创建新的卷。</li></ul><p>常用的启动一个<strong>Compose</strong>应用（通过<strong>Compose</strong>文件定义的多容器应用称为“<strong>Compose应用</strong>”）的方式就是<code>docker-compose up</code>命令。它会构建所需的镜像，创建网络和卷，并启动容器。</p><p>默认情况下，<code>docker-compose up</code>会查找名为<code>docker-compose.yml</code>或<code>docker-compose.yaml</code>的<strong>Compose</strong>文件。<strong>Docker Compose</strong>会将项目名称和<strong>Compose</strong>文件中定义的资源名称连起来，作为新构建的镜像的名称。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_11_GDrbxT.png" alt="2022_08_11_GDrbxT" style="zoom:80%;"><p><code>-d</code>参数在后台启动应用。</p><p><code>docker network ls</code>查看<strong>docker</strong>网络。<code>docker volume ls</code>查看卷。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_11_LS4hFl.png" alt="2022_08_11_LS4hFl" style="zoom:67%;"><h3 id="使用-docker-compose-管理应用" tabindex="-1"><a class="header-anchor" href="#使用-docker-compose-管理应用" aria-hidden="true">#</a> 使用 Docker Compose 管理应用</h3><p><code>docker-compose down</code>命令停止应用。</p><p>停止应用并不会删除<strong>卷</strong>，因为<strong>卷</strong>应该是用于数据长期持久化存储的。</p><p><code>docker-compose ps</code>命令查看应用状态。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_08_11_yqX3Qx.png" alt="2022_08_11_yqX3Qx" style="zoom:67%;"><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h3><ul><li><code>docker-compose up</code>部署一个<strong>Compose</strong>应用。</li><li><code>docker-compose stop</code>命令停止<strong>Compose</strong>应用相关的所有容器。</li><li><code>docker-compose restart</code>命令重新启动。如果用户在停止该应用后对其进行了变更，变更的内容不会反映在重启后的应用中，这时需要重新部署应用使变更生效。</li><li><code>docker-compose rm</code>命令用于删除已停止的<strong>Compose</strong>应用。它会删除容器和网络，但是不会删除卷和镜像。</li><li><code>docker-compose ps</code>命令用于列出<strong>Compose</strong>应用中的各个容器。</li><li><code>docker-compose down</code>会停止并删除运行中的<strong>Compose</strong>应用。它会删除容器和网络，但不会删除卷和镜像。</li></ul><h2 id="第10章-docker-swarm" tabindex="-1"><a class="header-anchor" href="#第10章-docker-swarm" aria-hidden="true">#</a> 第10章 Docker Swarm</h2><p>跳过</p><h2 id="第11章-docker网络" tabindex="-1"><a class="header-anchor" href="#第11章-docker网络" aria-hidden="true">#</a> 第11章 Docker网络</h2><p>Docker 在容器内部运行应用，这些应用之间的交互依赖于大量不同的网络。</p><p>Docker 网络架构源自一种叫作容器网络模型（CNM）的方案。Libnetwork 是 Docker 对 CNM 的一种实现，提供了 Docker 核心网络架构的全部功能。</p><p>Docker 封装了一系列本地驱动，其中包括单机桥接网络（Single-Host Bridge Network）、多机覆盖网络（Multi-Host Overlay），并且支持接入现有 VLAN（虚拟局域网）。</p><p>（暂时学到这，网络这块因为基础比较薄弱，看起来吃力，打算先看《计算机网络》，后续如果Docker用得多了会打算回来看这部分）。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: czl624824554@163.com">chenzilin</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog-site/assets/app.5b55431a.js" defer></script>
  </body>
</html>
