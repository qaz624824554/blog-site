<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/578220.jpg"><title>Leon Chen</title><meta name="description" content="">
    <link rel="modulepreload" href="/blogs/assets/app.7d2acf8d.js"><link rel="modulepreload" href="/blogs/assets/浏览器的基本工作原理.html.bace5466.js"><link rel="modulepreload" href="/blogs/assets/浏览器的基本工作原理.html.8b700cd1.js"><link rel="modulepreload" href="/blogs/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blogs/assets/style.fa95e7d7.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blogs/" class=""><img class="logo" src="/blogs/images/578220.jpg" alt="Leon Chen"><span class="site-name can-hide">Leon Chen</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blogs/program" class="" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blogs/promote" class="" aria-label="课外提升"><!--[--><!--]--> 课外提升 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blogs/questions" class="router-link-active" aria-label="疑问清单"><!--[--><!--]--> 疑问清单 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blogs/program" class="" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blogs/promote" class="" aria-label="课外提升"><!--[--><!--]--> 课外提升 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blogs/questions" class="router-link-active" aria-label="疑问清单"><!--[--><!--]--> 疑问清单 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#浏览器的多进程架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器的多进程架构"><!--[--><!--]--> 浏览器的多进程架构 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#进程-process-和线程-thread" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程（process）和线程（thread）"><!--[--><!--]--> 进程（process）和线程（thread） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#浏览器的架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器的架构"><!--[--><!--]--> 浏览器的架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#chrome-多进程架构的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="Chrome 多进程架构的优缺点"><!--[--><!--]--> Chrome 多进程架构的优缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#iframe-的渲染-site-isolation" class="router-link-active router-link-exact-active sidebar-item" aria-label="iframe 的渲染 -- Site Isolation"><!--[--><!--]--> iframe 的渲染 -- Site Isolation <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#导航过程发生了什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="导航过程发生了什么"><!--[--><!--]--> 导航过程发生了什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blogs/questions/Brower/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html#渲染进程是如何工作的" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染进程是如何工作的"><!--[--><!--]--> 渲染进程是如何工作的 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="浏览器的多进程架构" tabindex="-1"><a class="header-anchor" href="#浏览器的多进程架构" aria-hidden="true">#</a> 浏览器的多进程架构</h2><p>一个好的程序常常被划分为几个相互独立又彼此配合的模块，浏览器也是如此，以 Chrome 为例，它由多个进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_2C966CA0-FBC9-44DC-8D55-351FA6648C83.jpg" alt="2022_03_09_2C966CA0-FBC9-44DC-8D55-351FA6648C83"></p><h3 id="进程-process-和线程-thread" tabindex="-1"><a class="header-anchor" href="#进程-process-和线程-thread" aria-hidden="true">#</a> 进程（process）和线程（thread）</h3><p>当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。</p><p>一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。</p><h3 id="浏览器的架构" tabindex="-1"><a class="header-anchor" href="#浏览器的架构" aria-hidden="true">#</a> 浏览器的架构</h3><p>如果要开发一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_DA5118A6-FC84-42EB-B40C-61BE3E13FF9D.jpg" alt="2022_03_09_DA5118A6-FC84-42EB-B40C-61BE3E13FF9D"></p><p>不同浏览器采用了不同的架构模式，这里并不存在标准。</p><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_73CAE21B-E76C-441A-A470-B1E40CF5B14D.jpg" alt="2022_03_09_73CAE21B-E76C-441A-A470-B1E40CF5B14D"></p><p>具体说来，Chrome 的主要进程及其职责如下：</p><ul><li>Browser Process：</li></ul><ol><li>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</li><li>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</li></ol><ul><li>Renderer Process：</li></ul><ol><li>负责一个 tab 内关于网页呈现的所有事情</li></ol><ul><li>Plugin Process：</li></ul><ol><li>负责控制一个网页用到的所有插件，如 flash</li></ol><ul><li>GPU Process</li></ul><ol><li>负责处理 GPU 相关的任务</li></ol><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_F295BB8A-7FCD-4655-BEE2-4AE6B554B539.jpg" alt="2022_03_09_F295BB8A-7FCD-4655-BEE2-4AE6B554B539"></p><p>Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，右键单击还可以查看更多类别信息。</p><p>通过「页面右上角的三个点点点 --- 更多工具 --- 任务管理器」即可打开相关面板，</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_5EFF9426-4119-4F35-AAB6-2AF9090876D0.jpg" alt="2022_03_09_5EFF9426-4119-4F35-AAB6-2AF9090876D0"></p><h3 id="chrome-多进程架构的优缺点" tabindex="-1"><a class="header-anchor" href="#chrome-多进程架构的优缺点" aria-hidden="true">#</a> Chrome 多进程架构的优缺点</h3><p>优点</p><ol><li>某一渲染进程出问题不会影响其他进程</li><li>更为安全，在系统层面上限定了不同进程的权限</li></ol><p>缺点</p><p>由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。</p><p>为了节省内存，Chrome 限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。</p><p>Chrome 把浏览器不同程序的功能看做服务，这些服务可以方便的分割为不同的进程或者合并为一个进程。以 Broswer Process 为例，如果 Chrome 运行在强大的硬件上，它会分割不同的服务到不同的进程，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存。</p><h3 id="iframe-的渲染-site-isolation" tabindex="-1"><a class="header-anchor" href="#iframe-的渲染-site-isolation" aria-hidden="true">#</a> iframe 的渲染 -- Site Isolation</h3><p>在上面的进程图中我们还可以看到一些进程下还存在着 Subframe，这就是 Site Isolation 机制作用的结果。</p><p>Site Isolation 机制从 Chrome 67 开始默认启用。这种机制允许在同一个 Tab 下的跨站 iframe 使用单独的进程来渲染，这样会更为安全。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_066E22EC-A443-43A2-8422-A5F3D41F7C28.jpg" alt="2022_03_09_066E22EC-A443-43A2-8422-A5F3D41F7C28"></p><blockquote><p>Site Isolation 被大家看做里程碑式的功能， 其成功实现是多年工程努力的结果。Site Isolation 不是简单的叠加多个进程。这种机制在底层改变了 iframe 之间通信的方法，Chrome 的其它功能都需要做对应的调整，比如说 devtools 需要相应的支持，甚至 Ctrl + F 也需要支持。</p></blockquote><h2 id="导航过程发生了什么" tabindex="-1"><a class="header-anchor" href="#导航过程发生了什么" aria-hidden="true">#</a> 导航过程发生了什么</h2><p>也许大多数人使用 Chrome 最多的场景就是在地址栏输入关键字进行搜索或者输入地址导航到某个网站，我们来看看浏览器是怎么看待这个过程的。</p><p>我们知道浏览器 Tab 外的工作主要由 Browser Process 掌控，Browser Process 又对这些工作进一步划分，使用不同线程进行处理：</p><ul><li>UI thread ： 控制浏览器上的按钮及输入框；</li><li>network thread: 处理网络请求，从网上获取数据；</li><li>storage thread: 控制文件等的访问；</li></ul><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_BFC7B817-9F34-4569-B6C5-A8D20D40B17D.jpg" alt="2022_03_09_BFC7B817-9F34-4569-B6C5-A8D20D40B17D"></p><p>浏览器主进程中的不同线程</p><p>当我们在浏览器地址栏中输入文字，并点击回车获得页面内容的过程在浏览器看来可以分为以下几步：</p><ol><li>处理输入</li></ol><p>UI thread 需要判断用户输入的是 URL 还是 query；</p><ol start="2"><li>开始导航</li></ol><p>当用户点击回车键，UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。</p><p>network thread 会执行 DNS 查询，随后为请求建立 TLS 连接。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_F75A6A42-11C7-42BC-93EB-1463D6E4B605.jpg" alt="2022_03_09_F75A6A42-11C7-42BC-93EB-1463D6E4B605"></p><p>UI thread 通知 Network thread 加载相关信息</p><p>如果 network thread 接收到了重定向请求头如 301，network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发。</p><ol start="3"><li>读取响应</li></ol><p>当请求响应返回的时候，network thread 会依据 <a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener noreferrer">Content-Type<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 及 MIME Type sniffing 判断响应内容的格式。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_69720479-0DB9-4183-9A53-EAAA995E5783.jpg" alt="2022_03_09_69720479-0DB9-4183-9A53-EAAA995E5783"></p><p>判断响应内容的格式</p><p>如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。</p><p><a href="https://link.zhihu.com/?target=https%3A//safebrowsing.google.com/" target="_blank" rel="noopener noreferrer">Safe Browsing<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 <a href="https://link.zhihu.com/?target=https%3A//www.chromium.org/Home/chromium-security/corb-for-developers" target="_blank" rel="noopener noreferrer">CORB<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 检测也会触发确保敏感数据不会被传递给渲染进程。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_2D4684D6-4DC7-4F2B-85A1-1A5A5166997F.jpg" alt="2022_03_09_2D4684D6-4DC7-4F2B-85A1-1A5A5166997F"></p><ol start="4"><li>查找渲染进程</li></ol><p>当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_C3030765-3104-4DCE-8C97-E411A753CC4B.jpg" alt="2022_03_09_C3030765-3104-4DCE-8C97-E411A753CC4B"></p><p>收到 Network thread 返回的数据后，UI thread 查找相关的渲染进程</p><blockquote><p>由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。</p></blockquote><ol start="5"><li>确认导航</li></ol><p>讲过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。</p><p>此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_0A697578-6FCE-48B8-B04B-40E25069C094.jpg" alt="2022_03_09_0A697578-6FCE-48B8-B04B-40E25069C094"></p><p>Browser Process 和 Renderer Process 通过 IPC 通信，请求 Renderer Process 渲染页面</p><ol start="6"><li>额外的步骤</li></ol><p>一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_4BAA359F-1722-485D-86AF-39CCB2D029D2.jpg" alt="2022_03_09_4BAA359F-1722-485D-86AF-39CCB2D029D2"></p><p>Renderer Process 发送 IPC 消息通知 browser process 页面已经加载完成</p><p>当然上面的流程只是网页首帧渲染完成，在此之后，客户端依旧可下载额外的资源渲染出新的视图。</p><p>在这里我们可以明确一点，所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页内容的过程大部分时候不会涉及到其它的进程。不过也许你也曾经监听过 beforeunload 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_504B19E4-3568-443E-99E7-953466F190F2.jpg" alt="2022_03_09_504B19E4-3568-443E-99E7-953466F190F2"></p><p>浏览器进程发送 IPC 消息给渲染进程，通知要离开当前网站了</p><p>如果导航由 renderer process 触发（比如在用户点击某链接，或者JS执行 <code>window.location = &quot;[http://newsite.com](https://link.zhihu.com/?target=http%3A//newsite.com/)&quot; </code> ） renderer process 会首先检查是否有 <code>beforeunload</code> 事件处理器，导航请求由 renderer process 传递给 Browser process 。</p><p>如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 <code>unload</code> 等事件。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_4DAD8CD2-0230-424E-BB57-5CA5DCB9D232.jpg" alt="2022_03_09_4DAD8CD2-0230-424E-BB57-5CA5DCB9D232"></p><p>浏览器进程发送 IPC 消息到新的渲染进程通知渲染新的页面，同时通知旧的渲染进程卸载</p><p>除了上述流程，有些页面还拥有 Service Worker （服务工作线程），Service Worker 让开发者对本地缓存及判断何时从网络上获取信息有了更多的控制权，如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了。</p><p>值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。</p><p>当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_5322C7A9-E678-4CF6-B3FC-D76773BBC005.jpg" alt="2022_03_09_5322C7A9-E678-4CF6-B3FC-D76773BBC005"></p><p>Service Worker 依据具体情形做处理</p><p>如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。</p><hr><h2 id="渲染进程是如何工作的" tabindex="-1"><a class="header-anchor" href="#渲染进程是如何工作的" aria-hidden="true">#</a> 渲染进程是如何工作的</h2><p>渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_28_7ACD520A-7538-4213-96B9-5365547E1046.jpg" alt="2022_03_28_7ACD520A-7538-4213-96B9-5365547E1046"></p><p>渲染进程包含的线程</p><ol><li>主线程 Main thread</li><li>工作线程 Worker thread</li><li>排版线程 Compositor thread</li><li>光栅线程 Raster thread</li></ol><p>后文我们将逐步介绍不同线程的职责，在此之前我们先看看渲染的流程</p><ol><li>构建 DOM</li></ol><p>当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会解析文本字符串为 DOM。</p><p>渲染 html 为 DOM 的方法由 <a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/" target="_blank" rel="noopener noreferrer">HTML Standard<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 定义。</p><ol start="2"><li>加载次级的资源</li></ol><p>网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 <code>&lt;img&gt;</code> <code>&lt;link&gt;</code> 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。</p><ol start="3"><li>JS 的下载与执行</li></ol><p>当遇到 <code>&lt;script&gt;</code> 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 <code>document.write()</code>等API）。</p><p>不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在<code>&lt;script&gt;</code> 标签上添加了 <code>async</code> 或 <code>defer</code> 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。更多的方法可参考 <a href="https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/resource-prioritization" target="_blank" rel="noopener noreferrer">Resource Prioritization – Getting the Browser to Help You<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ol start="4"><li>样式计算</li></ol><p>仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_20C9B758-1119-4F7B-8251-A00FC13F24D5.jpg" alt="2022_03_09_20C9B758-1119-4F7B-8251-A00FC13F24D5"></p><p>渲染进程主线程计算每一个元素节点的最终样式值</p><ol start="5"><li>获取布局</li></ol><p>想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：</p><p>通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 <code>display:none</code> ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_36369A3A-95AD-4081-BBF7-C4B6F8AD1EE4.jpg" alt="2022_03_09_36369A3A-95AD-4081-BBF7-C4B6F8AD1EE4"></p><p>主线程遍历 DOM 及 对应元素的样式，构建出布局树</p><ol start="6"><li>绘制各元素</li></ol><p>即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_EF476583-19FB-4BE8-9365-98C994588C5E.jpg" alt="2022_03_09_EF476583-19FB-4BE8-9365-98C994588C5E"></p><p>主线程依据布局树构建绘制记录</p><ol start="7"><li>合成帧</li></ol><p>复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。</p><p>主线程会遍历布局树来创建层树（layer tree），添加了 <code>will-change</code> CSS 属性的元素，会被看做单独的一层。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_3CDB1654-AECD-4FB8-8BEC-4CD075E12B95.jpg" alt="2022_03_09_3CDB1654-AECD-4FB8-8BEC-4CD075E12B95"></p><p>主线程遍历布局树生成层树</p><p>你可能会想给每一个元素都添加上 <code>will-change</code>，不过组合过多的层也许会比在每一帧都栅格化页面中的某些小部分更慢。</p><p>一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_5E391EFF-61E6-414B-9B52-8F798DA4CB08.jpg" alt="2022_03_09_5E391EFF-61E6-414B-9B52-8F798DA4CB08"></p><p>栅格线程会栅格化每一个磁贴并存储在 GPU 显存中</p><p>一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。</p><p>合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。</p><p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_03_09_9E6D800E-8615-4285-AD31-47F4A5ECD3E8.jpg" alt="2022_03_09_9E6D800E-8615-4285-AD31-47F4A5ECD3E8"></p><p>合成器线程会发送合成帧给 GPU 渲染</p><p>合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么<a href="https://link.zhihu.com/?target=https%3A//www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank" rel="noopener noreferrer">合成器相关的动画<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: czl624824554@163.com">chenzilin</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blogs/assets/app.7d2acf8d.js" defer></script>
  </body>
</html>
